<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query | æ³¢æ³¢æ²™ğŸ </title><meta name=keywords content="Game Dev,PhysX"><meta name=description content="æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXåœºæ™¯æŸ¥è¯¢çš„ä¸€äº›å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode, D"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_scenequery/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query"><meta property="og:description" content="æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXåœºæ™¯æŸ¥è¯¢çš„ä¸€äº›å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode, D"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/using_physx_scenequery/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query"><meta name=twitter:description content="æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXåœºæ™¯æŸ¥è¯¢çš„ä¸€äº›å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode, D"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query","item":"https://pps43.github.io/posts/using_physx_scenequery/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query","name":"PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query","description":"æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXåœºæ™¯æŸ¥è¯¢çš„ä¸€äº›å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode, D","keywords":["Game Dev","PhysX"],"articleBody":" æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXåœºæ™¯æŸ¥è¯¢çš„ä¸€äº›å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚\nPhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode, Docï¼‰çš„ä¸€äº›ç»éªŒï¼Œæœ‰ä¸å°‘å¯¹å®˜æ–¹èµ„æ–™çš„è¡¥å……ã€‚\nWarm-up A Scene in PhysX engine is a container of objects in a hierachical manner.\n--- title: Scene Hierachy --- classDiagram direction LR class world class scene { Flags Gravity ... } class actor { ActorFlags Name GlobalPose ... } class shape { Flags GeometryType LocalPose QueryFilterData SimulationFilterData ... } class geometry { ... } class material { friction restitution damping } world \"1\"*.. \"N\"scene scene \"1\"*.. \"N\"actor actor \"1\"*.. \"N\"shape shape o--geometry shape o--material There are only position and rotation in GlobalPose and LocalPose, no â€œscaleâ€. Scale only reflects on geometryâ€™s actual size.\nScene Query Basics Three kinds of scene query:\nraycast sweep overlap In general, each SceneQuery traverses a culling structure containing the scene objects, performs a precise test using the GeometryQuery functions, and accumulates the results.\nYou can customize filtering logic via prefilter and postfilter.\nflowchart LR BP(Broad Phase) --\u003e prefilter --\u003e MP(Mid phase) --\u003e NP(Narrow Phase) --\u003e postfilter Broad phase traverses the global scene spatial partitioning structure to find candidates for the mid and narrow phases. Mid phase traverses the internal culling structures of triangle meshes and heightfields to find a smaller subset of triangles reported by the broad phase. Narrow phase performs exact intersection tests. Pre-filtering occurs before the mid and narrow phases, allowing shapes to be efficiently discarded before the potentially expensive exact collision test. Post-filtering occurs after the narrow phase test and can use the results of the test (such as PxRaycastHit.position) to determine whether a hit should be discarded. More on Traversal One scene uses two query structures, one for â€œstaticâ€ objects (PxRigidStatic), one for â€œdynamicâ€ objects (PxRigidBody). Each structure can use different culling algorithms, see PxPruningStructureType.\nPxPruningStructureType Explaination eNone Based on grid. Full rebuild when changed. eDYNAMIC_AABB_TREE Based on tree. Full rebuild when changed. Only choose this if all static actors in your scene are not modified after initialization. eSTATIC_AABB_TREE Based on grid and tree. Incremental rebuild when changed, unless by force. Choose this if frequently add/remove geometry, at the cost of higher memory More on Filtering Objects To make custom filtering logic works, there are 3 steps.\nAttach data for filtering on the shape (a.k.a. QueryFilterData) Define custom filtering logic Attach filter in your scene query Step 1. Attach data to the shape for futher filtering Attach PxFilterData to each shapeâ€™s QueryFilterData. It has four 32bit words to hold custom data, e.g., we use word0 as layer of this shape. Here is an example:\nPxShape* shape = PxRigidActorExt::createExclusiveShape(*pxActor, PxBoxGeometry(extV), *pxMaterial); PxFilterData queryFilter; queryFilter.word0 = layer; shape-\u003esetQueryFilterData(queryFilter); Step 2. Define custom filtering logic Define callback function for prefilter and postfilter. See PxQueryFilterCallback. The logic is totally depend on yourself, just return PxQueryHitType to tell if this shape can pass.\nPxQueryHitType Explanation eNONE Shall not pass. eTOUCH Pass, but does not stop the raycast or sweep. eBLOCK Pass, but stop here. Here is an example:\nclass PhysxQueryFilterCallback : public PxQueryFilterCallback { public: PhysxQueryFilterCallback(); PhysxQueryFilterCallback(bool isBlocking, bool includeTrigger); virtual PxQueryHitType::Enum preFilter(const PxFilterData\u0026 filterData, const PxShape* shape, const PxRigidActor* actor, PxHitFlags\u0026 queryFlags); virtual PxQueryHitType::Enum postFilter(const PxFilterData\u0026 filterData, const PxQueryHit\u0026 hit); private: PxQueryHitType::Enum m_HitType; bool m_IncludeTrigger; }; PxQueryHitType::Enum PhysxQueryFilterCallback::preFilter(const PxFilterData\u0026 filterData, const PxShape* shape, const PxRigidActor* actor, PxHitFlags\u0026 queryFlags) { bool isTrigger = shape-\u003egetFlags() \u0026 physx::PxShapeFlag::eTRIGGER_SHAPE; if (isTrigger \u0026\u0026 !m_IncludeTrigger) { return PxQueryHitType::eNONE; } PxFilterData shapefilterData = shape-\u003egetQueryFilterData(); if (shapefilterData.word0 \u0026 filterData.word0 || shapefilterData.word1 \u0026 filterData.word1) { return m_HitType; } return PxQueryHitType::eNONE; } PxQueryHitType::Enum PhysxQueryFilterCallback::postFilter(const PxFilterData\u0026 filterData, const PxQueryHit\u0026 hit) { const PxLocationHit\u0026 impactHit = static_cast\u003cconst PxLocationHit\u0026\u003e(hit); if (impactHit.distance \u003e 0.0f) return m_HitType; return PxQueryHitType::eNONE; } Step 3. Attach filter to your scene query PxQueryFilterData has two fields:\nfield Explaination PxQueryFlags Supported flags are in PxQueryFlag::Enums, e.g. raise ePREFILTER means all shapes need to pass prefilter you defined. PxFilterData Has four 32bit words for you, e.g. use word0 as the â€œlayermaskâ€ of the query. Raycast example Here is an example of raycast (return multiple objects).\n// save result and use it later struct MyRaycastHitResult { PhysXVec3 Position; PhysXVec3 Normal; float Distance; PhysXActor* Collider; }; typedef PhysXArray\u003cMyRaycastHitResult\u003e MyRaycastHitResults; // make sure \"direction\" is non-zero and normalized! bool PhysXManager::MyRaycast(MyRaycastHitResults\u0026 hitResults, const PhysXVec3\u0026 startPos, const PhysXVec3\u0026 direction, float distance, unsigned int layerMask, bool includeTrigger) { const PxU32 bufferSize = 256; PxRaycastHit hitBuffer[bufferSize]; PxRaycastBuffer buf(hitBuffer, bufferSize); PxQueryFilterData filterData = PxQueryFilterData(); filterData.flags |= PxQueryFlag::ePREFILTER | PxQueryFlag::ePOSTFILTER; // will call both prefilter and post filter filterData.data.word0 = 0; filterData.data.word1 = layerMask; PhysxQueryFilterCallback filterCallback(false, includeTrigger); bool status = m_pxScene-\u003eraycast(startPos, direction, distance, buf, PxHitFlag::eDEFAULT, filterData, \u0026filterCallback, NULL); if (status) { hitResults.clear(); for (PxU32 i = 0; i \u003c buf.nbTouches; i++) { PxRaycastHit touch = buf.touches[i]; MyRaycastHitResult hitResult; hitResult.Position = touch.position; hitResult.Normal = touch.normal; hitResult.Distance = touch.distance; hitResult.Collider = (PhysXActor*)touch.actor-\u003euserData; hitResults.push_back(hitResult); } if (buf.hasBlock) { MyRaycastHitResult hitResult; hitResult.Position = buf.block.position; hitResult.Normal = buf.block.normal; hitResult.Distance = buf.block.distance; hitResult.Collider = (PhysXActor*)buf.block.actor-\u003euserData; hitResults.push_back(hitResult); } } return status; } Overlap example Here is an example of sphere overlap. Other geometries are similar.\n// make sure radius is above zero! bool PhysXManager::MySphereOverlap(PhysXRaycastHits\u0026 hitResults, float radius, const PhysXVec3\u0026 position, const PhysXQuat\u0026 rotation, unsigned int layerMask, bool includeTrigger) { const PxU32 bufferSize = 256; PxOverlapHit hitBuffer[bufferSize]; PxOverlapBuffer buf(hitBuffer, bufferSize); PxQueryFilterData filterData = PxQueryFilterData(); filterData.flags |= PxQueryFlag::ePREFILTER;// no postfilter logic since we SHOULD NOT EXAMINE DISTANCE in overlap query filterData.data.word0 = 0; filterData.data.word1 = layerMask; PhysxQueryFilterCallback filterCallback(false, includeTrigger); bool status = false; PxTransform trans(position, rotation); status = m_pxScene-\u003eoverlap(PxSphereGeometry(radius), trans, buf, filterData, \u0026filterCallback); if (status \u0026\u0026 buf.nbTouches \u003e 0) { hitResults.clear(); for (PxU32 i = 0; i \u003c buf.nbTouches; i++) { PxOverlapHit hit = buf.touches[i]; PhysXRaycastHit hitResult; hitResult.Collider = (PhysXActor*)hit.actor-\u003euserData; hitResults.push_back(hitResult); } } return status; } Golden Tips Make sure shape dimension and queryshape dimension have positive values, recommended minimum value is 1.192092896e-07F. Or random crash may happen.\nIf using the DEBUG version, it may raise an assertion failure if a capsule shape degrades to a sphere shape (height is zero).\nIn Raycast or Sweep, make sure direction is normalized and not zero. Or random crash may happen.\nIn Overlap, do not check hit.distance (itâ€™s always zero) in post-filtering logic.\n","wordCount":"1078","inLanguage":"en","datePublished":"2023-05-26T00:00:00Z","dateModified":"2023-05-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_scenequery/"},"publisher":{"@type":"Organization","name":"æ³¢æ³¢æ²™ğŸ ","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="æ³¢æ³¢æ²™ğŸ  (Alt + H)">æ³¢æ³¢æ²™ğŸ </a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PhysXç‰©ç†å¼•æ“ï¼ˆ1ï¼‰Scene Query</h1><div class=post-meta><span title='2023-05-26 00:00:00 +0000 UTC'>May 26, 2023</span>&nbsp;Â·&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#warm-up aria-label=Warm-up>Warm-up</a></li><li><a href=#scene-query-basics aria-label="Scene Query Basics">Scene Query Basics</a></li><li><a href=#more-on-traversal aria-label="More on Traversal">More on Traversal</a></li><li><a href=#more-on-filtering-objects aria-label="More on Filtering Objects">More on Filtering Objects</a><ul><li><a href=#step-1-attach-data-to-the-shape-for-futher-filtering aria-label="Step 1. Attach data to the shape for futher filtering">Step 1. Attach data to the shape for futher filtering</a></li><li><a href=#step-2-define-custom-filtering-logic aria-label="Step 2. Define custom filtering logic">Step 2. Define custom filtering logic</a></li><li><a href=#step-3-attach-filter-to-your-scene-query aria-label="Step 3. Attach filter to your scene query">Step 3. Attach filter to your scene query</a><ul><li><a href=#raycast-example aria-label="Raycast example">Raycast example</a></li><li><a href=#overlap-example aria-label="Overlap example">Overlap example</a></li></ul></li></ul></li><li><a href=#golden-tips aria-label="Golden Tips">Golden Tips</a></li></ul></div></details></div><div class=post-content><blockquote><p>æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXåœºæ™¯æŸ¥è¯¢çš„ä¸€äº›å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚</p><p><a href=https://pps43.github.io/tags/physx/>PhysXç‰©ç†å¼•æ“ç³»åˆ—</a>è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆ<a href=https://github.com/pps43/PhysX-3.4>Code</a>, <a href=https://github.com/pps43/PhysX-3.4/raw/master/PhysX_3.4/Documentation/PhysXGuide.chm>Doc</a>ï¼‰çš„ä¸€äº›ç»éªŒï¼Œæœ‰ä¸å°‘å¯¹å®˜æ–¹èµ„æ–™çš„è¡¥å……ã€‚</p></blockquote><h1 id=warm-up>Warm-up<a hidden class=anchor aria-hidden=true href=#warm-up>#</a></h1><p>A <code>Scene</code> in PhysX engine is a container of objects in a hierachical manner.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>---
title: Scene Hierachy
---
classDiagram
direction LR

class world
class scene {
    Flags
    Gravity
    ...
}
class actor {
    ActorFlags
    Name
    GlobalPose
    ...
}
class shape {
    Flags
    GeometryType
    LocalPose
    QueryFilterData
    SimulationFilterData
    ...
}
class geometry {
    ...
}
class material {
    friction
    restitution
    damping
}

world &#34;1&#34;*.. &#34;N&#34;scene
scene &#34;1&#34;*.. &#34;N&#34;actor
actor &#34;1&#34;*.. &#34;N&#34;shape
shape o--geometry
shape o--material
</code></pre><p>There are only position and rotation in <code>GlobalPose</code> and <code>LocalPose</code>, no &ldquo;scale&rdquo;. Scale only reflects on geometry&rsquo;s actual size.</p><h1 id=scene-query-basics>Scene Query Basics<a hidden class=anchor aria-hidden=true href=#scene-query-basics>#</a></h1><p>Three kinds of scene query:</p><ul><li>raycast</li><li>sweep</li><li>overlap</li></ul><p>In general, each <code>SceneQuery</code> traverses a culling structure containing the scene objects, performs a precise test using the <code>GeometryQuery</code> functions, and accumulates the results.</p><p>You can customize filtering logic via <code>prefilter</code> and <code>postfilter</code>.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR

BP(Broad Phase) --&gt; prefilter --&gt; MP(Mid phase) --&gt; NP(Narrow Phase) --&gt; postfilter
</code></pre><ul><li><code>Broad phase</code> traverses the global scene spatial partitioning structure to find candidates for the mid and narrow phases.</li><li><code>Mid phase</code> traverses the internal culling structures of triangle meshes and heightfields to find a smaller subset of triangles reported by the broad phase.</li><li><code>Narrow phase</code> performs exact intersection tests.</li><li><code>Pre-filtering</code> occurs before the mid and narrow phases, allowing shapes to be efficiently discarded before the potentially expensive exact collision test.</li><li><code>Post-filtering</code> occurs after the narrow phase test and can use the results of the test (such as <code>PxRaycastHit.position</code>) to determine whether a hit should be discarded.</li></ul><h1 id=more-on-traversal>More on Traversal<a hidden class=anchor aria-hidden=true href=#more-on-traversal>#</a></h1><p>One scene uses two query structures, one for &ldquo;static&rdquo; objects (<code>PxRigidStatic</code>), one for &ldquo;dynamic&rdquo; objects (<code>PxRigidBody</code>). Each structure can use different culling algorithms, see <code>PxPruningStructureType</code>.</p><table><thead><tr><th>PxPruningStructureType</th><th>Explaination</th></tr></thead><tbody><tr><td>eNone</td><td>Based on grid. Full rebuild when changed.</td></tr><tr><td>eDYNAMIC_AABB_TREE</td><td>Based on tree. Full rebuild when changed. Only choose this if all static actors in your scene are not modified after initialization.</td></tr><tr><td>eSTATIC_AABB_TREE</td><td>Based on grid and tree. Incremental rebuild when changed, unless by force. Choose this if frequently add/remove geometry, at the cost of higher memory</td></tr></tbody></table><h1 id=more-on-filtering-objects>More on Filtering Objects<a hidden class=anchor aria-hidden=true href=#more-on-filtering-objects>#</a></h1><p>To make custom filtering logic works, there are 3 steps.</p><ol><li>Attach data for filtering on the shape (a.k.a. <code>QueryFilterData</code>)</li><li>Define custom filtering logic</li><li>Attach filter in your scene query</li></ol><h2 id=step-1-attach-data-to-the-shape-for-futher-filtering>Step 1. Attach data to the shape for futher filtering<a hidden class=anchor aria-hidden=true href=#step-1-attach-data-to-the-shape-for-futher-filtering>#</a></h2><p>Attach <code>PxFilterData</code> to each shape&rsquo;s QueryFilterData. It has four 32bit words to hold custom data, e.g., we use <code>word0</code> as layer of this shape. Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span> <span class=o>=</span> <span class=n>PxRigidActorExt</span><span class=o>::</span><span class=n>createExclusiveShape</span><span class=p>(</span><span class=o>*</span><span class=n>pxActor</span><span class=p>,</span> <span class=n>PxBoxGeometry</span><span class=p>(</span><span class=n>extV</span><span class=p>),</span> <span class=o>*</span><span class=n>pxMaterial</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>PxFilterData</span> <span class=n>queryFilter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>queryFilter</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=n>layer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>shape</span><span class=o>-&gt;</span><span class=n>setQueryFilterData</span><span class=p>(</span><span class=n>queryFilter</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=step-2-define-custom-filtering-logic>Step 2. Define custom filtering logic<a hidden class=anchor aria-hidden=true href=#step-2-define-custom-filtering-logic>#</a></h2><p>Define callback function for <code>prefilter</code> and <code>postfilter</code>. See <code>PxQueryFilterCallback</code>. The logic is totally depend on yourself, just return <code>PxQueryHitType</code> to tell if this shape can pass.</p><table><thead><tr><th>PxQueryHitType</th><th>Explanation</th></tr></thead><tbody><tr><td>eNONE</td><td>Shall not pass.</td></tr><tr><td>eTOUCH</td><td>Pass, but does not stop the raycast or sweep.</td></tr><tr><td>eBLOCK</td><td>Pass, but stop here.</td></tr></tbody></table><p>Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PhysxQueryFilterCallback</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PxQueryFilterCallback</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>PhysxQueryFilterCallback</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>PhysxQueryFilterCallback</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isBlocking</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>includeTrigger</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>preFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actor</span><span class=p>,</span> <span class=n>PxHitFlags</span><span class=o>&amp;</span> <span class=n>queryFlags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>postFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxQueryHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>m_IncludeTrigger</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>PhysxQueryFilterCallback</span><span class=o>::</span><span class=n>preFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actor</span><span class=p>,</span> <span class=n>PxHitFlags</span><span class=o>&amp;</span> <span class=n>queryFlags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>isTrigger</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>physx</span><span class=o>::</span><span class=n>PxShapeFlag</span><span class=o>::</span><span class=n>eTRIGGER_SHAPE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>isTrigger</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>m_IncludeTrigger</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PxFilterData</span> <span class=n>shapefilterData</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>shapefilterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>||</span> <span class=n>shapefilterData</span><span class=p>.</span><span class=n>word1</span> <span class=o>&amp;</span> <span class=n>filterData</span><span class=p>.</span><span class=n>word1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>PhysxQueryFilterCallback</span><span class=o>::</span><span class=n>postFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxQueryHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>PxLocationHit</span><span class=o>&amp;</span> <span class=n>impactHit</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>PxLocationHit</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>impactHit</span><span class=p>.</span><span class=n>distance</span> <span class=o>&gt;</span> <span class=mf>0.0f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=step-3-attach-filter-to-your-scene-query>Step 3. Attach filter to your scene query<a hidden class=anchor aria-hidden=true href=#step-3-attach-filter-to-your-scene-query>#</a></h2><p><code>PxQueryFilterData</code> has two fields:</p><table><thead><tr><th>field</th><th>Explaination</th></tr></thead><tbody><tr><td>PxQueryFlags</td><td>Supported flags are in <code>PxQueryFlag::Enums</code>, e.g. raise <code>ePREFILTER</code> means all shapes need to pass <code>prefilter</code> you defined.</td></tr><tr><td>PxFilterData</td><td>Has four 32bit words for you, e.g. use <code>word0</code> as the &ldquo;layermask&rdquo; of the query.</td></tr></tbody></table><h3 id=raycast-example>Raycast example<a hidden class=anchor aria-hidden=true href=#raycast-example>#</a></h3><p>Here is an example of raycast (return multiple objects).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// save result and use it later
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>MyRaycastHitResult</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysXVec3</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysXVec3</span> <span class=n>Normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>Distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysXActor</span><span class=o>*</span> <span class=n>Collider</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PhysXArray</span><span class=o>&lt;</span><span class=n>MyRaycastHitResult</span><span class=o>&gt;</span> <span class=n>MyRaycastHitResults</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// make sure &#34;direction&#34; is non-zero and normalized!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>PhysXManager</span><span class=o>::</span><span class=n>MyRaycast</span><span class=p>(</span><span class=n>MyRaycastHitResults</span><span class=o>&amp;</span> <span class=n>hitResults</span><span class=p>,</span> <span class=k>const</span> <span class=n>PhysXVec3</span><span class=o>&amp;</span> <span class=n>startPos</span><span class=p>,</span> <span class=k>const</span> <span class=n>PhysXVec3</span><span class=o>&amp;</span> <span class=n>direction</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distance</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>layerMask</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>includeTrigger</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>PxU32</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>256</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRaycastHit</span> <span class=n>hitBuffer</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRaycastBuffer</span> <span class=nf>buf</span><span class=p>(</span><span class=n>hitBuffer</span><span class=p>,</span> <span class=n>bufferSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PxQueryFilterData</span> <span class=n>filterData</span> <span class=o>=</span> <span class=n>PxQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>filterData</span><span class=p>.</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>PxQueryFlag</span><span class=o>::</span><span class=n>ePREFILTER</span> <span class=o>|</span> <span class=n>PxQueryFlag</span><span class=o>::</span><span class=n>ePOSTFILTER</span><span class=p>;</span> <span class=c1>// will call both prefilter and post filter
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>filterData</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>filterData</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>word1</span> <span class=o>=</span> <span class=n>layerMask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysxQueryFilterCallback</span> <span class=nf>filterCallback</span><span class=p>(</span><span class=nb>false</span><span class=p>,</span> <span class=n>includeTrigger</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>status</span> <span class=o>=</span> <span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>raycast</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>direction</span><span class=p>,</span> <span class=n>distance</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>PxHitFlag</span><span class=o>::</span><span class=n>eDEFAULT</span><span class=p>,</span> <span class=n>filterData</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>filterCallback</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>hitResults</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>PxU32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>buf</span><span class=p>.</span><span class=n>nbTouches</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>PxRaycastHit</span> <span class=n>touch</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>touches</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>MyRaycastHitResult</span> <span class=n>hitResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Position</span> <span class=o>=</span> <span class=n>touch</span><span class=p>.</span><span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Normal</span> <span class=o>=</span> <span class=n>touch</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Distance</span> <span class=o>=</span> <span class=n>touch</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Collider</span> <span class=o>=</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span><span class=n>touch</span><span class=p>.</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResults</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>hitResult</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=n>hasBlock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>MyRaycastHitResult</span> <span class=n>hitResult</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Position</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Normal</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Distance</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Collider</span> <span class=o>=</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span><span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResults</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>hitResult</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=overlap-example>Overlap example<a hidden class=anchor aria-hidden=true href=#overlap-example>#</a></h3><p>Here is an example of sphere overlap. Other geometries are similar.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// make sure radius is above zero!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>PhysXManager</span><span class=o>::</span><span class=n>MySphereOverlap</span><span class=p>(</span><span class=n>PhysXRaycastHits</span><span class=o>&amp;</span> <span class=n>hitResults</span><span class=p>,</span> <span class=kt>float</span> <span class=n>radius</span><span class=p>,</span> <span class=k>const</span> <span class=n>PhysXVec3</span><span class=o>&amp;</span> <span class=n>position</span><span class=p>,</span> <span class=k>const</span> <span class=n>PhysXQuat</span><span class=o>&amp;</span> <span class=n>rotation</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>layerMask</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>includeTrigger</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>PxU32</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>256</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PxOverlapHit</span> <span class=n>hitBuffer</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>PxOverlapBuffer</span> <span class=nf>buf</span><span class=p>(</span><span class=n>hitBuffer</span><span class=p>,</span> <span class=n>bufferSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PxQueryFilterData</span> <span class=n>filterData</span> <span class=o>=</span> <span class=n>PxQueryFilterData</span><span class=p>();</span> 
</span></span><span class=line><span class=cl>    <span class=n>filterData</span><span class=p>.</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>PxQueryFlag</span><span class=o>::</span><span class=n>ePREFILTER</span><span class=p>;</span><span class=c1>// no postfilter logic since we SHOULD NOT EXAMINE DISTANCE in overlap query
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>filterData</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>filterData</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>word1</span> <span class=o>=</span> <span class=n>layerMask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysxQueryFilterCallback</span> <span class=nf>filterCallback</span><span class=p>(</span><span class=nb>false</span><span class=p>,</span> <span class=n>includeTrigger</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>status</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PxTransform</span> <span class=nf>trans</span><span class=p>(</span><span class=n>position</span><span class=p>,</span> <span class=n>rotation</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>status</span> <span class=o>=</span> <span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>overlap</span><span class=p>(</span><span class=n>PxSphereGeometry</span><span class=p>(</span><span class=n>radius</span><span class=p>),</span> <span class=n>trans</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>filterData</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>filterCallback</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>status</span> <span class=o>&amp;&amp;</span> <span class=n>buf</span><span class=p>.</span><span class=n>nbTouches</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>hitResults</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>PxU32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>buf</span><span class=p>.</span><span class=n>nbTouches</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>PxOverlapHit</span> <span class=n>hit</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>touches</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>PhysXRaycastHit</span> <span class=n>hitResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResult</span><span class=p>.</span><span class=n>Collider</span> <span class=o>=</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span><span class=n>hit</span><span class=p>.</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>hitResults</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>hitResult</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=golden-tips>Golden Tips<a hidden class=anchor aria-hidden=true href=#golden-tips>#</a></h1><ul><li><p>Make sure shape dimension and queryshape dimension have positive values, recommended minimum value is <code>1.192092896e-07F</code>. Or random crash may happen.</p><blockquote><p>If using the DEBUG version, it may raise an assertion failure if a capsule shape degrades to a sphere shape (height is zero).</p><p><img loading=lazy src=/using_physx_scenequery/capsuleshape_assert_fail.png alt></p></blockquote></li><li><p>In <code>Raycast</code> or <code>Sweep</code>, make sure <code>direction</code> is normalized and not zero. Or random crash may happen.</p></li><li><p>In <code>Overlap</code>, do not check <code>hit.distance</code> (it&rsquo;s always zero) in post-filtering logic.</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/notes_on_why_buddhism_is_true/><span class=title>Â« Prev</span><br><span>æ´è§Â·ä¸ºä»€ä¹ˆä½›å­¦æ˜¯çœŸçš„</span></a>
<a class=next href=https://pps43.github.io/posts/asking_ai_about_ai_2/><span class=title>Next Â»</span><br><span>è·ŸAIè€å¸ˆå­¦AIï¼ˆ2ï¼‰</span></a></nav></footer></article></main><footer class=footer><span>Â© 2016-2023 By æ³¢æ³¢æ²™.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>