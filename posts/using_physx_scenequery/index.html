<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysX Engine Series: Scene Query | 波波沙🏠</title><meta name=keywords content="Game Dev,Game Engine,PhysX"><meta name=description content="PhysX Engine Series 这个系列主要记录一些最近在游戏中使用Nvdia PhysX 3.4物理引擎的一些经验。 本文主要介绍场景查询的一些内部机制和使用方法。 Prerequisites 官方资料： PhysX"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_scenequery/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="PhysX Engine Series: Scene Query"><meta property="og:description" content="PhysX Engine Series 这个系列主要记录一些最近在游戏中使用Nvdia PhysX 3.4物理引擎的一些经验。 本文主要介绍场景查询的一些内部机制和使用方法。 Prerequisites 官方资料： PhysX"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/using_physx_scenequery/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-05-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysX Engine Series: Scene Query"><meta name=twitter:description content="PhysX Engine Series 这个系列主要记录一些最近在游戏中使用Nvdia PhysX 3.4物理引擎的一些经验。 本文主要介绍场景查询的一些内部机制和使用方法。 Prerequisites 官方资料： PhysX"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"PhysX Engine Series: Scene Query","item":"https://pps43.github.io/posts/using_physx_scenequery/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysX Engine Series: Scene Query","name":"PhysX Engine Series: Scene Query","description":"PhysX Engine Series 这个系列主要记录一些最近在游戏中使用Nvdia PhysX 3.4物理引擎的一些经验。 本文主要介绍场景查询的一些内部机制和使用方法。 Prerequisites 官方资料： PhysX","keywords":["Game Dev","Game Engine","PhysX"],"articleBody":" PhysX Engine Series 这个系列主要记录一些最近在游戏中使用Nvdia PhysX 3.4物理引擎的一些经验。 本文主要介绍场景查询的一些内部机制和使用方法。\nPrerequisites 官方资料：\nPhysX 3.4 source code Download PhysXGuide.chm A Scene in PhysX engine is a container of objects in a hierachical manner.\n--- title: Scene Hierachy --- classDiagram direction LR class world class scene { Flags Gravity ... } class actor { ActorFlags Name GlobalPose ... } class shape { Flags GeometryType LocalPose ... } class geometry { halfExtents for box ... } class material { friction restitution damping } world \"1\"*.. \"N\"scene scene \"1\"*.. \"N\"actor actor \"1\"*.. \"N\"shape shape o--geometry shape o--material There are only position and rotation in GlobalPose and LocalPose, no “scale”. Scale only reflects on geometry’s actual size.\nPhysX Scene Query Three kinds of scene query:\nraycast sweep overlap In general, each SceneQuery traverses a culling structure containing the scene objects, performs a precise test using the GeometryQuery functions, and accumulates the results.\nYou can customize filtering logic via prefilter and postfilter.\nflowchart LR BP(Broad Phase) --\u003e prefilter --\u003e MP(Mid phase) --\u003e NP(Narrow Phase) --\u003e postfilter Broad phase traverses the global scene spatial partitioning structure to find the candidates for mid and narrow phases. midphase traverses the triangle mesh and heightfield internal culling structures, to find a smaller subset of the triangles in a mesh reported by the broad phase. Narrow phase performs exact intersection tests Pre-filtering happens before midphase and narrow phase and allows shapes to be efficiently discarded before the potentially expensive exact collision test. Post-filtering happens after the narrow phase test and can therefore use the results of the test (such as PxRaycastHit.position) to determine whether a hit should be discarded or not. More on traversal A scene uses two query structures, one for “static” objects (PxRigidStatic), one for “dynamic” objects (PxRigidBody). Each structure can use different culling algorithms, see PxPruningStructureType.\nPxPruningStructureType Explaination eNone Based on grid. Full rebuild when changed. eDYNAMIC_AABB_TREE Based on tree. Full rebuild when changed. Only choose this if all static actors in your scene are not modified after initialization. eSTATIC_AABB_TREE Based on grid and tree. Incremental rebuild when changed, unless by force. Choose this if frequently add/remove geometry, at the cost of higher memory More on prefilter and postfilter To make prefilter works, there are 3 steps.\nfirst attach data (PxFilterData) for on shape. It has four 32bit words to hold custom data, e.g., use word0 as layer of this shape. Here is an example:\nPxShape* shape = PxRigidActorExt::createExclusiveShape(*pxActor, PxBoxGeometry(extV), *pxMaterial); PxFilterData queryFilter; queryFilter.word0 = layer; shape-\u003esetQueryFilterData(queryFilter); second define callback function for prefilter. See PxQueryFilterCallback. The logic is totally depend on yourself, just return PxQueryHitType to tell if this shape can pass. PxQueryHitType Explanation eNONE Shall not pass. eTOUCH Pass, but does not stop the raycast or sweep. eBLOCK Pass, but stop here. Here is an realworld example:\nclass PhysxQueryFilterCallback : public PxQueryFilterCallback { public: PhysxQueryFilterCallback(); PhysxQueryFilterCallback(bool isBlocking, bool includeTrigger); virtual PxQueryHitType::Enum preFilter(const PxFilterData\u0026 filterData, const PxShape* shape, const PxRigidActor* actor, PxHitFlags\u0026 queryFlags); virtual PxQueryHitType::Enum postFilter(const PxFilterData\u0026 filterData, const PxQueryHit\u0026 hit); private: PxQueryHitType::Enum m_HitType; bool m_IncludeTrigger; }; PxQueryHitType::Enum PhysxQueryFilterCallback::preFilter(const PxFilterData\u0026 filterData, const PxShape* shape, const PxRigidActor* actor, PxHitFlags\u0026 queryFlags) { bool isTrigger = shape-\u003egetFlags() \u0026 physx::PxShapeFlag::eTRIGGER_SHAPE; if (isTrigger \u0026\u0026 !m_IncludeTrigger) { return PxQueryHitType::eNONE; } PxFilterData shapefilterData = shape-\u003egetQueryFilterData(); if (shapefilterData.word0 \u0026 filterData.word0 || shapefilterData.word1 \u0026 filterData.word1) { return m_HitType; } return PxQueryHitType::eNONE; } PxQueryHitType::Enum PhysxQueryFilterCallback::postFilter(const PxFilterData\u0026 filterData, const PxQueryHit\u0026 hit) { const PxLocationHit\u0026 impactHit = static_cast\u003cconst PxLocationHit\u0026\u003e(hit); if (impactHit.distance \u003e 0.0f) return m_HitType; return PxQueryHitType::eNONE; } third step is to add PxQueryFilterData when query PxQueryFilterData has two fields:\nfield Explaination PxQueryFlags Supported flags are in PxQueryFlag::Enums, e.g. raise ePREFILTER means all shapes need to pass prefilter you defined. PxFilterData Has four 32bit words for you, e.g. use word0 as the “layermask” of the query. Here is an realworld example of raycast (return multiple objects):\nstruct MyRaycastHitResult { PhysXVec3 Position; PhysXVec3 Normal; float Distance; PhysXActor* Collider; }; typedef PhysXArray\u003cMyRaycastHitResult\u003e MyRaycastHitResults; bool MyRaycast(MyRaycastHitResults\u0026 hitResults, const PhysXVec3\u0026 startPos, const PhysXVec3\u0026 direction, float distance, unsigned int layerMask, bool includeTrigger) { const PxU32 bufferSize = 256; PxRaycastHit hitBuffer[bufferSize]; PxRaycastBuffer buf(hitBuffer, bufferSize); PxQueryFilterData filterData = PxQueryFilterData(); filterData.flags |= PxQueryFlag::ePREFILTER | PxQueryFlag::ePOSTFILTER; filterData.data.word0 = 0; filterData.data.word1 = layerMask; PhysxQueryFilterCallback filterCallback(false, includeTrigger); bool status = m_pxScene-\u003eraycast(startPos, direction, distance, buf, PxHitFlag::eDEFAULT, filterData, \u0026filterCallback, NULL); if (status) { hitResults.clear(); for (PxU32 i = 0; i \u003c buf.nbTouches; i++) { PxRaycastHit touch = buf.touches[i]; MyRaycastHitResult hitResult; hitResult.Position = touch.position; hitResult.Normal = touch.normal; hitResult.Distance = touch.distance; hitResult.Collider = (PhysXActor*)touch.actor-\u003euserData; hitResults.push_back(hitResult); } if (buf.hasBlock) { MyRaycastHitResult hitResult; hitResult.Position = buf.block.position; hitResult.Normal = buf.block.normal; hitResult.Distance = buf.block.distance; hitResult.Collider = (PhysXActor*)buf.block.actor-\u003euserData; hitResults.push_back(hitResult); } } return status; } ","wordCount":"811","inLanguage":"en","datePublished":"2023-05-26T00:00:00Z","dateModified":"2023-05-26T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_scenequery/"},"publisher":{"@type":"Organization","name":"波波沙🏠","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="波波沙🏠 (Alt + H)">波波沙🏠</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PhysX Engine Series: Scene Query</h1><div class=post-meta><span title='2023-05-26 00:00:00 +0000 UTC'>May 26, 2023</span>&nbsp;·&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#prerequisites aria-label=Prerequisites>Prerequisites</a></li><li><a href=#physx-scene-query aria-label="PhysX Scene Query">PhysX Scene Query</a></li><li><a href=#more-on-traversal aria-label="More on traversal">More on <code>traversal</code></a></li><li><a href=#more-on-prefilter-and-postfilter aria-label="More on prefilter and postfilter">More on <code>prefilter</code> and <code>postfilter</code></a></li></ul></div></details></div><div class=post-content><blockquote><p><code>PhysX Engine Series</code> 这个系列主要记录一些最近在游戏中使用Nvdia PhysX 3.4物理引擎的一些经验。
本文主要介绍场景查询的一些内部机制和使用方法。</p></blockquote><h1 id=prerequisites>Prerequisites<a hidden class=anchor aria-hidden=true href=#prerequisites>#</a></h1><p>官方资料：</p><blockquote><ul><li>PhysX 3.4 <a href=https://github.com/pps43/PhysX-3.4>source code</a></li><li>Download <a href=https://github.com/pps43/PhysX-3.4/raw/master/PhysX_3.4/Documentation/PhysXGuide.chm>PhysXGuide.chm</a></li></ul></blockquote><p>A <code>Scene</code> in PhysX engine is a container of objects in a hierachical manner.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>---
title: Scene Hierachy
---
classDiagram
direction LR

class world
class scene {
    Flags
    Gravity
    ...
}
class actor {
    ActorFlags
    Name
    GlobalPose
    ...
}
class shape {
    Flags
    GeometryType
    LocalPose
    ...
}
class geometry {
    halfExtents for box
    ...
}
class material {
    friction
    restitution
    damping
}

world &#34;1&#34;*.. &#34;N&#34;scene
scene &#34;1&#34;*.. &#34;N&#34;actor
actor &#34;1&#34;*.. &#34;N&#34;shape
shape o--geometry
shape o--material
</code></pre><p>There are only position and rotation in <code>GlobalPose</code> and <code>LocalPose</code>, no &ldquo;scale&rdquo;. Scale only reflects on geometry&rsquo;s actual size.</p><h1 id=physx-scene-query>PhysX Scene Query<a hidden class=anchor aria-hidden=true href=#physx-scene-query>#</a></h1><p>Three kinds of scene query:</p><ul><li>raycast</li><li>sweep</li><li>overlap</li></ul><p>In general, each <code>SceneQuery</code> traverses a culling structure containing the scene objects, performs a precise test using the <code>GeometryQuery</code> functions, and accumulates the results.</p><p>You can customize filtering logic via <code>prefilter</code> and <code>postfilter</code>.</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart LR

BP(Broad Phase) --&gt; prefilter --&gt; MP(Mid phase) --&gt; NP(Narrow Phase) --&gt; postfilter
</code></pre><ul><li>Broad phase traverses the global scene spatial partitioning structure to find the candidates for mid and narrow phases.</li><li>midphase traverses the triangle mesh and heightfield internal culling structures, to find a smaller subset of the triangles in a mesh reported by the broad phase.</li><li>Narrow phase performs exact intersection tests</li><li>Pre-filtering happens before midphase and narrow phase and allows shapes to be efficiently discarded before the potentially expensive exact collision test.</li><li>Post-filtering happens after the narrow phase test and can therefore use the results of the test (such as PxRaycastHit.position) to determine whether a hit should be discarded or not.</li></ul><h1 id=more-on-traversal>More on <code>traversal</code><a hidden class=anchor aria-hidden=true href=#more-on-traversal>#</a></h1><p>A scene uses two query structures, one for &ldquo;static&rdquo; objects (<code>PxRigidStatic</code>), one for &ldquo;dynamic&rdquo; objects (<code>PxRigidBody</code>). Each structure can use different culling algorithms, see <code>PxPruningStructureType</code>.</p><table><thead><tr><th>PxPruningStructureType</th><th>Explaination</th></tr></thead><tbody><tr><td>eNone</td><td>Based on grid. Full rebuild when changed.</td></tr><tr><td>eDYNAMIC_AABB_TREE</td><td>Based on tree. Full rebuild when changed. Only choose this if all static actors in your scene are not modified after initialization.</td></tr><tr><td>eSTATIC_AABB_TREE</td><td>Based on grid and tree. Incremental rebuild when changed, unless by force. Choose this if frequently add/remove geometry, at the cost of higher memory</td></tr></tbody></table><h1 id=more-on-prefilter-and-postfilter>More on <code>prefilter</code> and <code>postfilter</code><a hidden class=anchor aria-hidden=true href=#more-on-prefilter-and-postfilter>#</a></h1><p>To make <code>prefilter</code> works, there are 3 steps.</p><ul><li>first attach data (<code>PxFilterData</code>) for on shape. It has four 32bit words to hold custom data, e.g., use <code>word0</code> as layer of this shape.</li></ul><p>Here is an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span> <span class=o>=</span> <span class=n>PxRigidActorExt</span><span class=o>::</span><span class=n>createExclusiveShape</span><span class=p>(</span><span class=o>*</span><span class=n>pxActor</span><span class=p>,</span> <span class=n>PxBoxGeometry</span><span class=p>(</span><span class=n>extV</span><span class=p>),</span> <span class=o>*</span><span class=n>pxMaterial</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>PxFilterData</span> <span class=n>queryFilter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>queryFilter</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=n>layer</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>shape</span><span class=o>-&gt;</span><span class=n>setQueryFilterData</span><span class=p>(</span><span class=n>queryFilter</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>second define callback function for <code>prefilter</code>. See <code>PxQueryFilterCallback</code>. The logic is totally depend on yourself, just return <code>PxQueryHitType</code> to tell if this shape can pass.</li></ul><table><thead><tr><th>PxQueryHitType</th><th>Explanation</th></tr></thead><tbody><tr><td>eNONE</td><td>Shall not pass.</td></tr><tr><td>eTOUCH</td><td>Pass, but does not stop the raycast or sweep.</td></tr><tr><td>eBLOCK</td><td>Pass, but stop here.</td></tr></tbody></table><p>Here is an realworld example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>PhysxQueryFilterCallback</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PxQueryFilterCallback</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysxQueryFilterCallback</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysxQueryFilterCallback</span><span class=p>(</span><span class=kt>bool</span> <span class=n>isBlocking</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>includeTrigger</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>preFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actor</span><span class=p>,</span> <span class=n>PxHitFlags</span><span class=o>&amp;</span> <span class=n>queryFlags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>postFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxQueryHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>m_IncludeTrigger</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>PhysxQueryFilterCallback</span><span class=o>::</span><span class=n>preFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actor</span><span class=p>,</span> <span class=n>PxHitFlags</span><span class=o>&amp;</span> <span class=n>queryFlags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>isTrigger</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>physx</span><span class=o>::</span><span class=n>PxShapeFlag</span><span class=o>::</span><span class=n>eTRIGGER_SHAPE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>isTrigger</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>m_IncludeTrigger</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PxFilterData</span> <span class=n>shapefilterData</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>shapefilterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>||</span> <span class=n>shapefilterData</span><span class=p>.</span><span class=n>word1</span> <span class=o>&amp;</span> <span class=n>filterData</span><span class=p>.</span><span class=n>word1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>PhysxQueryFilterCallback</span><span class=o>::</span><span class=n>postFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxQueryHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>PxLocationHit</span><span class=o>&amp;</span> <span class=n>impactHit</span> <span class=o>=</span> <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>PxLocationHit</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=n>hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>impactHit</span><span class=p>.</span><span class=n>distance</span> <span class=o>&gt;</span> <span class=mf>0.0f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>third step is to add <code>PxQueryFilterData</code> when query</li></ul><p><code>PxQueryFilterData</code> has two fields:</p><table><thead><tr><th>field</th><th>Explaination</th></tr></thead><tbody><tr><td>PxQueryFlags</td><td>Supported flags are in <code>PxQueryFlag::Enums</code>, e.g. raise <code>ePREFILTER</code> means all shapes need to pass <code>prefilter</code> you defined.</td></tr><tr><td>PxFilterData</td><td>Has four 32bit words for you, e.g. use <code>word0</code> as the &ldquo;layermask&rdquo; of the query.</td></tr></tbody></table><p>Here is an realworld example of raycast (return multiple objects):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyRaycastHitResult</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXVec3</span> <span class=n>Position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXVec3</span> <span class=n>Normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>float</span> <span class=n>Distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXActor</span><span class=o>*</span> <span class=n>Collider</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>PhysXArray</span><span class=o>&lt;</span><span class=n>MyRaycastHitResult</span><span class=o>&gt;</span> <span class=n>MyRaycastHitResults</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>MyRaycast</span><span class=p>(</span><span class=n>MyRaycastHitResults</span><span class=o>&amp;</span> <span class=n>hitResults</span><span class=p>,</span> <span class=k>const</span> <span class=n>PhysXVec3</span><span class=o>&amp;</span> <span class=n>startPos</span><span class=p>,</span> <span class=k>const</span> <span class=n>PhysXVec3</span><span class=o>&amp;</span> <span class=n>direction</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distance</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>layerMask</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>includeTrigger</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=n>PxU32</span> <span class=n>bufferSize</span> <span class=o>=</span> <span class=mi>256</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRaycastHit</span> <span class=n>hitBuffer</span><span class=p>[</span><span class=n>bufferSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRaycastBuffer</span> <span class=n>buf</span><span class=p>(</span><span class=n>hitBuffer</span><span class=p>,</span> <span class=n>bufferSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PxQueryFilterData</span> <span class=n>filterData</span> <span class=o>=</span> <span class=n>PxQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>filterData</span><span class=p>.</span><span class=n>flags</span> <span class=o>|=</span> <span class=n>PxQueryFlag</span><span class=o>::</span><span class=n>ePREFILTER</span> <span class=o>|</span> <span class=n>PxQueryFlag</span><span class=o>::</span><span class=n>ePOSTFILTER</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>filterData</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>filterData</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>word1</span> <span class=o>=</span> <span class=n>layerMask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysxQueryFilterCallback</span> <span class=n>filterCallback</span><span class=p>(</span><span class=nb>false</span><span class=p>,</span> <span class=n>includeTrigger</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>status</span> <span class=o>=</span> <span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>raycast</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>direction</span><span class=p>,</span> <span class=n>distance</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>PxHitFlag</span><span class=o>::</span><span class=n>eDEFAULT</span><span class=p>,</span> <span class=n>filterData</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>filterCallback</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>status</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>hitResults</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=n>PxU32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>buf</span><span class=p>.</span><span class=n>nbTouches</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>PxRaycastHit</span> <span class=n>touch</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>touches</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>			<span class=n>MyRaycastHitResult</span> <span class=n>hitResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Position</span> <span class=o>=</span> <span class=n>touch</span><span class=p>.</span><span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Normal</span> <span class=o>=</span> <span class=n>touch</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Distance</span> <span class=o>=</span> <span class=n>touch</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Collider</span> <span class=o>=</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span><span class=n>touch</span><span class=p>.</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResults</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>hitResult</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>buf</span><span class=p>.</span><span class=n>hasBlock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>MyRaycastHitResult</span> <span class=n>hitResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Position</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Normal</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Distance</span> <span class=o>=</span> <span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResult</span><span class=p>.</span><span class=n>Collider</span> <span class=o>=</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span><span class=n>buf</span><span class=p>.</span><span class=n>block</span><span class=p>.</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>hitResults</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>hitResult</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/game-engine/>Game Engine</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=next href=https://pps43.github.io/posts/asking_ai_about_ai_2/><span class=title>Next »</span><br><span>跟AI老师学AI（二）</span></a></nav></footer></article></main><footer class=footer><span>© 2016-2023 By 波波沙.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>