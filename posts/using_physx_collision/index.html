<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision | Ê≥¢Ê≥¢Ê≤ôüè†</title><meta name=keywords content="Game Dev,PhysX"><meta name=description content="Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÁ¢∞ÊíûÊ£ÄÊµãÁöÑ‰∏Ä‰∫õÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, D"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_collision/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision"><meta property="og:description" content="Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÁ¢∞ÊíûÊ£ÄÊµãÁöÑ‰∏Ä‰∫õÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, D"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/using_physx_collision/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-11T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision"><meta name=twitter:description content="Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÁ¢∞ÊíûÊ£ÄÊµãÁöÑ‰∏Ä‰∫õÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, D"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision","item":"https://pps43.github.io/posts/using_physx_collision/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision","name":"PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision","description":"Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÁ¢∞ÊíûÊ£ÄÊµãÁöÑ‰∏Ä‰∫õÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, D","keywords":["Game Dev","PhysX"],"articleBody":" Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÁ¢∞ÊíûÊ£ÄÊµãÁöÑ‰∏Ä‰∫õÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ\nPhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ\nWarm-up Static, Kinematic \u0026 Dynamic Static colliders are non-movable. In fact, they are not rigidbody, just PxRigidStatic. Kinematic and dynamic rigidbody are both PxRigidDynamic, and can switch to each other at runtime by setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true/false). The biggest difference is that kinematic rigidbody behaves like infinite mass, and will not move by external force. Instead, you call MovePosition on it. Dynamic rigidbody is the only type we can AddForce to, which has mass, center of mass, and inertia tensor to simulate a natural movement with Newton‚Äôs laws of motion. classDiagram PxRigidActor \u003c-- PxRigidStatic PxRigidActor \u003c-- PxRigidBody PxRigidBody \u003c-- PxRigidDynamic PxRigidActor *.. PxShape class PxRigidBody { PxRigidBodyFlag } class PxShape { PxShapeFlag } We cannot make a rigidbody without a shape. Shapes are tangible, with a real size.\nOne actor can have multiple shapes as children, each with a local position and rotation.\nEach shape have a flag PxShapeFlag::eSIMULATION_SHAPE to determine it‚Äôs a collider or a trigger.\nWhen two shapes overlap (collide), a ‚Äútriggering event‚Äù or a ‚Äúcontacting event‚Äù may raise.\nWhen two shapes are both collider, the event is contacting, otherwise triggering. Contacting event happens only when at least one of the shape‚Äôs belonging actor is Non-Kinematic PxRigidDynamic. Triggering event happens only when at least one of the shape‚Äôs belonging actor is PxRigidbody. Two shapes must pass a filtering logic, which is usually user-defined rules. This is called ‚Äúcollision filtering‚Äù. Unity Engine also has a doc to explain these rules, see here.\nFilter mechanism Basically, collision filter decides whether a collision pair should get processed, temporarily ignored or discarded.\nHistorically, there are 3 different implementation in PhysX.\nThe simpliest way is to use filter callback function to determine if two object can interact. Flexible, but too expensive/slow. Next is Simple group based filtering rules in PhysX 2.0 (Dividing actors into predefined groups and decide if two groups can collide). Not flexible enough. Now is Shader system+CPU callback in Physx 3+. Users can tradeoff between speed and flexiblity. Shader System, basically, is a custom function injected to the PxSceneDesc, and called for all pairs of shapes that come near each other ‚Äì more precisely: for all pairs of shapes whose AABB in world space are found to intersect for the first time.\nShader System runs on the vector processor and is therefore not able to access any eventual game data base in main memory, so any pointer dereference is FORBIDDEN.\nSimulation loop To put it simple, here is what happens each frame:\nvoid FixedUpdate(float timestep) { if (m_MySimCallback) { m_MySimCallback-\u003eClear(); // see later in Collision Callback section } if (m_pxScene) { m_pxScene-\u003esimulate(timeStep, NULL, m_ScratchBlock, SCRATCH_BLOCK_SIZE); // your shader function are called inside simulate, when AABB intersect each other. m_pxScene-\u003efetchResults(true); // your CPU callbacks are called inside fetchResults. } } See details on Official Manual: Simulation and Broadphase algorithm\nSetup Rigidbody To create a static actor:\npxActor = sPxPhysics-\u003ecreateRigidStatic(actorTransform); pxActor-\u003esetName(\"xxx\"); pxActor-\u003euserData = \u0026myActorWrapper; // bind to your game actor m_pxScene-\u003eaddActor(*pxActor); To create a dynamic/kinematic actor:\npxActor = sPxPhysics-\u003ecreateRigidDynamic(actorTransform); pxActor-\u003esetName(\"xxx\"); pxActor-\u003euserData = \u0026myActorWrapper;// bind to your game actor m_pxScene-\u003eaddActor(*pxActor); ((PxRigidDynamic*)pxActor)-\u003esetRigidBodyFlag(PxRigidBodyFlag::eENABLE_CCD, true); // set more property, e.g., linear damping, actor flag... if (isKinematic) { ((PxRigidDynamic*)pxActor)-\u003esetRigidBodyFlag(PxRigidBodyFlag::eENABLE_CCD, false); ((PxRigidDynamic*)pxActor)-\u003esetRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true); } To set collision data on each shape for filtering later:\nPxFilterData collisionFilter; collisionFilter.word0 = layer; // ePlayer collisionFilter.word1 = layerAgainst; // eGroud | eWall | eObstacle shape-\u003esetSimulationFilterData(collisionFilter); if (isTrigger) { shape-\u003esetFlag(PxShapeFlag::eSIMULATION_SHAPE, false); shape-\u003esetFlag(PxShapeFlag::eTRIGGER_SHAPE, true); } To register collision filtering and collision callback to all rigidbodies (when creating a PxScene):\nm_MySimCallback = new MySimulationEventCallback(); PxSceneDesc sceneDesc(sPxPhysics-\u003egetTolerancesScale()); ... sceneDesc.filterShader = MyFilterShader; sceneDesc.simulationEventCallback = m_MySimCallback; m_pxScene = sPxPhysics-\u003ecreateScene(sceneDesc); Collision Filtering Just define a function that meets type PxSimulationFilterShader (function pointer).\nPxFilterFlags MyFilterShader( PxFilterObjectAttributes attributes0, PxFilterData filterData0, PxFilterObjectAttributes attributes1, PxFilterData filterData1, PxPairFlags\u0026 pairFlags, const void* constantBlock, PxU32 constantBlockSize) { // for triggers if (PxFilterObjectIsTrigger(attributes0) || PxFilterObjectIsTrigger(attributes1)) { pairFlags = PxPairFlag::eTRIGGER_DEFAULT; // here I do not examine PxFilterData and just let it pass return PxFilterFlag::eDEFAULT; } else // for collisions { // Use word0 as self layer, word1 as layerAgainst. // word2 and word3 are not used here. // In most cases, collision rules are symmetric. // Here we use `||` just in case rules are asymmetric, which is equal to \"Collision only happens if A can collide with B and B can collide with A.\" if ((0 == (filterData0.word0 \u0026 filterData1.word1)) || (0 == (filterData1.word0 \u0026 filterData0.word1))) { return PxFilterFlag::eSUPPRESS; // no collide } // use contact solver, and use CCD detection pairFlags = PxPairFlag::eCONTACT_DEFAULT | PxPairFlag::eDETECT_CCD_CONTACT; // notify onContact event pairFlags |= PxPairFlag::eNOTIFY_TOUCH_FOUND | PxPairFlag::eNOTIFY_TOUCH_CCD | PxPairFlag::eNOTIFY_TOUCH_LOST; return PxFilterFlag::eDEFAULT; } } PxFilterObjectAttributes param is 32bit flag.\nvalue meaning 0 eRIGID_STATIC 1 eRIGID_DYNAMIC ‚Ä¶ ‚Ä¶ 15 as low mask 1¬´4 eKINEMATIC 1¬´5 eTRIGGER PxFilterFlags is return value tells PhysX what to do next.\nenum value meaning eDEFAULT 0 Processed with NO filter callback eKILL 1¬´0 Ignore the collision pair as long as the bounding volumes of the pair objects overlap. Until one of these conditions are met:The bounding volumes of the two objects overlap again (after being separated) The user enforces a re-filtering eSUPPRESS 1¬´1 Similar to eKill, except one more condition that filter data or attribute changes.‚úÖUsually use this. eCALLBACK 1¬´2 Use PxSimulationFilterCallback::pairFound(). ‚ö†SLOW! eNOTIFY 1¬´3 | eCALLBACK Besides eCALLBACK, plus pairLost(). ‚ö†SLOW! PxPairFlags is modifiable, to provide more info on what to do next.\nenum value meaning eSOLVE_CONTACT 1¬´0 need process contact for this pair eMODIFY_CONTACTS 1¬´1 eNOTIFY_TOUCH_FOUND 1¬´2 Raise event when ‚Äúenter‚Äù eNOTIFY_TOUCH_PERSISTS 1¬´3 Raise event when ‚Äústay‚Äù eNOTIFY_TOUCH_LOST 1¬´4 Raise event when ‚Äúexit‚Äù ‚Ä¶ ‚Ä¶ eNOTIFY_CONTACT_POINTS 1¬´9 Add contact points info eDETECT_DISCRETE_CONTACT 1¬´10 Discrete detection algorithm. Valid when eSOLVE_CONTACT eDETECT_CCD_CONTACT 1¬´11 Continous detection algoritym. Valid when eSOLVE_CONTACT, PxSceneFlag::eENABLE_CCD, and PxRigidBodyFlag::eENABLE_CCD are all set. ‚Ä¶ ‚Ä¶ eCONTACT_DEFAULT ‚Ä¶ eSOLVE_CONTACT | eDETECT_DISCRETE_CONTACT eTRIGGER_DEFAULT ‚Ä¶ eNOTIFY_TOUCH_FOUND | eNOTIFY_TOUCH_LOST | eDETECT_DISCRETE_CONTACT Collision Callback This is also how Unity OnTriggerEnter/Exit and OnCollisionEnter/Stay/Exit are based on.\nCreat a new class inheriting PxSimulationEventCallback and override its functions. In below example, we only implement onTrigger and onContact.\nclass MySimulationEventCallback : public PxSimulationEventCallback { public: //from PxSimulationEventCallback //ignore virtual void onConstraintBreak(PxConstraintInfo* constraints, PxU32 count) {}; virtual void onAdvance(const PxRigidBody*const* bodyBuffer, const PxTransform* poseBuffer, const PxU32 count) {}; virtual void onWake(PxActor** actors, PxU32 count){}; virtual void onSleep(PxActor** actors, PxU32 count){}; //implement virtual void onTrigger(PxTriggerPair* pairs, PxU32 count); virtual void onContact(const PxContactPairHeader\u0026 pairHeader, const PxContactPair* pairs, PxU32 nbPairs); public: // clear m_TriggerRecords and m_ContactRecords. Called before every time you called m_pxScene-\u003esimulate void Clear(); // Copy m_TriggerRecords. Called after every time you called m_pxScene-\u003efetchResults(true) bool GetTriggerResult(PhysXArray\u003cMyTriggerResult\u003e\u0026 out); // Copy m_ContactRecords. Called after every time you called m_pxScene-\u003efetchResults(true) bool GetContactResult(PhysXArray\u003cMyContactResult\u003e\u0026 out); private: PhysXArray\u003cMyTriggerResult\u003e m_TriggerRecords; PhysXArray\u003cMyContactResult\u003e m_ContactRecords; }; void MySimulationEventCallback::onTrigger(PxTriggerPair* pairs, PxU32 count) { for (PxU32 i = 0; i \u003c count; ++i) { const PxTriggerPair\u0026 curPair = pairs[i]; // ignore pairs when shapes have been deleted if (curPair.flags \u0026 (PxTriggerPairFlag::eREMOVED_SHAPE_TRIGGER | PxTriggerPairFlag::eREMOVED_SHAPE_OTHER)) continue; MyTriggerResult result; result.Trigger = (MyActor*)curPair.triggerActor-\u003euserData; result.Collider = (MyActor*)curPair.otherActor-\u003euserData; result.Lost = (curPair.status == PxPairFlag::eNOTIFY_TOUCH_LOST); // onTriggerEnter/Exit m_TriggerRecords.push_back(result); } } void MySimulationEventCallback::onContact(const PxContactPairHeader\u0026 pairHeader, const PxContactPair* pairs, PxU32 nbPairs) { if (pairHeader.flags \u0026 PxContactPairHeaderFlag::eREMOVED_ACTOR_0 || pairHeader.flags \u0026 PxContactPairHeaderFlag::eREMOVED_ACTOR_1) { return; } PxRigidActor* actorA = (PxRigidActor*)pairHeader.actors[0]; PxRigidActor* actorB = (PxRigidActor*)pairHeader.actors[1]; for (PxU32 i = 0; i \u003c nbPairs; i++) { const PxContactPair\u0026 curPair = pairs[i]; // ignore pairs when shapes have been deleted if (curPair.flags \u0026 (PxContactPairFlag::eREMOVED_SHAPE_0 | PxContactPairFlag::eREMOVED_SHAPE_1)) { continue; } if (curPair.events \u0026 PxPairFlag::eNOTIFY_TOUCH_PERSISTS) { // do nothing when contact persists } else { MyContactResult result; result.Lost = curPair.events \u0026 PxPairFlag::eNOTIFY_TOUCH_LOST; // OnCollisionEnter/Exit result.ColliderA = actorA == NULL ? NULL : (MyActor*) actorA-\u003euserData; result.ColliderB = actorB == NULL ? NULL : (MyActor*) actorB-\u003euserData; //result.ContactPoints= //need open eNOTIFY_CONTACT_POINTS if (result.ColliderA != NULL \u0026\u0026 result.ColliderB != NULL) { m_ContactRecords.push_back(result); } } } } Golden Tips PhysX can only handle maximum 65536 total interaction on ONE actor in broadphase. Since it‚Äôs in broadphase, ‚Äútotal interaction‚Äù is regardless of actor type or filter flags.\nWhen implementing onContact method,\nMust check actors‚Äô state via PxContactPairHeaderFlag::eREMOVED_ACTOR_0 and eREMOVED_ACTOR_1 Must check shapes‚Äô state via PxContactPairFlag::eREMOVED_SHAPE_0 and eREMOVED_SHAPE_1 Must access actor via pairHeader.actors, NOT pairs[i].shapes[0]-\u003egetActor(), which may be invalid. Be careful about whether you bind userData to shape, or actor. ","wordCount":"1451","inLanguage":"en","datePublished":"2023-08-11T00:00:00Z","dateModified":"2023-08-11T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_collision/"},"publisher":{"@type":"Organization","name":"Ê≥¢Ê≥¢Ê≤ôüè†","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="Ê≥¢Ê≥¢Ê≤ôüè† (Alt + H)">Ê≥¢Ê≥¢Ê≤ôüè†</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision</h1><div class=post-meta><span title='2023-08-11 00:00:00 +0000 UTC'>August 11, 2023</span>&nbsp;¬∑&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#warm-up aria-label=Warm-up>Warm-up</a><ul><li><a href=#static-kinematic--dynamic aria-label="Static, Kinematic &amp;amp; Dynamic">Static, Kinematic & Dynamic</a></li><li><a href=#filter-mechanism aria-label="Filter mechanism">Filter mechanism</a></li><li><a href=#simulation-loop aria-label="Simulation loop">Simulation loop</a></li></ul></li><li><a href=#setup-rigidbody aria-label="Setup Rigidbody">Setup Rigidbody</a></li><li><a href=#collision-filtering aria-label="Collision Filtering">Collision Filtering</a></li><li><a href=#collision-callback aria-label="Collision Callback">Collision Callback</a></li><li><a href=#golden-tips aria-label="Golden Tips">Golden Tips</a></li></ul></div></details></div><div class=post-content><blockquote><p>Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÁ¢∞ÊíûÊ£ÄÊµãÁöÑ‰∏Ä‰∫õÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ</p><p><a href=https://pps43.github.io/tags/physx/>PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàó</a>ËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºà<a href=https://github.com/pps43/PhysX-3.4>Code</a>, <a href=https://github.com/pps43/PhysX-3.4/raw/master/PhysX_3.4/Documentation/PhysXGuide.chm>Doc</a>ÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ</p></blockquote><h1 id=warm-up>Warm-up<a hidden class=anchor aria-hidden=true href=#warm-up>#</a></h1><h2 id=static-kinematic--dynamic>Static, Kinematic & Dynamic<a hidden class=anchor aria-hidden=true href=#static-kinematic--dynamic>#</a></h2><ul><li>Static colliders are non-movable. In fact, they are not rigidbody, just <code>PxRigidStatic</code>.</li><li>Kinematic and dynamic rigidbody are both <code>PxRigidDynamic</code>, and can switch to each other at runtime by <code>setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true/false)</code>. The biggest difference is that kinematic rigidbody behaves like infinite mass, and will not move by external force. Instead, you call <code>MovePosition</code> on it.</li><li>Dynamic rigidbody is the only type we can <code>AddForce</code> to, which has mass, center of mass, and inertia tensor to simulate a natural movement with Newton&rsquo;s laws of motion.</li></ul><pre tabindex=0><code class=language-mermaid data-lang=mermaid>classDiagram

PxRigidActor &lt;-- PxRigidStatic
PxRigidActor &lt;-- PxRigidBody
PxRigidBody &lt;-- PxRigidDynamic
PxRigidActor *.. PxShape

class PxRigidBody {
    PxRigidBodyFlag
}
class PxShape {
    PxShapeFlag
}
</code></pre><p>We cannot make a rigidbody without a shape. Shapes are tangible, with a real size.</p><ul><li><p>One actor can have multiple shapes as children, each with a local position and rotation.</p></li><li><p>Each shape have a flag <code>PxShapeFlag::eSIMULATION_SHAPE</code> to determine it&rsquo;s a <strong>collider</strong> or a <strong>trigger</strong>.</p></li><li><p>When two shapes overlap (collide), a &ldquo;<strong>triggering event</strong>&rdquo; or a &ldquo;<strong>contacting event</strong>&rdquo; may raise.</p><ul><li>When two shapes are both collider, the event is contacting, otherwise triggering.</li><li>Contacting event happens only when at least one of the shape&rsquo;s belonging actor is Non-Kinematic <code>PxRigidDynamic</code>.</li><li>Triggering event happens only when at least one of the shape&rsquo;s belonging actor is <code>PxRigidbody</code>.</li><li>Two shapes must pass a filtering logic, which is usually user-defined rules. This is called &ldquo;collision filtering&rdquo;.</li></ul></li></ul><blockquote><p>Unity Engine also has a doc to explain these rules, see <a href=https://docs.unity3d.com/Manual/CollidersOverview.html>here</a>.</p></blockquote><h2 id=filter-mechanism>Filter mechanism<a hidden class=anchor aria-hidden=true href=#filter-mechanism>#</a></h2><p>Basically, collision filter decides whether a collision pair should get processed, temporarily ignored or discarded.</p><p>Historically, there are 3 different implementation in PhysX.</p><ol><li>The simpliest way is to use <strong>filter callback function</strong> to determine if two object can interact. Flexible, but too expensive/slow.</li><li>Next is <strong>Simple group based filtering rules</strong> in PhysX 2.0 (Dividing actors into predefined groups and decide if two groups can collide). Not flexible enough.</li><li>Now is <strong>Shader system</strong>+<strong>CPU callback</strong> in Physx 3+. Users can tradeoff between speed and flexiblity.</li></ol><blockquote><p>Shader System, basically, is a custom function injected to the <code>PxSceneDesc</code>, and called for all pairs of shapes that come near each other &ndash; more precisely: for all pairs of shapes whose AABB in world space are found to intersect for the first time.</p><p>Shader System runs on the <strong>vector processor</strong> and is therefore not able to access any eventual game data base in main memory, so any pointer dereference is FORBIDDEN.</p></blockquote><h2 id=simulation-loop>Simulation loop<a hidden class=anchor aria-hidden=true href=#simulation-loop>#</a></h2><p>To put it simple, here is what happens each frame:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>FixedUpdate</span><span class=p>(</span><span class=kt>float</span> <span class=n>timestep</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>m_MySimCallback</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>m_MySimCallback</span><span class=o>-&gt;</span><span class=n>Clear</span><span class=p>();</span> <span class=c1>// see later in Collision Callback section
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>m_pxScene</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>simulate</span><span class=p>(</span><span class=n>timeStep</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>m_ScratchBlock</span><span class=p>,</span> <span class=n>SCRATCH_BLOCK_SIZE</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=c1>// your shader function are called inside simulate, when AABB intersect each other.
</span></span></span><span class=line><span class=cl><span class=c1></span>		
</span></span><span class=line><span class=cl>        <span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>fetchResults</span><span class=p>(</span><span class=nb>true</span><span class=p>);</span> 
</span></span><span class=line><span class=cl>        <span class=c1>// your CPU callbacks are called inside fetchResults.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>See details on Official Manual: <a href=https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/Simulation.html>Simulation</a> and <a href=https://docs.nvidia.com/gameworks/content/gameworkslibrary/physx/guide/Manual/RigidBodyCollision.html#broad-phase-algorithms>Broadphase algorithm</a></p><h1 id=setup-rigidbody>Setup Rigidbody<a hidden class=anchor aria-hidden=true href=#setup-rigidbody>#</a></h1><p>To create a static actor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pxActor</span> <span class=o>=</span> <span class=n>sPxPhysics</span><span class=o>-&gt;</span><span class=n>createRigidStatic</span><span class=p>(</span><span class=n>actorTransform</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pxActor</span><span class=o>-&gt;</span><span class=n>setName</span><span class=p>(</span><span class=s>&#34;xxx&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pxActor</span><span class=o>-&gt;</span><span class=n>userData</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>myActorWrapper</span><span class=p>;</span> <span class=c1>// bind to your game actor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>addActor</span><span class=p>(</span><span class=o>*</span><span class=n>pxActor</span><span class=p>);</span>
</span></span></code></pre></div><p>To create a dynamic/kinematic actor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pxActor</span> <span class=o>=</span> <span class=n>sPxPhysics</span><span class=o>-&gt;</span><span class=n>createRigidDynamic</span><span class=p>(</span><span class=n>actorTransform</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pxActor</span><span class=o>-&gt;</span><span class=n>setName</span><span class=p>(</span><span class=s>&#34;xxx&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>pxActor</span><span class=o>-&gt;</span><span class=n>userData</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>myActorWrapper</span><span class=p>;</span><span class=c1>// bind to your game actor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m_pxScene</span><span class=o>-&gt;</span><span class=n>addActor</span><span class=p>(</span><span class=o>*</span><span class=n>pxActor</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>((</span><span class=n>PxRigidDynamic</span><span class=o>*</span><span class=p>)</span><span class=n>pxActor</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>setRigidBodyFlag</span><span class=p>(</span><span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eENABLE_CCD</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// set more property, e.g., linear damping, actor flag...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>isKinematic</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=n>PxRigidDynamic</span><span class=o>*</span><span class=p>)</span><span class=n>pxActor</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>setRigidBodyFlag</span><span class=p>(</span><span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eENABLE_CCD</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>((</span><span class=n>PxRigidDynamic</span><span class=o>*</span><span class=p>)</span><span class=n>pxActor</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>setRigidBodyFlag</span><span class=p>(</span><span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eKINEMATIC</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To set collision data on each shape for filtering later:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PxFilterData</span> <span class=n>collisionFilter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>collisionFilter</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=n>layer</span><span class=p>;</span> <span class=c1>// ePlayer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>collisionFilter</span><span class=p>.</span><span class=n>word1</span> <span class=o>=</span> <span class=n>layerAgainst</span><span class=p>;</span> <span class=c1>// eGroud | eWall | eObstacle
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>shape</span><span class=o>-&gt;</span><span class=n>setSimulationFilterData</span><span class=p>(</span><span class=n>collisionFilter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>isTrigger</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>shape</span><span class=o>-&gt;</span><span class=n>setFlag</span><span class=p>(</span><span class=n>PxShapeFlag</span><span class=o>::</span><span class=n>eSIMULATION_SHAPE</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>shape</span><span class=o>-&gt;</span><span class=n>setFlag</span><span class=p>(</span><span class=n>PxShapeFlag</span><span class=o>::</span><span class=n>eTRIGGER_SHAPE</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To register collision filtering and collision callback to all rigidbodies (when creating a <code>PxScene</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>m_MySimCallback</span> <span class=o>=</span> <span class=k>new</span> <span class=n>MySimulationEventCallback</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>PxSceneDesc</span> <span class=nf>sceneDesc</span><span class=p>(</span><span class=n>sPxPhysics</span><span class=o>-&gt;</span><span class=n>getTolerancesScale</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=n>sceneDesc</span><span class=p>.</span><span class=n>filterShader</span> <span class=o>=</span> <span class=n>MyFilterShader</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>sceneDesc</span><span class=p>.</span><span class=n>simulationEventCallback</span> <span class=o>=</span> <span class=n>m_MySimCallback</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>m_pxScene</span> <span class=o>=</span> <span class=n>sPxPhysics</span><span class=o>-&gt;</span><span class=n>createScene</span><span class=p>(</span><span class=n>sceneDesc</span><span class=p>);</span>
</span></span></code></pre></div><h1 id=collision-filtering>Collision Filtering<a hidden class=anchor aria-hidden=true href=#collision-filtering>#</a></h1><p>Just define a function that meets type <code>PxSimulationFilterShader</code> (function pointer).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PxFilterFlags</span> <span class=nf>MyFilterShader</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=n>PxFilterObjectAttributes</span> <span class=n>attributes0</span><span class=p>,</span> <span class=n>PxFilterData</span> <span class=n>filterData0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>PxFilterObjectAttributes</span> <span class=n>attributes1</span><span class=p>,</span> <span class=n>PxFilterData</span> <span class=n>filterData1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>PxPairFlags</span><span class=o>&amp;</span> <span class=n>pairFlags</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span><span class=o>*</span> <span class=n>constantBlock</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>constantBlockSize</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// for triggers
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>PxFilterObjectIsTrigger</span><span class=p>(</span><span class=n>attributes0</span><span class=p>)</span> <span class=o>||</span> <span class=n>PxFilterObjectIsTrigger</span><span class=p>(</span><span class=n>attributes1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>pairFlags</span> <span class=o>=</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eTRIGGER_DEFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// here I do not examine PxFilterData and just let it pass
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>return</span> <span class=n>PxFilterFlag</span><span class=o>::</span><span class=n>eDEFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span> <span class=c1>// for collisions
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// Use word0 as self layer, word1 as layerAgainst.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// word2 and word3 are not used here.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// In most cases, collision rules are symmetric.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// Here we use `||` just in case rules are asymmetric, which is equal to &#34;Collision only happens if A can collide with B and B can collide with A.&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>if</span> <span class=p>((</span><span class=mi>0</span> <span class=o>==</span> <span class=p>(</span><span class=n>filterData0</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData1</span><span class=p>.</span><span class=n>word1</span><span class=p>))</span> <span class=o>||</span> <span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=p>(</span><span class=n>filterData1</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData0</span><span class=p>.</span><span class=n>word1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>			<span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=n>PxFilterFlag</span><span class=o>::</span><span class=n>eSUPPRESS</span><span class=p>;</span> <span class=c1>// no collide
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// use contact solver, and use CCD detection
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>pairFlags</span> <span class=o>=</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eCONTACT_DEFAULT</span> <span class=o>|</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eDETECT_CCD_CONTACT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=c1>// notify onContact event
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>pairFlags</span> <span class=o>|=</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_FOUND</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                        <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_CCD</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                        <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_LOST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=n>PxFilterFlag</span><span class=o>::</span><span class=n>eDEFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span></code></pre></div><ul><li><p><code>PxFilterObjectAttributes</code> param is 32bit flag.</p><table><thead><tr><th>value</th><th>meaning</th></tr></thead><tbody><tr><td>0</td><td>eRIGID_STATIC</td></tr><tr><td>1</td><td>eRIGID_DYNAMIC</td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr><tr><td>15</td><td>as low mask</td></tr><tr><td>1&#171;4</td><td>eKINEMATIC</td></tr><tr><td>1&#171;5</td><td>eTRIGGER</td></tr></tbody></table></li><li><p><code>PxFilterFlags</code> is return value tells PhysX what to do next.</p><table><thead><tr><th>enum</th><th>value</th><th>meaning</th></tr></thead><tbody><tr><td><code>eDEFAULT</code></td><td>0</td><td>Processed with NO filter callback</td></tr><tr><td><code>eKILL</code></td><td>1&#171;0</td><td>Ignore the collision pair as long as the bounding volumes of the pair objects overlap. Until one of these conditions are met:The bounding volumes of the two objects overlap again (after being separated) The user enforces a re-filtering</td></tr><tr><td></td><td></td><td></td></tr><tr><td><code>eSUPPRESS</code></td><td>1&#171;1</td><td>Similar to eKill, except one more condition that filter data or attribute changes.‚úÖUsually use this.</td></tr><tr><td><code>eCALLBACK</code></td><td>1&#171;2</td><td>Use <code>PxSimulationFilterCallback::pairFound()</code>. ‚ö†SLOW!</td></tr><tr><td><code>eNOTIFY</code></td><td>1&#171;3 | eCALLBACK</td><td>Besides <code>eCALLBACK</code>, plus <code>pairLost()</code>. ‚ö†SLOW!</td></tr></tbody></table></li><li><p><code>PxPairFlags</code> is modifiable, to provide more info on what to do next.</p><table><thead><tr><th>enum</th><th>value</th><th>meaning</th></tr></thead><tbody><tr><td><code>eSOLVE_CONTACT</code></td><td>1&#171;0</td><td>need process contact for this pair</td></tr><tr><td><code>eMODIFY_CONTACTS</code></td><td>1&#171;1</td><td></td></tr><tr><td><code>eNOTIFY_TOUCH_FOUND</code></td><td>1&#171;2</td><td>Raise event when &ldquo;enter&rdquo;</td></tr><tr><td><code>eNOTIFY_TOUCH_PERSISTS</code></td><td>1&#171;3</td><td>Raise event when &ldquo;stay&rdquo;</td></tr><tr><td><code>eNOTIFY_TOUCH_LOST</code></td><td>1&#171;4</td><td>Raise event when &ldquo;exit&rdquo;</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td></td></tr><tr><td><code>eNOTIFY_CONTACT_POINTS</code></td><td>1&#171;9</td><td>Add contact points info</td></tr><tr><td><code>eDETECT_DISCRETE_CONTACT</code></td><td>1&#171;10</td><td>Discrete detection algorithm. Valid when <code>eSOLVE_CONTACT</code></td></tr><tr><td><code>eDETECT_CCD_CONTACT</code></td><td>1&#171;11</td><td>Continous detection algoritym. Valid when <code>eSOLVE_CONTACT</code>, <code>PxSceneFlag::eENABLE_CCD</code>, and <code>PxRigidBodyFlag::eENABLE_CCD</code> are all set.</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td></td></tr><tr><td><code>eCONTACT_DEFAULT</code></td><td>&mldr;</td><td><code>eSOLVE_CONTACT</code> | <code>eDETECT_DISCRETE_CONTACT</code></td></tr><tr><td><code>eTRIGGER_DEFAULT</code></td><td>&mldr;</td><td><code>eNOTIFY_TOUCH_FOUND</code> | <code>eNOTIFY_TOUCH_LOST</code> | <code>eDETECT_DISCRETE_CONTACT</code></td></tr></tbody></table></li></ul><h1 id=collision-callback>Collision Callback<a hidden class=anchor aria-hidden=true href=#collision-callback>#</a></h1><blockquote><p>This is also how Unity <code>OnTriggerEnter/Exit</code> and <code>OnCollisionEnter/Stay/Exit</code> are based on.</p></blockquote><p>Creat a new class inheriting <code>PxSimulationEventCallback</code> and override its functions. In below example, we only implement <code>onTrigger</code> and <code>onContact</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MySimulationEventCallback</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PxSimulationEventCallback</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span> <span class=c1>//from PxSimulationEventCallback
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//ignore
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>onConstraintBreak</span><span class=p>(</span><span class=n>PxConstraintInfo</span><span class=o>*</span> <span class=n>constraints</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>count</span><span class=p>)</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onAdvance</span><span class=p>(</span><span class=k>const</span> <span class=n>PxRigidBody</span><span class=o>*</span><span class=k>const</span><span class=o>*</span> <span class=n>bodyBuffer</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxTransform</span><span class=o>*</span> <span class=n>poseBuffer</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxU32</span> <span class=n>count</span><span class=p>)</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onWake</span><span class=p>(</span><span class=n>PxActor</span><span class=o>**</span> <span class=n>actors</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>count</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onSleep</span><span class=p>(</span><span class=n>PxActor</span><span class=o>**</span> <span class=n>actors</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>count</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>	<span class=c1>//implement
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onTrigger</span><span class=p>(</span><span class=n>PxTriggerPair</span><span class=o>*</span> <span class=n>pairs</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onContact</span><span class=p>(</span><span class=k>const</span> <span class=n>PxContactPairHeader</span><span class=o>&amp;</span> <span class=n>pairHeader</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxContactPair</span><span class=o>*</span> <span class=n>pairs</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>nbPairs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// clear m_TriggerRecords and m_ContactRecords. Called before every time you called m_pxScene-&gt;simulate
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=n>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy m_TriggerRecords. Called after every time you called m_pxScene-&gt;fetchResults(true)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=nf>GetTriggerResult</span><span class=p>(</span><span class=n>PhysXArray</span><span class=o>&lt;</span><span class=n>MyTriggerResult</span><span class=o>&gt;&amp;</span> <span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy m_ContactRecords. Called after every time you called m_pxScene-&gt;fetchResults(true)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=nf>GetContactResult</span><span class=p>(</span><span class=n>PhysXArray</span><span class=o>&lt;</span><span class=n>MyContactResult</span><span class=o>&gt;&amp;</span> <span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXArray</span><span class=o>&lt;</span><span class=n>MyTriggerResult</span><span class=o>&gt;</span> <span class=n>m_TriggerRecords</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXArray</span><span class=o>&lt;</span><span class=n>MyContactResult</span><span class=o>&gt;</span> <span class=n>m_ContactRecords</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MySimulationEventCallback</span><span class=o>::</span><span class=n>onTrigger</span><span class=p>(</span><span class=n>PxTriggerPair</span><span class=o>*</span> <span class=n>pairs</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>count</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>PxU32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>PxTriggerPair</span><span class=o>&amp;</span> <span class=n>curPair</span> <span class=o>=</span> <span class=n>pairs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=c1>// ignore pairs when shapes have been deleted
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>curPair</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PxTriggerPairFlag</span><span class=o>::</span><span class=n>eREMOVED_SHAPE_TRIGGER</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                    <span class=n>PxTriggerPairFlag</span><span class=o>::</span><span class=n>eREMOVED_SHAPE_OTHER</span><span class=p>))</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>MyTriggerResult</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span><span class=p>.</span><span class=n>Trigger</span> <span class=o>=</span> <span class=p>(</span><span class=n>MyActor</span><span class=o>*</span><span class=p>)</span><span class=n>curPair</span><span class=p>.</span><span class=n>triggerActor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span><span class=p>.</span><span class=n>Collider</span> <span class=o>=</span> <span class=p>(</span><span class=n>MyActor</span><span class=o>*</span><span class=p>)</span><span class=n>curPair</span><span class=p>.</span><span class=n>otherActor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>result</span><span class=p>.</span><span class=n>Lost</span> <span class=o>=</span> <span class=p>(</span><span class=n>curPair</span><span class=p>.</span><span class=n>status</span> <span class=o>==</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_LOST</span><span class=p>);</span> <span class=c1>// onTriggerEnter/Exit
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>m_TriggerRecords</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MySimulationEventCallback</span><span class=o>::</span><span class=n>onContact</span><span class=p>(</span><span class=k>const</span> <span class=n>PxContactPairHeader</span><span class=o>&amp;</span> <span class=n>pairHeader</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxContactPair</span><span class=o>*</span> <span class=n>pairs</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>nbPairs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>pairHeader</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>PxContactPairHeaderFlag</span><span class=o>::</span><span class=n>eREMOVED_ACTOR_0</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>		<span class=n>pairHeader</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>PxContactPairHeaderFlag</span><span class=o>::</span><span class=n>eREMOVED_ACTOR_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actorA</span> <span class=o>=</span> <span class=p>(</span><span class=n>PxRigidActor</span><span class=o>*</span><span class=p>)</span><span class=n>pairHeader</span><span class=p>.</span><span class=n>actors</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actorB</span> <span class=o>=</span> <span class=p>(</span><span class=n>PxRigidActor</span><span class=o>*</span><span class=p>)</span><span class=n>pairHeader</span><span class=p>.</span><span class=n>actors</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>PxU32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nbPairs</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>PxContactPair</span><span class=o>&amp;</span> <span class=n>curPair</span> <span class=o>=</span> <span class=n>pairs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// ignore pairs when shapes have been deleted
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>curPair</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PxContactPairFlag</span><span class=o>::</span><span class=n>eREMOVED_SHAPE_0</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                    <span class=n>PxContactPairFlag</span><span class=o>::</span><span class=n>eREMOVED_SHAPE_1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>curPair</span><span class=p>.</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_PERSISTS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// do nothing when contact persists
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>MyContactResult</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>result</span><span class=p>.</span><span class=n>Lost</span> <span class=o>=</span> <span class=n>curPair</span><span class=p>.</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_LOST</span><span class=p>;</span> <span class=c1>// OnCollisionEnter/Exit
</span></span></span><span class=line><span class=cl><span class=c1></span>			
</span></span><span class=line><span class=cl>			<span class=n>result</span><span class=p>.</span><span class=n>ColliderA</span> <span class=o>=</span> <span class=n>actorA</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=p>(</span><span class=n>MyActor</span><span class=o>*</span><span class=p>)</span> <span class=n>actorA</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>result</span><span class=p>.</span><span class=n>ColliderB</span> <span class=o>=</span> <span class=n>actorB</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=p>(</span><span class=n>MyActor</span><span class=o>*</span><span class=p>)</span> <span class=n>actorB</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=c1>//result.ContactPoints= //need open eNOTIFY_CONTACT_POINTS
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>ColliderA</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>result</span><span class=p>.</span><span class=n>ColliderB</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>m_ContactRecords</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=golden-tips>Golden Tips<a hidden class=anchor aria-hidden=true href=#golden-tips>#</a></h1><ul><li><p>PhysX can only handle maximum <code>65536</code> total interaction on ONE actor in broadphase. Since it&rsquo;s in broadphase, &ldquo;total interaction&rdquo; is regardless of actor type or filter flags.</p></li><li><p>When implementing <code>onContact</code> method,</p><ul><li>Must check actors&rsquo; state via <code>PxContactPairHeaderFlag::eREMOVED_ACTOR_0</code> and <code>eREMOVED_ACTOR_1</code></li><li>Must check shapes&rsquo; state via <code>PxContactPairFlag::eREMOVED_SHAPE_0</code> and <code>eREMOVED_SHAPE_1</code></li><li>Must access actor via <code>pairHeader.actors</code>, NOT <code>pairs[i].shapes[0]->getActor()</code>, which may be invalid.</li><li>Be careful about whether you bind userData to shape, or actor.</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/using_physx_rigidbody/><span class=title>¬´ Prev</span><br><span>PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics</span></a>
<a class=next href=https://pps43.github.io/posts/thinking_of_lossyscale/><span class=title>Next ¬ª</span><br><span>Ê∑±ÂÖ• LossyScale</span></a></nav></footer></article></main><footer class=footer><span>¬© 2016-2023 By Ê≥¢Ê≥¢Ê≤ô.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>