<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç° | æ³¢æ³¢æ²™ğŸ </title>
<meta name=keywords content="Game Dev,PhysX,Unity"><meta name=description content="
æœ¬æ–‡ä¹Ÿæ˜¯PhysXç‰©ç†å¼•æ“ç³»åˆ—çš„ç•ªå¤–ç¯‡ã€‚ä»‹ç»äº†ç¬”è€…åŸºäºCharacterController(CCT)è®¾è®¡çš„ä¸€ä¸ªæ–°çš„è§’è‰²æ§åˆ¶å™¨ï¼Œåœ¨ä¿®è¡¥Unity/PhysXçš„CCTçš„ç¼ºé™·å¤–ï¼Œè¿˜å¢æ·»äº†è‹¥å¹²å’Œç‰©ç†äº¤äº’ç›¸å…³çš„æœ‰è¶£ç‰¹æ€§ã€‚ä»£ç å·²ç»è¿‡å®é™…é¡¹ç›®éªŒè¯ï¼Œè¿™é‡Œä»…ä¿ç•™å’Œå…·ä½“ä¸šåŠ¡æ— å…³çš„éƒ¨åˆ†ã€‚
èƒŒæ™¯å’Œéœ€æ±‚
å‰æ–‡ç»“å°¾å¤„æåˆ°ä¸€äº›PhysXè‡ªå¸¦çš„CCTï¼ˆUnityä¹Ÿæ˜¯åŸºäºæ­¤äºŒæ¬¡å°è£…å‡ºCharacterControllerç»„ä»¶ï¼‰åœ¨å®é™…æ¸¸æˆå¼€å‘ä¸­çš„ç¼ºç‚¹ï¼Œè¿™é‡Œå†æ¬¡æ€»ç»“ï¼š

CCTä¸å‚ä¸ç¢°æ’ç³»ç»Ÿçš„æ£€æµ‹ã€‚ä»…å½“CCTè‡ªèº«ç§»åŠ¨æ—¶ä¼šåˆ¤æ–­æ˜¯å¦è¢«å…¶ä»–åˆšä½“æˆ–CCTé˜»æŒ¡ã€‚è¿™å°±é€ æˆä¸€ä¸ªBUGï¼šCCTè‡ªèº«é™æ­¢æ—¶ï¼Œå…¶ä»–è¿åŠ¨ç‰©ä½“ä¼šç©¿è¿‡CCTä¸”æ²¡æœ‰äº‹ä»¶è§¦å‘ã€‚å®˜æ–¹è®ºå›ä¸Šæœ‰è‹¦ä¸»æŒç»­8å¹´å‘Unityåé¦ˆè¿™ä¸ªé—®é¢˜ä½†æ— æ³•è§£å†³ï¼Œç›®å‰å·²çŸ¥çš„å”¯ä¸€ç»•è¿‡æ–¹å¼æ˜¯æ¯å¸§ç»™CCTé™„åŠ ä¸€ä¸ªå¾®å°çš„ä½ç§»ï¼ˆä¸‹æ–‡ä¸­çš„SlightMoveï¼‰ã€‚
Unityæä¾›çš„æ¥å£CharacterController.isGroundedæ•ˆæœå¾ˆä¸ç¨³å®šã€‚å…¶å†…éƒ¨åªæ˜¯åˆ¤æ–­CCTä¸Šæ¬¡è¿åŠ¨ååº•éƒ¨æ˜¯å¦è§¦ç¢°ç‰©ä½“ã€‚å³collisionFlags & eCOLLISION_DOWN::eCOLLISION_DOWNã€‚ä½†åœ¨ä¸Šä¸‹å¡æˆ–å´å²–åœ°å½¢æ—¶ï¼Œå¾ˆå®¹æ˜“å‡ºç°ä¾§é¢è§¦ç¢°æˆ–çŸ­æš‚æµ®ç©ºã€‚å¦‚æœç”¨è¯¥æ¥å£é©±åŠ¨åŠ¨ç”»è¡¨ç°ç”šè‡³è·‘è·³é€»è¾‘ï¼Œæ•ˆæœå¾ˆå·®ã€‚éœ€è¦è‡ªè¡ŒåŸºäºSceneQueryå°è£…å‡ºæ›´åŠ ç¨³å®šçš„åˆ¤å®šç€åœ°çš„å‡½æ•°ã€‚
Unityæ²¡æœ‰æš´éœ²CCT.upVectorï¼Œè§’è‰²æ€»æ˜¯ç«–ç›´å‘ä¸Šçš„ã€‚è¦å®ç°åé‡åŠ›é‹åœ¨ä»»æ„æ–œé¢ä¸Šè¡Œèµ°æˆ–åƒé©¬é‡Œå¥¥é“¶æ²³é‚£æ ·åœ¨æ›²é¢ä¸Šè·‘è·³ç©¿æ¢­ï¼Œåªèƒ½æ”¾å¼ƒä½¿ç”¨CCTä½†ä¹Ÿæ”¾å¼ƒäº†å…¶åœ¨æ“ä½œæ‰‹æ„Ÿä¸Šçš„æ”¹å–„ã€‚å…¶å®æ‹¿åˆ°Unityçš„æºç åï¼Œåªç”¨äº†ååˆ†é’Ÿå°†åº•å±‚å­—æ®µæš´éœ²åˆ°C#å±‚å°±è§£å†³äº†è¯¥é—®é¢˜ã€‚

æ–°çš„è§’è‰²æ§åˆ¶å™¨éœ€è¦å¢åŠ çš„ç‰©ç†äº¤äº’ç‰¹æ€§æœ‰ï¼š"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/notes_on_physics_based_cct/><link crossorigin=anonymous href=/assets/css/stylesheet.da461cdc6aa5b1045299cab0ebd07edbb2f1e481e0c7ae775d260fc5af887327.css integrity="sha256-2kYc3GqlsQRSmcqw69B+27Lx5IHgx653XSYPxa+Icyc=" rel="preload stylesheet" as=style><link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pps43.github.io/posts/notes_on_physics_based_cct/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL")}</script><meta property="og:url" content="https://pps43.github.io/posts/notes_on_physics_based_cct/"><meta property="og:site_name" content="æ³¢æ³¢æ²™ğŸ "><meta property="og:title" content="å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°"><meta property="og:description" content=" æœ¬æ–‡ä¹Ÿæ˜¯PhysXç‰©ç†å¼•æ“ç³»åˆ—çš„ç•ªå¤–ç¯‡ã€‚ä»‹ç»äº†ç¬”è€…åŸºäºCharacterController(CCT)è®¾è®¡çš„ä¸€ä¸ªæ–°çš„è§’è‰²æ§åˆ¶å™¨ï¼Œåœ¨ä¿®è¡¥Unity/PhysXçš„CCTçš„ç¼ºé™·å¤–ï¼Œè¿˜å¢æ·»äº†è‹¥å¹²å’Œç‰©ç†äº¤äº’ç›¸å…³çš„æœ‰è¶£ç‰¹æ€§ã€‚ä»£ç å·²ç»è¿‡å®é™…é¡¹ç›®éªŒè¯ï¼Œè¿™é‡Œä»…ä¿ç•™å’Œå…·ä½“ä¸šåŠ¡æ— å…³çš„éƒ¨åˆ†ã€‚
èƒŒæ™¯å’Œéœ€æ±‚ å‰æ–‡ç»“å°¾å¤„æåˆ°ä¸€äº›PhysXè‡ªå¸¦çš„CCTï¼ˆUnityä¹Ÿæ˜¯åŸºäºæ­¤äºŒæ¬¡å°è£…å‡ºCharacterControllerç»„ä»¶ï¼‰åœ¨å®é™…æ¸¸æˆå¼€å‘ä¸­çš„ç¼ºç‚¹ï¼Œè¿™é‡Œå†æ¬¡æ€»ç»“ï¼š
CCTä¸å‚ä¸ç¢°æ’ç³»ç»Ÿçš„æ£€æµ‹ã€‚ä»…å½“CCTè‡ªèº«ç§»åŠ¨æ—¶ä¼šåˆ¤æ–­æ˜¯å¦è¢«å…¶ä»–åˆšä½“æˆ–CCTé˜»æŒ¡ã€‚è¿™å°±é€ æˆä¸€ä¸ªBUGï¼šCCTè‡ªèº«é™æ­¢æ—¶ï¼Œå…¶ä»–è¿åŠ¨ç‰©ä½“ä¼šç©¿è¿‡CCTä¸”æ²¡æœ‰äº‹ä»¶è§¦å‘ã€‚å®˜æ–¹è®ºå›ä¸Šæœ‰è‹¦ä¸»æŒç»­8å¹´å‘Unityåé¦ˆè¿™ä¸ªé—®é¢˜ä½†æ— æ³•è§£å†³ï¼Œç›®å‰å·²çŸ¥çš„å”¯ä¸€ç»•è¿‡æ–¹å¼æ˜¯æ¯å¸§ç»™CCTé™„åŠ ä¸€ä¸ªå¾®å°çš„ä½ç§»ï¼ˆä¸‹æ–‡ä¸­çš„SlightMoveï¼‰ã€‚ Unityæä¾›çš„æ¥å£CharacterController.isGroundedæ•ˆæœå¾ˆä¸ç¨³å®šã€‚å…¶å†…éƒ¨åªæ˜¯åˆ¤æ–­CCTä¸Šæ¬¡è¿åŠ¨ååº•éƒ¨æ˜¯å¦è§¦ç¢°ç‰©ä½“ã€‚å³collisionFlags & eCOLLISION_DOWN::eCOLLISION_DOWNã€‚ä½†åœ¨ä¸Šä¸‹å¡æˆ–å´å²–åœ°å½¢æ—¶ï¼Œå¾ˆå®¹æ˜“å‡ºç°ä¾§é¢è§¦ç¢°æˆ–çŸ­æš‚æµ®ç©ºã€‚å¦‚æœç”¨è¯¥æ¥å£é©±åŠ¨åŠ¨ç”»è¡¨ç°ç”šè‡³è·‘è·³é€»è¾‘ï¼Œæ•ˆæœå¾ˆå·®ã€‚éœ€è¦è‡ªè¡ŒåŸºäºSceneQueryå°è£…å‡ºæ›´åŠ ç¨³å®šçš„åˆ¤å®šç€åœ°çš„å‡½æ•°ã€‚ Unityæ²¡æœ‰æš´éœ²CCT.upVectorï¼Œè§’è‰²æ€»æ˜¯ç«–ç›´å‘ä¸Šçš„ã€‚è¦å®ç°åé‡åŠ›é‹åœ¨ä»»æ„æ–œé¢ä¸Šè¡Œèµ°æˆ–åƒé©¬é‡Œå¥¥é“¶æ²³é‚£æ ·åœ¨æ›²é¢ä¸Šè·‘è·³ç©¿æ¢­ï¼Œåªèƒ½æ”¾å¼ƒä½¿ç”¨CCTä½†ä¹Ÿæ”¾å¼ƒäº†å…¶åœ¨æ“ä½œæ‰‹æ„Ÿä¸Šçš„æ”¹å–„ã€‚å…¶å®æ‹¿åˆ°Unityçš„æºç åï¼Œåªç”¨äº†ååˆ†é’Ÿå°†åº•å±‚å­—æ®µæš´éœ²åˆ°C#å±‚å°±è§£å†³äº†è¯¥é—®é¢˜ã€‚ æ–°çš„è§’è‰²æ§åˆ¶å™¨éœ€è¦å¢åŠ çš„ç‰©ç†äº¤äº’ç‰¹æ€§æœ‰ï¼š"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-18T00:00:00+00:00"><meta property="article:tag" content="Game Dev"><meta property="article:tag" content="PhysX"><meta property="article:tag" content="Unity"><meta name=twitter:card content="summary"><meta name=twitter:title content="å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°"><meta name=twitter:description content="
æœ¬æ–‡ä¹Ÿæ˜¯PhysXç‰©ç†å¼•æ“ç³»åˆ—çš„ç•ªå¤–ç¯‡ã€‚ä»‹ç»äº†ç¬”è€…åŸºäºCharacterController(CCT)è®¾è®¡çš„ä¸€ä¸ªæ–°çš„è§’è‰²æ§åˆ¶å™¨ï¼Œåœ¨ä¿®è¡¥Unity/PhysXçš„CCTçš„ç¼ºé™·å¤–ï¼Œè¿˜å¢æ·»äº†è‹¥å¹²å’Œç‰©ç†äº¤äº’ç›¸å…³çš„æœ‰è¶£ç‰¹æ€§ã€‚ä»£ç å·²ç»è¿‡å®é™…é¡¹ç›®éªŒè¯ï¼Œè¿™é‡Œä»…ä¿ç•™å’Œå…·ä½“ä¸šåŠ¡æ— å…³çš„éƒ¨åˆ†ã€‚
èƒŒæ™¯å’Œéœ€æ±‚
å‰æ–‡ç»“å°¾å¤„æåˆ°ä¸€äº›PhysXè‡ªå¸¦çš„CCTï¼ˆUnityä¹Ÿæ˜¯åŸºäºæ­¤äºŒæ¬¡å°è£…å‡ºCharacterControllerç»„ä»¶ï¼‰åœ¨å®é™…æ¸¸æˆå¼€å‘ä¸­çš„ç¼ºç‚¹ï¼Œè¿™é‡Œå†æ¬¡æ€»ç»“ï¼š

CCTä¸å‚ä¸ç¢°æ’ç³»ç»Ÿçš„æ£€æµ‹ã€‚ä»…å½“CCTè‡ªèº«ç§»åŠ¨æ—¶ä¼šåˆ¤æ–­æ˜¯å¦è¢«å…¶ä»–åˆšä½“æˆ–CCTé˜»æŒ¡ã€‚è¿™å°±é€ æˆä¸€ä¸ªBUGï¼šCCTè‡ªèº«é™æ­¢æ—¶ï¼Œå…¶ä»–è¿åŠ¨ç‰©ä½“ä¼šç©¿è¿‡CCTä¸”æ²¡æœ‰äº‹ä»¶è§¦å‘ã€‚å®˜æ–¹è®ºå›ä¸Šæœ‰è‹¦ä¸»æŒç»­8å¹´å‘Unityåé¦ˆè¿™ä¸ªé—®é¢˜ä½†æ— æ³•è§£å†³ï¼Œç›®å‰å·²çŸ¥çš„å”¯ä¸€ç»•è¿‡æ–¹å¼æ˜¯æ¯å¸§ç»™CCTé™„åŠ ä¸€ä¸ªå¾®å°çš„ä½ç§»ï¼ˆä¸‹æ–‡ä¸­çš„SlightMoveï¼‰ã€‚
Unityæä¾›çš„æ¥å£CharacterController.isGroundedæ•ˆæœå¾ˆä¸ç¨³å®šã€‚å…¶å†…éƒ¨åªæ˜¯åˆ¤æ–­CCTä¸Šæ¬¡è¿åŠ¨ååº•éƒ¨æ˜¯å¦è§¦ç¢°ç‰©ä½“ã€‚å³collisionFlags & eCOLLISION_DOWN::eCOLLISION_DOWNã€‚ä½†åœ¨ä¸Šä¸‹å¡æˆ–å´å²–åœ°å½¢æ—¶ï¼Œå¾ˆå®¹æ˜“å‡ºç°ä¾§é¢è§¦ç¢°æˆ–çŸ­æš‚æµ®ç©ºã€‚å¦‚æœç”¨è¯¥æ¥å£é©±åŠ¨åŠ¨ç”»è¡¨ç°ç”šè‡³è·‘è·³é€»è¾‘ï¼Œæ•ˆæœå¾ˆå·®ã€‚éœ€è¦è‡ªè¡ŒåŸºäºSceneQueryå°è£…å‡ºæ›´åŠ ç¨³å®šçš„åˆ¤å®šç€åœ°çš„å‡½æ•°ã€‚
Unityæ²¡æœ‰æš´éœ²CCT.upVectorï¼Œè§’è‰²æ€»æ˜¯ç«–ç›´å‘ä¸Šçš„ã€‚è¦å®ç°åé‡åŠ›é‹åœ¨ä»»æ„æ–œé¢ä¸Šè¡Œèµ°æˆ–åƒé©¬é‡Œå¥¥é“¶æ²³é‚£æ ·åœ¨æ›²é¢ä¸Šè·‘è·³ç©¿æ¢­ï¼Œåªèƒ½æ”¾å¼ƒä½¿ç”¨CCTä½†ä¹Ÿæ”¾å¼ƒäº†å…¶åœ¨æ“ä½œæ‰‹æ„Ÿä¸Šçš„æ”¹å–„ã€‚å…¶å®æ‹¿åˆ°Unityçš„æºç åï¼Œåªç”¨äº†ååˆ†é’Ÿå°†åº•å±‚å­—æ®µæš´éœ²åˆ°C#å±‚å°±è§£å†³äº†è¯¥é—®é¢˜ã€‚

æ–°çš„è§’è‰²æ§åˆ¶å™¨éœ€è¦å¢åŠ çš„ç‰©ç†äº¤äº’ç‰¹æ€§æœ‰ï¼š"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":2,"name":"å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°","item":"https://pps43.github.io/posts/notes_on_physics_based_cct/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°","name":"å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°","description":" æœ¬æ–‡ä¹Ÿæ˜¯PhysXç‰©ç†å¼•æ“ç³»åˆ—çš„ç•ªå¤–ç¯‡ã€‚ä»‹ç»äº†ç¬”è€…åŸºäºCharacterController(CCT)è®¾è®¡çš„ä¸€ä¸ªæ–°çš„è§’è‰²æ§åˆ¶å™¨ï¼Œåœ¨ä¿®è¡¥Unity/PhysXçš„CCTçš„ç¼ºé™·å¤–ï¼Œè¿˜å¢æ·»äº†è‹¥å¹²å’Œç‰©ç†äº¤äº’ç›¸å…³çš„æœ‰è¶£ç‰¹æ€§ã€‚ä»£ç å·²ç»è¿‡å®é™…é¡¹ç›®éªŒè¯ï¼Œè¿™é‡Œä»…ä¿ç•™å’Œå…·ä½“ä¸šåŠ¡æ— å…³çš„éƒ¨åˆ†ã€‚\nèƒŒæ™¯å’Œéœ€æ±‚ å‰æ–‡ç»“å°¾å¤„æåˆ°ä¸€äº›PhysXè‡ªå¸¦çš„CCTï¼ˆUnityä¹Ÿæ˜¯åŸºäºæ­¤äºŒæ¬¡å°è£…å‡ºCharacterControllerç»„ä»¶ï¼‰åœ¨å®é™…æ¸¸æˆå¼€å‘ä¸­çš„ç¼ºç‚¹ï¼Œè¿™é‡Œå†æ¬¡æ€»ç»“ï¼š\nCCTä¸å‚ä¸ç¢°æ’ç³»ç»Ÿçš„æ£€æµ‹ã€‚ä»…å½“CCTè‡ªèº«ç§»åŠ¨æ—¶ä¼šåˆ¤æ–­æ˜¯å¦è¢«å…¶ä»–åˆšä½“æˆ–CCTé˜»æŒ¡ã€‚è¿™å°±é€ æˆä¸€ä¸ªBUGï¼šCCTè‡ªèº«é™æ­¢æ—¶ï¼Œå…¶ä»–è¿åŠ¨ç‰©ä½“ä¼šç©¿è¿‡CCTä¸”æ²¡æœ‰äº‹ä»¶è§¦å‘ã€‚å®˜æ–¹è®ºå›ä¸Šæœ‰è‹¦ä¸»æŒç»­8å¹´å‘Unityåé¦ˆè¿™ä¸ªé—®é¢˜ä½†æ— æ³•è§£å†³ï¼Œç›®å‰å·²çŸ¥çš„å”¯ä¸€ç»•è¿‡æ–¹å¼æ˜¯æ¯å¸§ç»™CCTé™„åŠ ä¸€ä¸ªå¾®å°çš„ä½ç§»ï¼ˆä¸‹æ–‡ä¸­çš„SlightMoveï¼‰ã€‚ Unityæä¾›çš„æ¥å£CharacterController.isGroundedæ•ˆæœå¾ˆä¸ç¨³å®šã€‚å…¶å†…éƒ¨åªæ˜¯åˆ¤æ–­CCTä¸Šæ¬¡è¿åŠ¨ååº•éƒ¨æ˜¯å¦è§¦ç¢°ç‰©ä½“ã€‚å³collisionFlags \u0026amp; eCOLLISION_DOWN::eCOLLISION_DOWNã€‚ä½†åœ¨ä¸Šä¸‹å¡æˆ–å´å²–åœ°å½¢æ—¶ï¼Œå¾ˆå®¹æ˜“å‡ºç°ä¾§é¢è§¦ç¢°æˆ–çŸ­æš‚æµ®ç©ºã€‚å¦‚æœç”¨è¯¥æ¥å£é©±åŠ¨åŠ¨ç”»è¡¨ç°ç”šè‡³è·‘è·³é€»è¾‘ï¼Œæ•ˆæœå¾ˆå·®ã€‚éœ€è¦è‡ªè¡ŒåŸºäºSceneQueryå°è£…å‡ºæ›´åŠ ç¨³å®šçš„åˆ¤å®šç€åœ°çš„å‡½æ•°ã€‚ Unityæ²¡æœ‰æš´éœ²CCT.upVectorï¼Œè§’è‰²æ€»æ˜¯ç«–ç›´å‘ä¸Šçš„ã€‚è¦å®ç°åé‡åŠ›é‹åœ¨ä»»æ„æ–œé¢ä¸Šè¡Œèµ°æˆ–åƒé©¬é‡Œå¥¥é“¶æ²³é‚£æ ·åœ¨æ›²é¢ä¸Šè·‘è·³ç©¿æ¢­ï¼Œåªèƒ½æ”¾å¼ƒä½¿ç”¨CCTä½†ä¹Ÿæ”¾å¼ƒäº†å…¶åœ¨æ“ä½œæ‰‹æ„Ÿä¸Šçš„æ”¹å–„ã€‚å…¶å®æ‹¿åˆ°Unityçš„æºç åï¼Œåªç”¨äº†ååˆ†é’Ÿå°†åº•å±‚å­—æ®µæš´éœ²åˆ°C#å±‚å°±è§£å†³äº†è¯¥é—®é¢˜ã€‚ æ–°çš„è§’è‰²æ§åˆ¶å™¨éœ€è¦å¢åŠ çš„ç‰©ç†äº¤äº’ç‰¹æ€§æœ‰ï¼š\n","keywords":["Game Dev","PhysX","Unity"],"articleBody":" æœ¬æ–‡ä¹Ÿæ˜¯PhysXç‰©ç†å¼•æ“ç³»åˆ—çš„ç•ªå¤–ç¯‡ã€‚ä»‹ç»äº†ç¬”è€…åŸºäºCharacterController(CCT)è®¾è®¡çš„ä¸€ä¸ªæ–°çš„è§’è‰²æ§åˆ¶å™¨ï¼Œåœ¨ä¿®è¡¥Unity/PhysXçš„CCTçš„ç¼ºé™·å¤–ï¼Œè¿˜å¢æ·»äº†è‹¥å¹²å’Œç‰©ç†äº¤äº’ç›¸å…³çš„æœ‰è¶£ç‰¹æ€§ã€‚ä»£ç å·²ç»è¿‡å®é™…é¡¹ç›®éªŒè¯ï¼Œè¿™é‡Œä»…ä¿ç•™å’Œå…·ä½“ä¸šåŠ¡æ— å…³çš„éƒ¨åˆ†ã€‚\nèƒŒæ™¯å’Œéœ€æ±‚ å‰æ–‡ç»“å°¾å¤„æåˆ°ä¸€äº›PhysXè‡ªå¸¦çš„CCTï¼ˆUnityä¹Ÿæ˜¯åŸºäºæ­¤äºŒæ¬¡å°è£…å‡ºCharacterControllerç»„ä»¶ï¼‰åœ¨å®é™…æ¸¸æˆå¼€å‘ä¸­çš„ç¼ºç‚¹ï¼Œè¿™é‡Œå†æ¬¡æ€»ç»“ï¼š\nCCTä¸å‚ä¸ç¢°æ’ç³»ç»Ÿçš„æ£€æµ‹ã€‚ä»…å½“CCTè‡ªèº«ç§»åŠ¨æ—¶ä¼šåˆ¤æ–­æ˜¯å¦è¢«å…¶ä»–åˆšä½“æˆ–CCTé˜»æŒ¡ã€‚è¿™å°±é€ æˆä¸€ä¸ªBUGï¼šCCTè‡ªèº«é™æ­¢æ—¶ï¼Œå…¶ä»–è¿åŠ¨ç‰©ä½“ä¼šç©¿è¿‡CCTä¸”æ²¡æœ‰äº‹ä»¶è§¦å‘ã€‚å®˜æ–¹è®ºå›ä¸Šæœ‰è‹¦ä¸»æŒç»­8å¹´å‘Unityåé¦ˆè¿™ä¸ªé—®é¢˜ä½†æ— æ³•è§£å†³ï¼Œç›®å‰å·²çŸ¥çš„å”¯ä¸€ç»•è¿‡æ–¹å¼æ˜¯æ¯å¸§ç»™CCTé™„åŠ ä¸€ä¸ªå¾®å°çš„ä½ç§»ï¼ˆä¸‹æ–‡ä¸­çš„SlightMoveï¼‰ã€‚ Unityæä¾›çš„æ¥å£CharacterController.isGroundedæ•ˆæœå¾ˆä¸ç¨³å®šã€‚å…¶å†…éƒ¨åªæ˜¯åˆ¤æ–­CCTä¸Šæ¬¡è¿åŠ¨ååº•éƒ¨æ˜¯å¦è§¦ç¢°ç‰©ä½“ã€‚å³collisionFlags \u0026 eCOLLISION_DOWN::eCOLLISION_DOWNã€‚ä½†åœ¨ä¸Šä¸‹å¡æˆ–å´å²–åœ°å½¢æ—¶ï¼Œå¾ˆå®¹æ˜“å‡ºç°ä¾§é¢è§¦ç¢°æˆ–çŸ­æš‚æµ®ç©ºã€‚å¦‚æœç”¨è¯¥æ¥å£é©±åŠ¨åŠ¨ç”»è¡¨ç°ç”šè‡³è·‘è·³é€»è¾‘ï¼Œæ•ˆæœå¾ˆå·®ã€‚éœ€è¦è‡ªè¡ŒåŸºäºSceneQueryå°è£…å‡ºæ›´åŠ ç¨³å®šçš„åˆ¤å®šç€åœ°çš„å‡½æ•°ã€‚ Unityæ²¡æœ‰æš´éœ²CCT.upVectorï¼Œè§’è‰²æ€»æ˜¯ç«–ç›´å‘ä¸Šçš„ã€‚è¦å®ç°åé‡åŠ›é‹åœ¨ä»»æ„æ–œé¢ä¸Šè¡Œèµ°æˆ–åƒé©¬é‡Œå¥¥é“¶æ²³é‚£æ ·åœ¨æ›²é¢ä¸Šè·‘è·³ç©¿æ¢­ï¼Œåªèƒ½æ”¾å¼ƒä½¿ç”¨CCTä½†ä¹Ÿæ”¾å¼ƒäº†å…¶åœ¨æ“ä½œæ‰‹æ„Ÿä¸Šçš„æ”¹å–„ã€‚å…¶å®æ‹¿åˆ°Unityçš„æºç åï¼Œåªç”¨äº†ååˆ†é’Ÿå°†åº•å±‚å­—æ®µæš´éœ²åˆ°C#å±‚å°±è§£å†³äº†è¯¥é—®é¢˜ã€‚ æ–°çš„è§’è‰²æ§åˆ¶å™¨éœ€è¦å¢åŠ çš„ç‰©ç†äº¤äº’ç‰¹æ€§æœ‰ï¼š\nå—åŠ›ã€‚ æ—¢å¯ä»¥åƒä¼ ç»ŸCCTä¸€æ ·ç²¾å‡†æ“æ§è¿åŠ¨ï¼Œä¹Ÿå¯ä»¥åƒåˆšä½“ä¸€æ ·å¯¹å…¶æ–½åŠ›ã€‚ å…¶ä»–åˆšä½“å¯ä»¥å¯¹å…¶äº§ç”Ÿæ¨æŒ¤ã€æ’é£æ•ˆæœã€‚ è‡ªèº«é‡åŠ›å¯åœ¨é™¡å¡ä¸Šäº§ç”Ÿæ»‘è¡Œæ•ˆæœã€‚ æ–½åŠ›ã€‚è¿åŠ¨æ—¶å…·æœ‰æ¨åŠ›ï¼Œè‡ªèº«é‡åŠ›å¯ä»¥å¯¹å¤–åšåŠŸã€‚ é‡åŠ›æ–¹å‘ã€‚å¤§å°å’Œæ–¹å‘åŠ¨æ€å¯å˜ï¼Œæ–¹å‘å˜åŒ–æ—¶å¯è‡ªåŠ¨æ—‹è½¬CCTä»¥è°ƒæ•´å§¿æ€ã€‚ ç§»åŠ¨å¹³å°ã€‚CCTå¯é™„ç€åœ¨æ‰€æœ‰ç§»åŠ¨å¯¹è±¡ä¸Šè·Ÿéšè¿åŠ¨ï¼Œä¸å€ŸåŠ©çˆ¶å­ç»“æ„ã€‚ å¦å¤–CCTè¿˜æ”¯æŒäº†ä¸¤ç§ç½‘ç»œåŒæ­¥æ–¹å¼ï¼šæœåŠ¡ç«¯è·Ÿéšå®¢æˆ·ç«¯ï¼ˆé€šè¿‡æ ¡éªŒç»´æŒæœåŠ¡ç«¯æƒå¨æ€§ï¼‰ã€å®¢æˆ·ç«¯è·ŸéšæœåŠ¡ç«¯ï¼ˆé€šè¿‡å¤–æ’å‡å°å»¶è¿Ÿï¼‰ï¼Œå¹¶ä¸”å¯ä»¥åŠ¨æ€åˆ‡æ¢ã€‚è€ƒè™‘åˆ°ç¯‡å¹…ï¼Œæœ¬ç¯‡å¯¹åŒæ­¥ç®—æ³•ä¸å±•å¼€ä»‹ç»ã€‚\næŠ€æœ¯è·¯çº¿ è§’è‰²è¦å®ç°ä¸°å¯Œçš„ç‰©ç†äº¤äº’ï¼Œå¤§ä½“æœ‰ä¸‰ç§æ€è·¯ï¼š\nåŸºäºCCTï¼Œæ·»åŠ åŠ¨åŠ›å­¦æ¨¡æ‹Ÿï¼ˆæ–½åŠ›ã€å—åŠ›ï¼‰ã€‚è¿åŠ¨å—æ§åº¦æœ€é«˜ï¼Œä½†ç®—æ³•å¤æ‚ã€‚ åŸºäºKinematicåˆšä½“ï¼Œæ·»åŠ CCTç‰¹æ€§ï¼ˆCollide-and-Slideï¼‰ ã€æ·»åŠ åŠ¨åŠ›å­¦æ¨¡æ‹Ÿï¼ˆå—åŠ›è¿åŠ¨ï¼‰ã€‚è¿åŠ¨å—æ§åº¦é«˜ï¼Œä½†ç®—æ³•å¤æ‚ã€‚ åŸºäºDynamicåˆšä½“ï¼Œæ·»åŠ éƒ¨åˆ†CCTç‰¹æ€§ã€‚ä¾‹å¦‚Active RagdollæŠ€æœ¯ã€‚è¿åŠ¨å—æ§åº¦ä½ï¼Œä½†é€»è¾‘ç®€æ´ï¼Œä¸”ç‰¹åˆ«é€‚åˆç³–è±†äººè¿™ç±»ä¼‘é—²è ¢èŒè§’è‰²ã€‚ ç»“åˆç©æ³•ç±»å‹å’Œé¡¹ç›®å®é™…æƒ…å†µï¼Œä¸ºäº†æœ€å¤§åŒ–å¤ç”¨åŸæœ‰è§’è‰²åŠŸèƒ½ï¼Œæœ€ç»ˆé€‰æ‹©äº†ç¬¬ä¸€ç§æ€è·¯ã€‚\næ¡†æ¶è®¾è®¡ è¦æ¨¡æ‹Ÿå„ç±»ç‰©ç†äº¤äº’ï¼Œæœ‰ä¸‰ä¸ªé‡è¦è®¾è®¡ã€‚\næ‰€æœ‰äº¤äº’æœ€ç»ˆéƒ½è½¬åŒ–ä¸ºé€Ÿåº¦è¿™ä¸ªç‰©ç†é‡ã€‚æ¯å¸§é€šè¿‡èåˆåçš„æ€»é€Ÿåº¦äº§ç”Ÿä¸€æ¬¡cctmoveã€‚å…·ä½“äº¤äº’åŒ…æ‹¬æ‘‡æ†è¾“å…¥ã€APIè¾“å…¥ã€é‡åŠ›ã€æ‘©æ“¦ã€ç¢°æ’æ—¶çš„å†²é‡â€¦ äº¤äº’å¯¹è±¡ä¸é™äºåˆšä½“ï¼Œè€Œæ˜¯æ‰€æœ‰å®ç°äº†IPhysicalMoveræ¥å£çš„å¯¹è±¡ã€‚è¿™æ ·å°±å°†ä¸å‚ä¸åˆšä½“ä»¿çœŸçš„å¯¹è±¡ä¹Ÿç»Ÿä¸€èµ·æ¥ï¼ˆæ¯”å¦‚cctå’Œè¢«å¼ºåˆ¶ç§»åŠ¨çš„static colliderï¼‰ã€‚ å°†äº¤äº’æ•ˆæœçš„è®¡ç®—ï¼Œåˆ†ä¸ºå†…æ ¸ä¸æ¥å£ã€‚å†…æ ¸éƒ¨åˆ†PhysicalCCTå®ç°äº†ç‰©ç†äº¤äº’çš„æ ¸å¿ƒè®¡ç®—å’Œæµç¨‹ï¼Œä¸åŒä¸šåŠ¡çš„è§’è‰²ç±»åªéœ€å®ç°IPhysicalCharacteræ¥å£éƒ¨åˆ†å°±èƒ½å—å†…æ ¸é©±åŠ¨ï¼Œå¹¶å®šåˆ¶ç©æ³•ç›¸å…³çš„æ•ˆæœã€‚ ä¸‹é¢æ˜¯ä¸¤ä¸ªæ¥å£çš„å®šä¹‰ï¼š\n/// /// a actor who has mass, velocity, and can add force to. (e.g. moving platform) /// public interface IPhysicalMover { float GetMoverMass(); Vector3 GetMoverCenterOfRotation(); Vector3 GetMoverVelocity(); //m/s Vector3 GetMoverAngularVelocity(); //degree/s void AddForceAtPosition(Vector3 force, ForceMode mode, Vector3 hitPoint); } public interface IPhysicalCharacter { void BeforeCCTUpdate(); void AfterCCTUpdate(); /// /// Can be used to do Landing/Take off game logic based on CurrentGroundState and LastGroundState /// void AfterUpdateGroundState(); /// /// Update CCT rotation according to input and game logic (e.g., change Forward to moving dir, or rotate Up to align with gravity). /// BaseRotation means auto-generated rotation if walking on the surface of a rotating platform. /// Return modified Rotation. /// Quaternion UpdateRotation(Quaternion BaseRotation, float gameTime, float deltaTime); /// /// Update CCT velocity according to input (walk, run, jump...should have different speed) and game logic (e.g., if Dead, set velocity to zero). /// Do not add gravity inside. /// Return modified Velocity. /// Vector3 UpdateVelocity(Vector3 BaseVelocity, float gameTime, float deltaTime); void OnGroundHit(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint); // during GroundDetection void OnCollideWith(Collider hitCollider); } ä¸‹é¢æ˜¯æ¡†æ¶è°ƒç”¨æµç¨‹ã€‚\nsequenceDiagram participant Game participant Character participant PhysicalCCT Game-\u003e\u003eCharacter: FixedUpdate Note over Character: ... Character-\u003e\u003ePhysicalCCT: UpdatePhase1 PhysicalCCT-\u003e\u003eCharacter: BeforeCCTUpdate Note over Character: ... Note over PhysicalCCT: GroundDetection PhysicalCCT-\u003e\u003eCharacter: OnGroundHit PhysicalCCT-\u003e\u003eCharacter: AfterUpdateGroundState Note over PhysicalCCT: FixVelocityOnGround critical GetPointVelocityOnMover PhysicalCCT -\u003e\u003e Mover: GetMoverVelocity PhysicalCCT -\u003e\u003e Mover: GetMoverAngularVelocity PhysicalCCT -\u003e\u003e Mover: GetMoverCenterOfRotation end Note over PhysicalCCT: CCTMoveWithGround Game --\u003e Mover: All movers should have moved to final pos Character-\u003e\u003ePhysicalCCT: UpdatePhase2 PhysicalCCT-\u003e\u003eCharacter: UpdateRotation Note over Character: RotateWithCamera/... PhysicalCCT-\u003e\u003eCharacter: UpdateVelocity Note over Character: BlendWithInputVelocity/Jump/... Note over PhysicalCCT: ApplyGravity Note over PhysicalCCT: ApplyOtherExternalForce Note over PhysicalCCT: ClampFinalVelocity Note over PhysicalCCT: CCTMove Note over PhysicalCCT: ProcessControllerHits PhysicalCCT -\u003e\u003e PhysicalCCT: modify self Velocity PhysicalCCT -\u003e\u003e Mover: AddForceAtPosition PhysicalCCT -\u003e\u003e Character: OnCollideWith PhysicalCCT -\u003e\u003e Character: AfterCCTUpdate Note over Character: ... æ¡†æ¶ä»£ç ç¤ºæ„ï¼š\npublic void UpdatePhase1(float gameTime, float deltaTime) { m_Character.BeforeCCTUpdate(); ResetEveryFrame(deltaTime); GroundDetection(); // may modify PositionNew if force unground m_Character.AfterUpdateGroundState(); FixVelocityOnGround(deltaTime); // modify VelocityNew CCTMoveWithGround(deltaTime) // modify VelocityNew, RotationNew, PositionNew } public void UpdatePhase2(float gameTime, float deltaTime) { RotationNew = m_Character.UpdateRotation(RotationNew, gameTime, deltaTime); VelocityNew = m_Character.UpdateVelocity(VelocityNew, gameTime, deltaTime); // apply gravity if (UseGravity \u0026\u0026 !IsGrounded) { VelocityNew += GravityDirection * GravityScale * deltaTime; } // apply other external force if (AdditionalForceToApply.sqrMagnitude \u003e 0) { VelocityNew += AdditionalForceToApply; AdditionalForceToApply = Vector3.zero; } VelocityNew = ClampVelocity(VelocityNew); CurrentCollisionFlags = DoCCTMove(ref PositionNew, VelocityNew, deltaTime, true); // true means snap to ground ProcessControllerHits(); // may modify VelocityNew //... Velocity = VelocityNew; // for outside logic m_Character.AfterCCTUpdate(); #if UNITY_EDITOR RecordPreviousPositions(PositionNew); // for debug gizmos #endif } å…·ä½“åŠŸèƒ½å®ç° ä¸‹é¢åˆ—ä¸¾å‡ ä¸ªå…³é”®åŠŸèƒ½çš„å®ç°æ–¹å¼ã€‚\nç€åœ°çŠ¶æ€æ£€æµ‹GroundDetection é¦–å…ˆï¼ŒPhysicalCCTä¸­è®°å½•çš„å…³äºç€åœ°çŠ¶æ€çš„å­—æ®µæœ‰ï¼š\npublic class PhysicalCCT : MonoBehaviour { //... [Serializable] public struct GroundingState { public bool IsGrounded; // todo: we can decide if on a stable ground, or on an edge. public Vector3 GroundNormal; public Vector3 SnapToGroundDisplacement;// assigned when IsGrounded is true, and apply once in current frame's cctmove public IPhysicalMover Mover; // can be null public Vector3 MoverVelocityAtPosition; public Vector3 MoverAngularVelocityAtPosition; } public GroundingState CurrentGroundState; public GroundingState LastGroundState; public const float GroundDetectionBackDistance = 0.002f; // avoid raycast exactly from ground. must smaller than MinGroundDetectionDistance public float GroundDetectionDistance { get { var distance = 0.1f + GroundDetectionBackDistance + (LastGroundState.IsGrounded ? StepOffset : 0f); return distance; } } private RaycastHit[] m_GroundDetectionBuffer = new RaycastHit[8]; private bool m_ForceUnground = false; private int m_ForceUngroundReMainFrameCount = 0; public bool IsLanding { get { return !LastGroundState.IsGrounded \u0026\u0026 CurrentGroundState.IsGrounded; } } public bool IsSliding { get { return IsGroundTooSteep(CurrentGroundState); } } public bool IsGrounded { get { return CurrentGroundState.IsGrounded; } } private bool IsGroundTooSteep(GroundingState state) { if (state.IsGrounded) { float slopeAngle = Vector3.Angle(CharacterUp, state.GroundNormal); if (slopeAngle \u003e 90) { return false;// meaningless } return slopeAngle \u003e SlopeLimit; } return false; } } æµç¨‹å›¾ä¸­GroundDetectionå†…éƒ¨é€»è¾‘å¦‚ä¸‹ï¼š\nprivate void GroundDetection() { LastGroundState = CurrentGroundState; var newState = new GroundingState(); newState.IsGrounded = false; if (IsForcingUnGround) // e.g. request jump { m_ForceUngroundReMainFrameCount--; if (m_ForceUngroundReMainFrameCount \u003c= 0) { m_ForceUnground = false; PositionNew += CharacterUp * GroundDetectionBackDistance; // ensure next frame } } else { var groundLayerMask = PhysicsUtil.GetLayerMask(...); // use your own layer mask RaycastHit closestSweepHit; var startPos = PositionNew + CharacterUp * GroundDetectionBackDistance; //add a little offset to avoid raycast exactly from ground var DetectionDirection = -CharacterUp; // not GravityDirection, because \"OnGround\" means stand on feet var isHit = CCTSweep(startPos, DetectionDirection, GroundDetectionDistance, groundLayerMask, out closestSweepHit); if (isHit \u0026\u0026 closestSweepHit.collider != null \u0026\u0026 !closestSweepHit.collider.isTrigger) // do not include trigger { newState.IsGrounded = true; newState.SnapToGroundDisplacement = (closestSweepHit.distance - GroundDetectionBackDistance) * DetectionDirection; Vector3 hitPos; RaycastHit closestRaycastHit; var extraDistance = Mathf.Max(Radius, StepOffset); if (CCTRaycast(startPos, DetectionDirection, GroundDetectionDistance + extraDistance, groundLayerMask, out closestRaycastHit)) // more precise { newState.GroundNormal = closestRaycastHit.normal; newState.Mover = closestSweepHit.collider.gameObject.GetComponentInParent\u003cIPhysicalMover\u003e(); hitPos = closestRaycastHit.point; } else // fallback { newState.GroundNormal = closestSweepHit.normal; newState.Mover = closestSweepHit.collider.gameObject.GetComponentInParent\u003cIPhysicalMover\u003e(); hitPos = PositionNew; } if (newState.Mover != null) { var pressure = GravityDirection * GravityScale * Mass; newState.Mover.AddForceAtPosition(pressure, ForceMode.Force, hitPos); } } } CurrentGroundState = newState; } Vector3 m_sweep_point1 = Vector3.zero; Vector3 m_sweep_point2 = Vector3.zero; Vector3 m_sweep_direction = Vector3.zero; float m_sweep_distance = 0; float m_sweep_radius = 0; private bool CCTSweep(Vector3 position, Vector3 direction, float distance, int layermask, out RaycastHit closestHit) { closestHit = new RaycastHit(); if (distance \u003c= 0) { return false; } distance += SkinWidth; // must add skinwidth, since capsulecast m_sweep_point1 is hemi-sphere center, not capsule foot position var bias = Height * 0.5f - Radius; m_sweep_point1 = position + CharacterUp * (CenterOffset.y - bias); // foot hemi-sphere center m_sweep_point2 = position + CharacterUp * (CenterOffset.y + bias); // head hemi-sphere center m_sweep_distance = distance; m_sweep_radius = Radius; m_sweep_direction = direction.normalized; if (m_sweep_direction.sqrMagnitude \u003c= 0) { Debugger.Log(\"Invalid sweep direction:\" + direction.ToString(\"G3\")); return false; } int numberOfHits = Physics.CapsuleCastNonAlloc(m_sweep_point1, m_sweep_point2, m_sweep_radius, m_sweep_direction, m_GroundDetectionBuffer, m_sweep_distance, layermask); //find closest hit bool foundValidHit = false; float closestHitDistance = float.MaxValue; for (int i = 0; i \u003c numberOfHits; i++) { var hit = m_GroundDetectionBuffer[i]; if (hit.distance \u003e 0 \u0026\u0026 hit.distance \u003c closestHitDistance) { closestHitDistance = hit.distance; closestHit = hit; foundValidHit = true; } } return foundValidHit; } private bool CCTRaycast(Vector3 position, Vector3 direction, float distance, int layermask, out RaycastHit closestHit) { closestHit = new RaycastHit(); int numberOfHits = Physics.RaycastNonAlloc(position, direction, m_GroundDetectionBuffer, distance, layermask); //find closest hit bool foundValidHit = false; float closestHitDistance = float.MaxValue; for (int i = 0; i \u003c numberOfHits; i++) { var hit = m_GroundDetectionBuffer[i]; if (hit.distance \u003e 0 \u0026\u0026 hit.distance \u003c closestHitDistance) { closestHitDistance = hit.distance; closestHit = hit; foundValidHit = true; } } return foundValidHit; } è½åœ°é€Ÿåº¦ä¿®æ­£FixVelocityOnGround è¿™ä¸€æ­¥çš„ç›®çš„æ˜¯é˜²æ­¢è½åœ°åå¼¹è·³ç­‰ä¸è‡ªç„¶è¡¨ç°ï¼Œä»¥åŠå‘ä¸Šå†²é™¡å¡æ—¶çš„é™åˆ¶ã€‚\nprivate void FixVelocityOnGround(float deltaTime) { if (!IsGrounded) { return; } Vector3 tempVelocity = VelocityNew; if (IsLanding) { tempVelocity = ProjectVectorToPlane(tempVelocity, CharacterUp); // no jump up Vector3 vRight = Vector3.Cross(tempVelocity, CharacterUp); Vector3 tangentDir = Vector3.Cross(CurrentGroundState.GroundNormal, vRight).normalized; tempVelocity = tangentDir * tempVelocity.magnitude; // reorient velocity along ground tangent } if (IsSliding) { Vector3 slidingAcceleration = ProjectVectorToPlane(GravityDirection * GravityScale, CurrentGroundState.GroundNormal); tempVelocity = ProjectVectorToPlane(tempVelocity, CurrentGroundState.GroundNormal); if (ForbidUphillMovementWhenSliding) { var slidingProjection = Vector3.Dot(tempVelocity, slidingAcceleration.normalized); if (slidingProjection \u003c 0) // has uphill velocity { // discard uphill velocity tempVelocity -= slidingProjection * slidingAcceleration.normalized; } } tempVelocity += slidingAcceleration * deltaTime; } VelocityNew = tempVelocity; } /// /// Discard velocity that is perpendicular to the hit normal from v /// private Vector3 ProjectVectorToPlane(Vector3 v, Vector3 planeNormal) { return v - Vector3.Dot(v, planeNormal) * planeNormal; } ç§»åŠ¨å¹³å°è·ŸéšCCTMoveWithGround æ­¤æ—¶å·²ç»è·å¾—äº†ç€åœ°çŠ¶æ€ï¼Œå¦‚æœè„šä¸‹æ˜¯ç§»åŠ¨å¹³å°ï¼Œéœ€è¦å¤„ç†è·Ÿéšè¿åŠ¨ã€ä»¥åŠè·³è¿›è·³å‡ºæ—¶çš„æƒ¯æ€§ã€‚\n{ Vector3 MoverVelocity = Vector3.zero; Vector3 MoverAngularVelocity = Vector3.zero; GetPointVelocityFromPhysicalMover(CurrentGroundState.Mover, PositionNew, deltaTime, out MoverVelocity, out MoverAngularVelocity); CurrentGroundState.MoverVelocityAtPosition = MoverVelocity; CurrentGroundState.MoverAngularVelocityAtPosition = MoverAngularVelocity; // jump between different moving grounds if (LastGroundState.Mover != null \u0026\u0026 CurrentGroundState.Mover != LastGroundState.Mover) { VelocityNew += LastGroundState.MoverVelocityAtPosition; VelocityNew -= CurrentGroundState.MoverVelocityAtPosition; } // do not bump when landing if (LastGroundState.Mover == null \u0026\u0026 CurrentGroundState.Mover != null) { VelocityNew -= ProjectVectorToPlane(CurrentGroundState.MoverVelocityAtPosition, CharacterUp); } // rotate with mover if (CurrentGroundState.MoverAngularVelocityAtPosition.sqrMagnitude \u003e 0) { Vector3 newForward = Quaternion.Euler(CurrentGroundState.MoverAngularVelocityAtPosition * deltaTime) * CharacterForward; newForward = ProjectVectorToPlane(newForward, CharacterUp).normalized; RotationNew = Quaternion.LookRotation(newForward, CharacterUp); } // translate with mover if (CurrentGroundState.MoverVelocityAtPosition.sqrMagnitude \u003e 0) { DoCCTMove(ref PositionNew, CurrentGroundState.MoverVelocityAtPosition, deltaTime, false); } } // Turn on SlightMove when user is not moving, this is to detect collision private CollisionFlags DoCCTMove(ref Vector3 position, Vector3 velocity, float deltaTime, bool extraSnapToGround) { float noiseMovemet = 0.001f * deltaTime; Vector3 movement = SlightMove ? noiseMovemet * CharacterForward : Vector3.zero; if (velocity.sqrMagnitude \u003e 0) { movement = velocity * deltaTime; } // Snap to ground: add displacement to keep character attached when going downhill if (extraSnapToGround \u0026\u0026 CurrentGroundState.IsGrounded \u0026\u0026 CurrentGroundState.SnapToGroundDisplacement.sqrMagnitude \u003e 0) { movement += CurrentGroundState.SnapToGroundDisplacement; } var flags = m_CCT.Move(movement); position = m_CCT.transform.position; return flags; } ä¸è¾“å…¥é€Ÿåº¦æ··åˆBlendWithInputVelocity è¿™ä¸€æ­¥æ˜¯åœ¨å®ç°æ¥å£å‡½æ•°UpdateVelocityæ—¶ï¼Œå°†ä¼ å…¥çš„BaseVelocityå’Œè¯»å–åˆ°çš„ç©å®¶è¾“å…¥è¿›è¡Œæ··åˆï¼ŒåŒ…æ‹¬å¤„ç†è·³è·ƒã€ç©ºä¸­ç§»åŠ¨ç­‰ã€‚\nVector3 IPhysicalCharacter.UpdateVelocity(Vector3 BaseVelocity, float gameTime, float deltaTime) { Vector3 originalV = BaseVelocity; // handle jump separately if (RequestJump) { RequestJump = false; if (PhysicalCCT.JumpCount \u003c PhysicalCCT.JumpMaxCount) { float jumpupSpeed = Mathf.Sqrt(PhysicalCCT.JumpHeight * 2 * PhysicalCCT.GravityScale); if (PhysicalCCT.CurrentGroundState.IsGrounded) { PhysicalCCT.JumpCount = 1; BaseVelocity += jumpupSpeed * PhysicalCCT.CharacterUp; PhysicalCCT.ForceUnground(); } else { // when second jump, it reset BaseVelocity along CharacterUp direction, rather than add to BaseVelocity var cutVelocity = Vector3.Dot(BaseVelocity, PhysicalCCT.CharacterUp) * PhysicalCCT.CharacterUp; var restVelocity = BaseVelocity - cutVelocity; BaseVelocity = restVelocity + jumpupSpeed * PhysicalCCT.CharacterUp; PhysicalCCT.JumpCount++; } } } else { Vector3 InputVelocity = Vector3.zero; if (PhysicalCCT.CurrentGroundState.IsGrounded) // standing, walking, running { PhysicalCCT.JumpCount = 0; // reset jump count InputVelocity = MovingDirection * MoveSpeed; // rotate InputVelocity onto ground plane, only if IsSliding false Vector3 groundNormal = PhysicalCCT.CurrentGroundState.GroundNormal; if (InputVelocity.sqrMagnitude \u003e 0 \u0026\u0026 groundNormal.sqrMagnitude \u003e 0) { InputVelocity = PhysicalCCT.ReorientVelocityToPlane(InputVelocity, PhysicalCCT.CharacterUp, groundNormal); } // assign BaseVelocity with InputVelocity if (PhysicalCCT.IsSliding) { // usually we don't want to lose control immediately, but gradually BaseVelocity += Vector3.Lerp(InputVelocity, Vector3.zero, 1f - Mathf.Exp(-PhysicalCCT.LoseControlMoveSensibility * deltaTime)); } else { // we want to move as desired velocity (InputVelocity) quickly, but not immediately BaseVelocity = Vector3.Lerp(BaseVelocity, InputVelocity, 1f - Mathf.Exp(-PhysicalCCT.ControlMoveSensibility * deltaTime)); } } else // falling { if (PhysicalCCT.CanMoveInAir) { // when dashing, moving dir is 0,0,0 var dir = MovingDirection; dir.y = 0; var horizontalBaseVelocity = dir.normalized * MoveSpeed; // when in air, don't change horizontal velocity if no input if (horizontalBaseVelocity.sqrMagnitude \u003e 0) { BaseVelocity.x = horizontalBaseVelocity.x; BaseVelocity.z = horizontalBaseVelocity.z; } } } } return BaseVelocity; } å—åŠ›è¿åŠ¨ApplyOtherEnternalForce Addforceæ”¯æŒå¤šç§æ–½åŠ›æ¨¡å¼ï¼Œå’Œåˆšä½“ç±»ä¼¼ã€‚è½¬åŒ–ä¸ºé€Ÿåº¦åï¼Œæœ€ååœ¨ApplyOtherEnternalForceä¸­ç›´æ¥å åŠ åˆ°VelocityNewã€‚\npublic void AddExternalForce(Vector3 force, ForceMode mode = ForceMode.Force) { switch (mode) { case ForceMode.Force: AdditionalForceToApply += force * DeltaTime / Mass; break; case ForceMode.Acceleration: AdditionalForceToApply += force * DeltaTime; break; case ForceMode.Impulse: AdditionalForceToApply += force / Mass; break; case ForceMode.VelocityChange: AdditionalForceToApply += force; break; default: break; } } å¤„ç†ç‰©ç†ç¢°æ’æ•ˆæœProcessControllerHits è¢«æ¨æŒ¤è¿˜æ˜¯è¢«æ’é£æœ‰ä¸€ä¸ªåˆ¤å®šé˜ˆå€¼ã€‚SolveCCTCollideWithMovableObjectå†…éƒ¨ï¼Œä¼šæ ¹æ®äºŒè€…ç›¸ç¢°æ—¶ç¢°æ’æ–¹å‘ä¸Šçš„é€Ÿåº¦å·®ï¼Œä»¥åŠäºŒè€…çš„è´¨é‡å·®ï¼Œå†³å®šæ˜¯å¼¹æ€§æˆ–æ˜¯éå¼¹æ€§ç¢°æ’ã€‚\n/// /// This is called just after CCTMove /// private void OnControllerColliderHit(ControllerColliderHit hit) { var mover = hit.gameObject.GetComponentInParent\u003cIPhysicalMover\u003e(); if (mover != null) { ControllerHitInfo projectionHit = new ControllerHitInfo(); projectionHit.HitNormal = hit.normal; projectionHit.HitPoint = hit.point; projectionHit.Mover = mover; projectionHit.CCTHitVelocity = Velocity; m_ControllerHits.Add(projectionHit); } } private void ProcessControllerHits() { for (int i = 0; i \u003c m_ControllerHits.Count; i++) { var hitInfo = m_ControllerHits[i]; if(!hitInfo.IsValid() || m_HittedMovers.Contains(hitInfo.Mover)) { continue; } m_HittedMovers.Add(hitInfo.Mover); // todo: what if Mover is other CCT/PhysicalMover float moverMass = hitInfo.Mover.GetMoverMass(); float cctMass = this.Mass; Vector3 cctVelocityDeltaAfterCollision, moverVelocityDeltaAfterCollision; bool isBounce = PhysicalContactSolver.SolveCCTCollideWithMovableObject(this, hitInfo.HitNormal, hitInfo.CCTHitVelocity, hitInfo.MoverHitVelocity, cctMass, moverMass, out cctVelocityDeltaAfterCollision, out moverVelocityDeltaAfterCollision); if (!isBounce \u0026\u0026 UseCustomPushForce) { hitInfo.Mover.AddForceAtPosition(hitInfo.HitNormal * (-CustomPushForce), ForceMode.Force, hitInfo.HitPoint); } else { VelocityNew += cctVelocityDeltaAfterCollision; hitInfo.Mover.AddForceAtPosition(moverVelocityDeltaAfterCollision, ForceMode.VelocityChange, hitInfo.HitPoint); } } } ","wordCount":"3850","inLanguage":"en","datePublished":"2024-03-18T00:00:00Z","dateModified":"2024-03-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/notes_on_physics_based_cct/"},"publisher":{"@type":"Organization","name":"æ³¢æ³¢æ²™ğŸ ","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io/ accesskey=h title="æ³¢æ³¢æ²™ğŸ  (Alt + H)">æ³¢æ³¢æ²™ğŸ </a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°</h1><div class=post-meta><span title='2024-03-18 00:00:00 +0000 UTC'>March 18, 2024</span>&nbsp;Â·&nbsp;8 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af%e5%92%8c%e9%9c%80%e6%b1%82 aria-label=èƒŒæ™¯å’Œéœ€æ±‚>èƒŒæ™¯å’Œéœ€æ±‚</a></li><li><a href=#%e6%8a%80%e6%9c%af%e8%b7%af%e7%ba%bf aria-label=æŠ€æœ¯è·¯çº¿>æŠ€æœ¯è·¯çº¿</a></li><li><a href=#%e6%a1%86%e6%9e%b6%e8%ae%be%e8%ae%a1 aria-label=æ¡†æ¶è®¾è®¡>æ¡†æ¶è®¾è®¡</a></li><li><a href=#%e5%85%b7%e4%bd%93%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0 aria-label=å…·ä½“åŠŸèƒ½å®ç°>å…·ä½“åŠŸèƒ½å®ç°</a><ul><li><a href=#%e7%9d%80%e5%9c%b0%e7%8a%b6%e6%80%81%e6%a3%80%e6%b5%8bgrounddetection aria-label=ç€åœ°çŠ¶æ€æ£€æµ‹GroundDetection>ç€åœ°çŠ¶æ€æ£€æµ‹GroundDetection</a></li><li><a href=#%e8%90%bd%e5%9c%b0%e9%80%9f%e5%ba%a6%e4%bf%ae%e6%ad%a3fixvelocityonground aria-label=è½åœ°é€Ÿåº¦ä¿®æ­£FixVelocityOnGround>è½åœ°é€Ÿåº¦ä¿®æ­£FixVelocityOnGround</a></li><li><a href=#%e7%a7%bb%e5%8a%a8%e5%b9%b3%e5%8f%b0%e8%b7%9f%e9%9a%8fcctmovewithground aria-label=ç§»åŠ¨å¹³å°è·ŸéšCCTMoveWithGround>ç§»åŠ¨å¹³å°è·ŸéšCCTMoveWithGround</a></li><li><a href=#%e4%b8%8e%e8%be%93%e5%85%a5%e9%80%9f%e5%ba%a6%e6%b7%b7%e5%90%88blendwithinputvelocity aria-label=ä¸è¾“å…¥é€Ÿåº¦æ··åˆBlendWithInputVelocity>ä¸è¾“å…¥é€Ÿåº¦æ··åˆBlendWithInputVelocity</a></li><li><a href=#%e5%8f%97%e5%8a%9b%e8%bf%90%e5%8a%a8applyotherenternalforce aria-label=å—åŠ›è¿åŠ¨ApplyOtherEnternalForce>å—åŠ›è¿åŠ¨ApplyOtherEnternalForce</a></li><li><a href=#%e5%a4%84%e7%90%86%e7%89%a9%e7%90%86%e7%a2%b0%e6%92%9e%e6%95%88%e6%9e%9cprocesscontrollerhits aria-label=å¤„ç†ç‰©ç†ç¢°æ’æ•ˆæœProcessControllerHits>å¤„ç†ç‰©ç†ç¢°æ’æ•ˆæœProcessControllerHits</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>æœ¬æ–‡ä¹Ÿæ˜¯<a href=https://pps43.github.io/tags/physx/>PhysXç‰©ç†å¼•æ“ç³»åˆ—</a>çš„ç•ªå¤–ç¯‡ã€‚ä»‹ç»äº†ç¬”è€…åŸºäºCharacterController(CCT)è®¾è®¡çš„ä¸€ä¸ªæ–°çš„è§’è‰²æ§åˆ¶å™¨ï¼Œåœ¨ä¿®è¡¥Unity/PhysXçš„CCTçš„ç¼ºé™·å¤–ï¼Œè¿˜å¢æ·»äº†è‹¥å¹²å’Œç‰©ç†äº¤äº’ç›¸å…³çš„æœ‰è¶£ç‰¹æ€§ã€‚ä»£ç å·²ç»è¿‡å®é™…é¡¹ç›®éªŒè¯ï¼Œè¿™é‡Œä»…ä¿ç•™å’Œå…·ä½“ä¸šåŠ¡æ— å…³çš„éƒ¨åˆ†ã€‚</p></blockquote><h1 id=èƒŒæ™¯å’Œéœ€æ±‚>èƒŒæ™¯å’Œéœ€æ±‚<a hidden class=anchor aria-hidden=true href=#èƒŒæ™¯å’Œéœ€æ±‚>#</a></h1><p><a href=https://pps43.github.io/posts/using_physx_cct/>å‰æ–‡</a>ç»“å°¾å¤„æåˆ°ä¸€äº›PhysXè‡ªå¸¦çš„CCTï¼ˆUnityä¹Ÿæ˜¯åŸºäºæ­¤äºŒæ¬¡å°è£…å‡º<code>CharacterController</code>ç»„ä»¶ï¼‰åœ¨å®é™…æ¸¸æˆå¼€å‘ä¸­çš„ç¼ºç‚¹ï¼Œè¿™é‡Œå†æ¬¡æ€»ç»“ï¼š</p><ul><li><strong>CCTä¸å‚ä¸ç¢°æ’ç³»ç»Ÿçš„æ£€æµ‹</strong>ã€‚ä»…å½“CCTè‡ªèº«ç§»åŠ¨æ—¶ä¼šåˆ¤æ–­æ˜¯å¦è¢«å…¶ä»–åˆšä½“æˆ–CCTé˜»æŒ¡ã€‚è¿™å°±é€ æˆä¸€ä¸ªBUGï¼šCCTè‡ªèº«é™æ­¢æ—¶ï¼Œå…¶ä»–è¿åŠ¨ç‰©ä½“ä¼šç©¿è¿‡CCTä¸”æ²¡æœ‰äº‹ä»¶è§¦å‘ã€‚<a href=https://discussions.unity.com/t/proper-collision-detection-with-charactercontroller/564371>å®˜æ–¹è®ºå›ä¸Šæœ‰è‹¦ä¸»</a>æŒç»­8å¹´å‘Unityåé¦ˆè¿™ä¸ªé—®é¢˜ä½†æ— æ³•è§£å†³ï¼Œç›®å‰å·²çŸ¥çš„å”¯ä¸€ç»•è¿‡æ–¹å¼æ˜¯æ¯å¸§ç»™CCTé™„åŠ ä¸€ä¸ªå¾®å°çš„ä½ç§»ï¼ˆä¸‹æ–‡ä¸­çš„<code>SlightMove</code>ï¼‰ã€‚</li><li><strong>Unityæä¾›çš„æ¥å£<code>CharacterController.isGrounded</code>æ•ˆæœå¾ˆä¸ç¨³å®š</strong>ã€‚å…¶å†…éƒ¨åªæ˜¯åˆ¤æ–­CCTä¸Šæ¬¡è¿åŠ¨ååº•éƒ¨æ˜¯å¦è§¦ç¢°ç‰©ä½“ã€‚å³<code>collisionFlags & eCOLLISION_DOWN::eCOLLISION_DOWN</code>ã€‚ä½†åœ¨ä¸Šä¸‹å¡æˆ–å´å²–åœ°å½¢æ—¶ï¼Œå¾ˆå®¹æ˜“å‡ºç°ä¾§é¢è§¦ç¢°æˆ–çŸ­æš‚æµ®ç©ºã€‚å¦‚æœç”¨è¯¥æ¥å£é©±åŠ¨åŠ¨ç”»è¡¨ç°ç”šè‡³è·‘è·³é€»è¾‘ï¼Œæ•ˆæœå¾ˆå·®ã€‚éœ€è¦è‡ªè¡ŒåŸºäºSceneQueryå°è£…å‡ºæ›´åŠ ç¨³å®šçš„åˆ¤å®šç€åœ°çš„å‡½æ•°ã€‚</li><li><strong>Unityæ²¡æœ‰æš´éœ²<code>CCT.upVector</code>ï¼Œè§’è‰²æ€»æ˜¯ç«–ç›´å‘ä¸Šçš„</strong>ã€‚è¦å®ç°åé‡åŠ›é‹åœ¨ä»»æ„æ–œé¢ä¸Šè¡Œèµ°æˆ–åƒ<code>é©¬é‡Œå¥¥é“¶æ²³</code>é‚£æ ·åœ¨æ›²é¢ä¸Šè·‘è·³ç©¿æ¢­ï¼Œåªèƒ½æ”¾å¼ƒä½¿ç”¨CCTä½†ä¹Ÿæ”¾å¼ƒäº†å…¶åœ¨æ“ä½œæ‰‹æ„Ÿä¸Šçš„æ”¹å–„ã€‚å…¶å®æ‹¿åˆ°Unityçš„æºç åï¼Œåªç”¨äº†ååˆ†é’Ÿå°†åº•å±‚å­—æ®µæš´éœ²åˆ°C#å±‚å°±è§£å†³äº†è¯¥é—®é¢˜ã€‚</li></ul><p>æ–°çš„è§’è‰²æ§åˆ¶å™¨éœ€è¦å¢åŠ çš„ç‰©ç†äº¤äº’ç‰¹æ€§æœ‰ï¼š</p><ul><li>å—åŠ›ã€‚<ul><li>æ—¢å¯ä»¥åƒä¼ ç»ŸCCTä¸€æ ·ç²¾å‡†æ“æ§è¿åŠ¨ï¼Œä¹Ÿå¯ä»¥åƒåˆšä½“ä¸€æ ·å¯¹å…¶æ–½åŠ›ã€‚</li><li>å…¶ä»–åˆšä½“å¯ä»¥å¯¹å…¶äº§ç”Ÿæ¨æŒ¤ã€æ’é£æ•ˆæœã€‚</li><li>è‡ªèº«é‡åŠ›å¯åœ¨é™¡å¡ä¸Šäº§ç”Ÿæ»‘è¡Œæ•ˆæœã€‚</li></ul></li><li>æ–½åŠ›ã€‚è¿åŠ¨æ—¶å…·æœ‰æ¨åŠ›ï¼Œè‡ªèº«é‡åŠ›å¯ä»¥å¯¹å¤–åšåŠŸã€‚</li><li>é‡åŠ›æ–¹å‘ã€‚å¤§å°å’Œæ–¹å‘åŠ¨æ€å¯å˜ï¼Œæ–¹å‘å˜åŒ–æ—¶å¯è‡ªåŠ¨æ—‹è½¬CCTä»¥è°ƒæ•´å§¿æ€ã€‚</li><li>ç§»åŠ¨å¹³å°ã€‚CCTå¯é™„ç€åœ¨æ‰€æœ‰ç§»åŠ¨å¯¹è±¡ä¸Šè·Ÿéšè¿åŠ¨ï¼Œä¸å€ŸåŠ©çˆ¶å­ç»“æ„ã€‚</li></ul><p>å¦å¤–CCTè¿˜æ”¯æŒäº†ä¸¤ç§ç½‘ç»œåŒæ­¥æ–¹å¼ï¼šæœåŠ¡ç«¯è·Ÿéšå®¢æˆ·ç«¯ï¼ˆé€šè¿‡æ ¡éªŒç»´æŒæœåŠ¡ç«¯æƒå¨æ€§ï¼‰ã€å®¢æˆ·ç«¯è·ŸéšæœåŠ¡ç«¯ï¼ˆé€šè¿‡å¤–æ’å‡å°å»¶è¿Ÿï¼‰ï¼Œå¹¶ä¸”å¯ä»¥åŠ¨æ€åˆ‡æ¢ã€‚è€ƒè™‘åˆ°ç¯‡å¹…ï¼Œ<strong>æœ¬ç¯‡å¯¹åŒæ­¥ç®—æ³•ä¸å±•å¼€ä»‹ç»</strong>ã€‚</p><h1 id=æŠ€æœ¯è·¯çº¿>æŠ€æœ¯è·¯çº¿<a hidden class=anchor aria-hidden=true href=#æŠ€æœ¯è·¯çº¿>#</a></h1><p>è§’è‰²è¦å®ç°ä¸°å¯Œçš„ç‰©ç†äº¤äº’ï¼Œå¤§ä½“æœ‰ä¸‰ç§æ€è·¯ï¼š</p><ol><li>åŸºäºCCTï¼Œæ·»åŠ åŠ¨åŠ›å­¦æ¨¡æ‹Ÿï¼ˆæ–½åŠ›ã€å—åŠ›ï¼‰ã€‚è¿åŠ¨å—æ§åº¦æœ€é«˜ï¼Œä½†ç®—æ³•å¤æ‚ã€‚</li><li>åŸºäºKinematicåˆšä½“ï¼Œæ·»åŠ CCTç‰¹æ€§ï¼ˆ<code>Collide-and-Slide</code>ï¼‰ ã€æ·»åŠ åŠ¨åŠ›å­¦æ¨¡æ‹Ÿï¼ˆå—åŠ›è¿åŠ¨ï¼‰ã€‚è¿åŠ¨å—æ§åº¦é«˜ï¼Œä½†ç®—æ³•å¤æ‚ã€‚</li><li>åŸºäºDynamicåˆšä½“ï¼Œæ·»åŠ éƒ¨åˆ†CCTç‰¹æ€§ã€‚ä¾‹å¦‚<code>Active Ragdoll</code>æŠ€æœ¯ã€‚è¿åŠ¨å—æ§åº¦ä½ï¼Œä½†é€»è¾‘ç®€æ´ï¼Œä¸”ç‰¹åˆ«é€‚åˆç³–è±†äººè¿™ç±»ä¼‘é—²è ¢èŒè§’è‰²ã€‚</li></ol><p>ç»“åˆç©æ³•ç±»å‹å’Œé¡¹ç›®å®é™…æƒ…å†µï¼Œä¸ºäº†æœ€å¤§åŒ–å¤ç”¨åŸæœ‰è§’è‰²åŠŸèƒ½ï¼Œæœ€ç»ˆé€‰æ‹©äº†ç¬¬ä¸€ç§æ€è·¯ã€‚</p><h1 id=æ¡†æ¶è®¾è®¡>æ¡†æ¶è®¾è®¡<a hidden class=anchor aria-hidden=true href=#æ¡†æ¶è®¾è®¡>#</a></h1><p>è¦æ¨¡æ‹Ÿå„ç±»ç‰©ç†äº¤äº’ï¼Œæœ‰ä¸‰ä¸ªé‡è¦è®¾è®¡ã€‚</p><ol><li><strong>æ‰€æœ‰äº¤äº’æœ€ç»ˆéƒ½è½¬åŒ–ä¸ºé€Ÿåº¦è¿™ä¸ªç‰©ç†é‡</strong>ã€‚æ¯å¸§é€šè¿‡èåˆåçš„æ€»é€Ÿåº¦äº§ç”Ÿä¸€æ¬¡cctmoveã€‚å…·ä½“äº¤äº’åŒ…æ‹¬æ‘‡æ†è¾“å…¥ã€APIè¾“å…¥ã€é‡åŠ›ã€æ‘©æ“¦ã€ç¢°æ’æ—¶çš„å†²é‡&mldr;</li><li><strong>äº¤äº’å¯¹è±¡ä¸é™äºåˆšä½“ï¼Œè€Œæ˜¯æ‰€æœ‰å®ç°äº†<code>IPhysicalMover</code>æ¥å£çš„å¯¹è±¡</strong>ã€‚è¿™æ ·å°±å°†ä¸å‚ä¸åˆšä½“ä»¿çœŸçš„å¯¹è±¡ä¹Ÿç»Ÿä¸€èµ·æ¥ï¼ˆæ¯”å¦‚cctå’Œè¢«å¼ºåˆ¶ç§»åŠ¨çš„static colliderï¼‰ã€‚</li><li><strong>å°†äº¤äº’æ•ˆæœçš„è®¡ç®—ï¼Œåˆ†ä¸ºå†…æ ¸ä¸æ¥å£</strong>ã€‚å†…æ ¸éƒ¨åˆ†<code>PhysicalCCT</code>å®ç°äº†ç‰©ç†äº¤äº’çš„æ ¸å¿ƒè®¡ç®—å’Œæµç¨‹ï¼Œä¸åŒä¸šåŠ¡çš„è§’è‰²ç±»åªéœ€å®ç°<code>IPhysicalCharacter</code>æ¥å£éƒ¨åˆ†å°±èƒ½å—å†…æ ¸é©±åŠ¨ï¼Œå¹¶å®šåˆ¶ç©æ³•ç›¸å…³çš„æ•ˆæœã€‚</li></ol><p>ä¸‹é¢æ˜¯ä¸¤ä¸ªæ¥å£çš„å®šä¹‰ï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// a actor who has mass, velocity, and can add force to. (e.g. moving platform)</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>interface</span> <span class=nc>IPhysicalMover</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>GetMoverMass</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>GetMoverCenterOfRotation</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>GetMoverVelocity</span><span class=p>();</span> <span class=c1>//m/s</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>GetMoverAngularVelocity</span><span class=p>();</span> <span class=c1>//degree/s</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>force</span><span class=p>,</span> <span class=n>ForceMode</span> <span class=n>mode</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>hitPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>interface</span> <span class=nc>IPhysicalCharacter</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>BeforeCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>AfterCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Can be used to do Landing/Take off game logic based on CurrentGroundState and LastGroundState</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>AfterUpdateGroundState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Update CCT rotation according to input and game logic (e.g., change Forward to moving dir, or rotate Up to align with gravity). </span>
</span></span><span class=line><span class=cl>    <span class=cs>/// BaseRotation means auto-generated rotation if walking on the surface of a rotating platform.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Return modified Rotation.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Quaternion</span> <span class=n>UpdateRotation</span><span class=p>(</span><span class=n>Quaternion</span> <span class=n>BaseRotation</span><span class=p>,</span> <span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Update CCT velocity according to input (walk, run, jump...should have different speed) and game logic (e.g., if Dead, set velocity to zero).</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Do not add gravity inside.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Return modified Velocity.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>UpdateVelocity</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>BaseVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>OnGroundHit</span><span class=p>(</span><span class=n>Collider</span> <span class=n>hitCollider</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>hitNormal</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>hitPoint</span><span class=p>);</span> <span class=c1>// during GroundDetection</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>OnCollideWith</span><span class=p>(</span><span class=n>Collider</span> <span class=n>hitCollider</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>ä¸‹é¢æ˜¯æ¡†æ¶è°ƒç”¨æµç¨‹ã€‚</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant Game
    participant Character
    participant PhysicalCCT
    Game-&gt;&gt;Character: FixedUpdate
    Note over Character: ...
    Character-&gt;&gt;PhysicalCCT: UpdatePhase1
    PhysicalCCT-&gt;&gt;Character: BeforeCCTUpdate
    Note over Character: ...
    Note over PhysicalCCT: GroundDetection
    PhysicalCCT-&gt;&gt;Character: OnGroundHit
    PhysicalCCT-&gt;&gt;Character: AfterUpdateGroundState
    Note over PhysicalCCT: FixVelocityOnGround
    critical GetPointVelocityOnMover
    PhysicalCCT -&gt;&gt; Mover: GetMoverVelocity
    PhysicalCCT -&gt;&gt; Mover: GetMoverAngularVelocity
    PhysicalCCT -&gt;&gt; Mover: GetMoverCenterOfRotation
    end
    Note over PhysicalCCT: CCTMoveWithGround
    Game --&gt; Mover: All movers should have moved to final pos
    Character-&gt;&gt;PhysicalCCT: UpdatePhase2
    PhysicalCCT-&gt;&gt;Character: UpdateRotation
    Note over Character: RotateWithCamera/...
    PhysicalCCT-&gt;&gt;Character: UpdateVelocity
    Note over Character: BlendWithInputVelocity/Jump/...
    Note over PhysicalCCT: ApplyGravity
    Note over PhysicalCCT: ApplyOtherExternalForce
    Note over PhysicalCCT: ClampFinalVelocity
    Note over PhysicalCCT: CCTMove
    Note over PhysicalCCT: ProcessControllerHits
    PhysicalCCT -&gt;&gt; PhysicalCCT: modify self Velocity
    PhysicalCCT -&gt;&gt; Mover: AddForceAtPosition
    PhysicalCCT -&gt;&gt; Character: OnCollideWith
    PhysicalCCT -&gt;&gt; Character: AfterCCTUpdate
    Note over Character: ...
    
</code></pre><p>æ¡†æ¶ä»£ç ç¤ºæ„ï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>UpdatePhase1</span><span class=p>(</span><span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m_Character</span><span class=p>.</span><span class=n>BeforeCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ResetEveryFrame</span><span class=p>(</span><span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>GroundDetection</span><span class=p>();</span> <span class=c1>// may modify PositionNew if force unground</span>
</span></span><span class=line><span class=cl>    <span class=n>m_Character</span><span class=p>.</span><span class=n>AfterUpdateGroundState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>FixVelocityOnGround</span><span class=p>(</span><span class=n>deltaTime</span><span class=p>);</span> <span class=c1>// modify VelocityNew</span>
</span></span><span class=line><span class=cl>    <span class=n>CCTMoveWithGround</span><span class=p>(</span><span class=n>deltaTime</span><span class=p>)</span> <span class=c1>// modify VelocityNew, RotationNew, PositionNew</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>UpdatePhase2</span><span class=p>(</span><span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RotationNew</span> <span class=p>=</span> <span class=n>m_Character</span><span class=p>.</span><span class=n>UpdateRotation</span><span class=p>(</span><span class=n>RotationNew</span><span class=p>,</span> <span class=n>gameTime</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>VelocityNew</span> <span class=p>=</span> <span class=n>m_Character</span><span class=p>.</span><span class=n>UpdateVelocity</span><span class=p>(</span><span class=n>VelocityNew</span><span class=p>,</span> <span class=n>gameTime</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// apply gravity</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>UseGravity</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>GravityDirection</span> <span class=p>*</span> <span class=n>GravityScale</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// apply other external force</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>AdditionalForceToApply</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>AdditionalForceToApply</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>AdditionalForceToApply</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>VelocityNew</span> <span class=p>=</span> <span class=n>ClampVelocity</span><span class=p>(</span><span class=n>VelocityNew</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CurrentCollisionFlags</span> <span class=p>=</span> <span class=n>DoCCTMove</span><span class=p>(</span><span class=k>ref</span> <span class=n>PositionNew</span><span class=p>,</span> <span class=n>VelocityNew</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>,</span> <span class=kc>true</span><span class=p>);</span> <span class=c1>// true means snap to ground</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessControllerHits</span><span class=p>();</span> <span class=c1>// may modify VelocityNew</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...</span>
</span></span><span class=line><span class=cl>    <span class=n>Velocity</span> <span class=p>=</span> <span class=n>VelocityNew</span><span class=p>;</span> <span class=c1>// for outside logic</span>
</span></span><span class=line><span class=cl>    <span class=n>m_Character</span><span class=p>.</span><span class=n>AfterCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if</span> <span class=n>UNITY_EDITOR</span>
</span></span><span class=line><span class=cl>    <span class=n>RecordPreviousPositions</span><span class=p>(</span><span class=n>PositionNew</span><span class=p>);</span> <span class=c1>// for debug gizmos</span>
</span></span><span class=line><span class=cl><span class=cp>#endif</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=å…·ä½“åŠŸèƒ½å®ç°>å…·ä½“åŠŸèƒ½å®ç°<a hidden class=anchor aria-hidden=true href=#å…·ä½“åŠŸèƒ½å®ç°>#</a></h1><p>ä¸‹é¢åˆ—ä¸¾å‡ ä¸ªå…³é”®åŠŸèƒ½çš„å®ç°æ–¹å¼ã€‚</p><h2 id=ç€åœ°çŠ¶æ€æ£€æµ‹grounddetection>ç€åœ°çŠ¶æ€æ£€æµ‹<code>GroundDetection</code><a hidden class=anchor aria-hidden=true href=#ç€åœ°çŠ¶æ€æ£€æµ‹grounddetection>#</a></h2><p>é¦–å…ˆï¼ŒPhysicalCCTä¸­è®°å½•çš„å…³äºç€åœ°çŠ¶æ€çš„å­—æ®µæœ‰ï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>PhysicalCCT</span> <span class=p>:</span> <span class=n>MonoBehaviour</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Serializable]</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=k>struct</span> <span class=nc>GroundingState</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>bool</span> <span class=n>IsGrounded</span><span class=p>;</span> <span class=c1>// todo: we can decide if on a stable ground, or on an edge.</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>Vector3</span> <span class=n>GroundNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>Vector3</span> <span class=n>SnapToGroundDisplacement</span><span class=p>;</span><span class=c1>// assigned when IsGrounded is true, and apply once in current frame&#39;s cctmove</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>IPhysicalMover</span> <span class=n>Mover</span><span class=p>;</span> <span class=c1>// can be null</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>Vector3</span> <span class=n>MoverVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=n>Vector3</span> <span class=n>MoverAngularVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>GroundingState</span> <span class=n>CurrentGroundState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>GroundingState</span> <span class=n>LastGroundState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>const</span> <span class=kt>float</span> <span class=n>GroundDetectionBackDistance</span> <span class=p>=</span> <span class=m>0.002f</span><span class=p>;</span> <span class=c1>// avoid raycast exactly from ground. must smaller than MinGroundDetectionDistance</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>float</span> <span class=n>GroundDetectionDistance</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>distance</span> <span class=p>=</span> <span class=m>0.1f</span> <span class=p>+</span> <span class=n>GroundDetectionBackDistance</span> <span class=p>+</span> <span class=p>(</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>?</span> <span class=n>StepOffset</span> <span class=p>:</span> <span class=m>0f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>RaycastHit</span><span class=p>[]</span> <span class=n>m_GroundDetectionBuffer</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RaycastHit</span><span class=p>[</span><span class=m>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>bool</span> <span class=n>m_ForceUnground</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>m_ForceUngroundReMainFrameCount</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>bool</span> <span class=n>IsLanding</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>!</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>bool</span> <span class=n>IsSliding</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>IsGroundTooSteep</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>bool</span> <span class=n>IsGrounded</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>bool</span> <span class=n>IsGroundTooSteep</span><span class=p>(</span><span class=n>GroundingState</span> <span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>state</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>float</span> <span class=n>slopeAngle</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Angle</span><span class=p>(</span><span class=n>CharacterUp</span><span class=p>,</span> <span class=n>state</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>slopeAngle</span> <span class=p>&gt;</span> <span class=m>90</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=kc>false</span><span class=p>;</span><span class=c1>// meaningless</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>slopeAngle</span> <span class=p>&gt;</span> <span class=n>SlopeLimit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>æµç¨‹å›¾ä¸­<code>GroundDetection</code>å†…éƒ¨é€»è¾‘å¦‚ä¸‹ï¼š</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>GroundDetection</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LastGroundState</span> <span class=p>=</span> <span class=n>CurrentGroundState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>newState</span> <span class=p>=</span> <span class=k>new</span> <span class=n>GroundingState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>newState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsForcingUnGround</span><span class=p>)</span> <span class=c1>// e.g. request jump</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ForceUngroundReMainFrameCount</span><span class=p>--;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>m_ForceUngroundReMainFrameCount</span> <span class=p>&lt;=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>m_ForceUnground</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>PositionNew</span> <span class=p>+=</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=n>GroundDetectionBackDistance</span><span class=p>;</span> <span class=c1>// ensure next frame</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>groundLayerMask</span> <span class=p>=</span> <span class=n>PhysicsUtil</span><span class=p>.</span><span class=n>GetLayerMask</span><span class=p>(...);</span> <span class=c1>// use your own layer mask</span>
</span></span><span class=line><span class=cl>        <span class=n>RaycastHit</span> <span class=n>closestSweepHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>startPos</span> <span class=p>=</span> <span class=n>PositionNew</span> <span class=p>+</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=n>GroundDetectionBackDistance</span><span class=p>;</span> <span class=c1>//add a little offset to avoid raycast exactly from ground</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>DetectionDirection</span> <span class=p>=</span> <span class=p>-</span><span class=n>CharacterUp</span><span class=p>;</span> <span class=c1>// not GravityDirection, because &#34;OnGround&#34; means stand on feet</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>isHit</span> <span class=p>=</span> <span class=n>CCTSweep</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>DetectionDirection</span><span class=p>,</span> <span class=n>GroundDetectionDistance</span><span class=p>,</span> <span class=n>groundLayerMask</span><span class=p>,</span> <span class=k>out</span> <span class=n>closestSweepHit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>isHit</span> <span class=p>&amp;&amp;</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span> <span class=p>!=</span> <span class=kc>null</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span><span class=p>.</span><span class=n>isTrigger</span><span class=p>)</span> <span class=c1>// do not include trigger</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>newState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>newState</span><span class=p>.</span><span class=n>SnapToGroundDisplacement</span> <span class=p>=</span> <span class=p>(</span><span class=n>closestSweepHit</span><span class=p>.</span><span class=n>distance</span> <span class=p>-</span> <span class=n>GroundDetectionBackDistance</span><span class=p>)</span> <span class=p>*</span> <span class=n>DetectionDirection</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>Vector3</span> <span class=n>hitPos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>RaycastHit</span> <span class=n>closestRaycastHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>extraDistance</span> <span class=p>=</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Max</span><span class=p>(</span><span class=n>Radius</span><span class=p>,</span> <span class=n>StepOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>CCTRaycast</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>DetectionDirection</span><span class=p>,</span> <span class=n>GroundDetectionDistance</span> <span class=p>+</span> <span class=n>extraDistance</span><span class=p>,</span> <span class=n>groundLayerMask</span><span class=p>,</span> <span class=k>out</span> <span class=n>closestRaycastHit</span><span class=p>))</span> <span class=c1>// more precise</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>GroundNormal</span> <span class=p>=</span> <span class=n>closestRaycastHit</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>=</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span><span class=p>.</span><span class=n>gameObject</span><span class=p>.</span><span class=n>GetComponentInParent</span><span class=p>&lt;</span><span class=n>IPhysicalMover</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>                <span class=n>hitPos</span> <span class=p>=</span> <span class=n>closestRaycastHit</span><span class=p>.</span><span class=n>point</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=c1>// fallback</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>GroundNormal</span> <span class=p>=</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>=</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span><span class=p>.</span><span class=n>gameObject</span><span class=p>.</span><span class=n>GetComponentInParent</span><span class=p>&lt;</span><span class=n>IPhysicalMover</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>                <span class=n>hitPos</span> <span class=p>=</span> <span class=n>PositionNew</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>newState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=kc>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>pressure</span> <span class=p>=</span> <span class=n>GravityDirection</span> <span class=p>*</span> <span class=n>GravityScale</span> <span class=p>*</span> <span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>pressure</span><span class=p>,</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>,</span> <span class=n>hitPos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CurrentGroundState</span> <span class=p>=</span> <span class=n>newState</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>m_sweep_point1</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>m_sweep_point2</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>m_sweep_direction</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>m_sweep_distance</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>m_sweep_radius</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>bool</span> <span class=n>CCTSweep</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>position</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>direction</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distance</span><span class=p>,</span> <span class=kt>int</span> <span class=n>layermask</span><span class=p>,</span> <span class=k>out</span> <span class=n>RaycastHit</span> <span class=n>closestHit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>closestHit</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RaycastHit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>distance</span> <span class=p>&lt;=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=p>+=</span> <span class=n>SkinWidth</span><span class=p>;</span> <span class=c1>// must add skinwidth, since capsulecast m_sweep_point1 is hemi-sphere center, not capsule foot position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>bias</span> <span class=p>=</span> <span class=n>Height</span> <span class=p>*</span> <span class=m>0.5f</span> <span class=p>-</span> <span class=n>Radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_point1</span> <span class=p>=</span> <span class=n>position</span> <span class=p>+</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=p>(</span><span class=n>CenterOffset</span><span class=p>.</span><span class=n>y</span> <span class=p>-</span> <span class=n>bias</span><span class=p>);</span> <span class=c1>// foot hemi-sphere center</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_point2</span> <span class=p>=</span> <span class=n>position</span> <span class=p>+</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=p>(</span><span class=n>CenterOffset</span><span class=p>.</span><span class=n>y</span> <span class=p>+</span> <span class=n>bias</span><span class=p>);</span> <span class=c1>// head hemi-sphere center</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_distance</span> <span class=p>=</span> <span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_radius</span> <span class=p>=</span> <span class=n>Radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_direction</span> <span class=p>=</span> <span class=n>direction</span><span class=p>.</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>m_sweep_direction</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&lt;=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Debugger</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=s>&#34;Invalid sweep direction:&#34;</span> <span class=p>+</span> <span class=n>direction</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=s>&#34;G3&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numberOfHits</span> <span class=p>=</span> <span class=n>Physics</span><span class=p>.</span><span class=n>CapsuleCastNonAlloc</span><span class=p>(</span><span class=n>m_sweep_point1</span><span class=p>,</span> <span class=n>m_sweep_point2</span><span class=p>,</span> <span class=n>m_sweep_radius</span><span class=p>,</span> <span class=n>m_sweep_direction</span><span class=p>,</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>,</span> <span class=n>m_sweep_distance</span><span class=p>,</span> <span class=n>layermask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//find closest hit</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>foundValidHit</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=kt>float</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>numberOfHits</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>hit</span> <span class=p>=</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&lt;</span> <span class=n>closestHitDistance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHit</span> <span class=p>=</span> <span class=n>hit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>foundValidHit</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>foundValidHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=kt>bool</span> <span class=n>CCTRaycast</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>position</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>direction</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distance</span><span class=p>,</span> <span class=kt>int</span> <span class=n>layermask</span><span class=p>,</span> <span class=k>out</span> <span class=n>RaycastHit</span> <span class=n>closestHit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>closestHit</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RaycastHit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numberOfHits</span> <span class=p>=</span> <span class=n>Physics</span><span class=p>.</span><span class=n>RaycastNonAlloc</span><span class=p>(</span><span class=n>position</span><span class=p>,</span> <span class=n>direction</span><span class=p>,</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>,</span> <span class=n>distance</span><span class=p>,</span> <span class=n>layermask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//find closest hit</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>foundValidHit</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=kt>float</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>numberOfHits</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>hit</span> <span class=p>=</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&lt;</span> <span class=n>closestHitDistance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHit</span> <span class=p>=</span> <span class=n>hit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>foundValidHit</span> <span class=p>=</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>foundValidHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=è½åœ°é€Ÿåº¦ä¿®æ­£fixvelocityonground>è½åœ°é€Ÿåº¦ä¿®æ­£<code>FixVelocityOnGround</code><a hidden class=anchor aria-hidden=true href=#è½åœ°é€Ÿåº¦ä¿®æ­£fixvelocityonground>#</a></h2><p>è¿™ä¸€æ­¥çš„ç›®çš„æ˜¯é˜²æ­¢è½åœ°åå¼¹è·³ç­‰ä¸è‡ªç„¶è¡¨ç°ï¼Œä»¥åŠå‘ä¸Šå†²é™¡å¡æ—¶çš„é™åˆ¶ã€‚</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>FixVelocityOnGround</span><span class=p>(</span><span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(!</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>VelocityNew</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsLanding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span> <span class=c1>// no jump up</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>vRight</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Cross</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>tangentDir</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Cross</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>,</span> <span class=n>vRight</span><span class=p>).</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>tangentDir</span> <span class=p>*</span> <span class=n>tempVelocity</span><span class=p>.</span><span class=n>magnitude</span><span class=p>;</span> <span class=c1>// reorient velocity along ground tangent</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsSliding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>slidingAcceleration</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>GravityDirection</span> <span class=p>*</span> <span class=n>GravityScale</span><span class=p>,</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ForbidUphillMovementWhenSliding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>slidingProjection</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Dot</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>slidingAcceleration</span><span class=p>.</span><span class=n>normalized</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>slidingProjection</span> <span class=p>&lt;</span> <span class=m>0</span><span class=p>)</span> <span class=c1>// has uphill velocity</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// discard uphill velocity</span>
</span></span><span class=line><span class=cl>                <span class=n>tempVelocity</span> <span class=p>-=</span> <span class=n>slidingProjection</span> <span class=p>*</span> <span class=n>slidingAcceleration</span><span class=p>.</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>+=</span>  <span class=n>slidingAcceleration</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>VelocityNew</span> <span class=p>=</span> <span class=n>tempVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Discard velocity that is perpendicular to the hit normal from v</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>Vector3</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>v</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>planeNormal</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>v</span> <span class=p>-</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Dot</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>planeNormal</span><span class=p>)</span> <span class=p>*</span> <span class=n>planeNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ç§»åŠ¨å¹³å°è·Ÿéšcctmovewithground>ç§»åŠ¨å¹³å°è·Ÿéš<code>CCTMoveWithGround</code><a hidden class=anchor aria-hidden=true href=#ç§»åŠ¨å¹³å°è·Ÿéšcctmovewithground>#</a></h2><p>æ­¤æ—¶å·²ç»è·å¾—äº†ç€åœ°çŠ¶æ€ï¼Œå¦‚æœè„šä¸‹æ˜¯ç§»åŠ¨å¹³å°ï¼Œéœ€è¦å¤„ç†è·Ÿéšè¿åŠ¨ã€ä»¥åŠè·³è¿›è·³å‡ºæ—¶çš„æƒ¯æ€§ã€‚</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>MoverVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>MoverAngularVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GetPointVelocityFromPhysicalMover</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>Mover</span><span class=p>,</span> <span class=n>PositionNew</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>,</span> <span class=k>out</span> <span class=n>MoverVelocity</span><span class=p>,</span> <span class=k>out</span> <span class=n>MoverAngularVelocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span> <span class=p>=</span> <span class=n>MoverVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverAngularVelocityAtPosition</span> <span class=p>=</span> <span class=n>MoverAngularVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// jump between different moving grounds</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=kc>null</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=n>LastGroundState</span><span class=p>.</span><span class=n>Mover</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>LastGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>-=</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// do not bump when landing</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>==</span> <span class=kc>null</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=kc>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>-=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// rotate with mover</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverAngularVelocityAtPosition</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>newForward</span> <span class=p>=</span> <span class=n>Quaternion</span><span class=p>.</span><span class=n>Euler</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverAngularVelocityAtPosition</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>)</span> <span class=p>*</span> <span class=n>CharacterForward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>newForward</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>newForward</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>).</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>RotationNew</span> <span class=p>=</span> <span class=n>Quaternion</span><span class=p>.</span><span class=n>LookRotation</span><span class=p>(</span><span class=n>newForward</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// translate with mover</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DoCCTMove</span><span class=p>(</span><span class=k>ref</span> <span class=n>PositionNew</span><span class=p>,</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>,</span> <span class=kc>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Turn on SlightMove when user is not moving, this is to detect collision</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=n>CollisionFlags</span> <span class=n>DoCCTMove</span><span class=p>(</span><span class=k>ref</span> <span class=n>Vector3</span> <span class=n>position</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>velocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>extraSnapToGround</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>noiseMovemet</span> <span class=p>=</span> <span class=m>0.001f</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>movement</span> <span class=p>=</span> <span class=n>SlightMove</span> <span class=p>?</span> <span class=n>noiseMovemet</span> <span class=p>*</span> <span class=n>CharacterForward</span> <span class=p>:</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>velocity</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>movement</span> <span class=p>=</span> <span class=n>velocity</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Snap to ground: add displacement to keep character attached when going downhill</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>extraSnapToGround</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>SnapToGroundDisplacement</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>movement</span> <span class=p>+=</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>SnapToGroundDisplacement</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>flags</span> <span class=p>=</span> <span class=n>m_CCT</span><span class=p>.</span><span class=n>Move</span><span class=p>(</span><span class=n>movement</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>position</span> <span class=p>=</span> <span class=n>m_CCT</span><span class=p>.</span><span class=n>transform</span><span class=p>.</span><span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=ä¸è¾“å…¥é€Ÿåº¦æ··åˆblendwithinputvelocity>ä¸è¾“å…¥é€Ÿåº¦æ··åˆ<code>BlendWithInputVelocity</code><a hidden class=anchor aria-hidden=true href=#ä¸è¾“å…¥é€Ÿåº¦æ··åˆblendwithinputvelocity>#</a></h2><p>è¿™ä¸€æ­¥æ˜¯åœ¨å®ç°æ¥å£å‡½æ•°<code>UpdateVelocity</code>æ—¶ï¼Œå°†ä¼ å…¥çš„<code>BaseVelocity</code>å’Œè¯»å–åˆ°çš„ç©å®¶è¾“å…¥è¿›è¡Œæ··åˆï¼ŒåŒ…æ‹¬å¤„ç†è·³è·ƒã€ç©ºä¸­ç§»åŠ¨ç­‰ã€‚</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>IPhysicalCharacter</span><span class=p>.</span><span class=n>UpdateVelocity</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>BaseVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>originalV</span> <span class=p>=</span> <span class=n>BaseVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// handle jump separately</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>RequestJump</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RequestJump</span> <span class=p>=</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span> <span class=p>&lt;</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpMaxCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>float</span> <span class=n>jumpupSpeed</span> <span class=p>=</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Sqrt</span><span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpHeight</span> <span class=p>*</span> <span class=m>2</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>GravityScale</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>+=</span> <span class=n>jumpupSpeed</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>ForceUnground</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// when second jump, it reset BaseVelocity along CharacterUp direction, rather than add to BaseVelocity</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>cutVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Dot</span><span class=p>(</span><span class=n>BaseVelocity</span><span class=p>,</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>)</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>restVelocity</span> <span class=p>=</span> <span class=n>BaseVelocity</span> <span class=p>-</span> <span class=n>cutVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>=</span> <span class=n>restVelocity</span> <span class=p>+</span> <span class=n>jumpupSpeed</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>InputVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>)</span> <span class=c1>// standing, walking, running</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=c1>// reset jump count</span>
</span></span><span class=line><span class=cl>            <span class=n>InputVelocity</span> <span class=p>=</span> <span class=n>MovingDirection</span> <span class=p>*</span> <span class=n>MoveSpeed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// rotate InputVelocity onto ground plane, only if IsSliding false</span>
</span></span><span class=line><span class=cl>            <span class=n>Vector3</span> <span class=n>groundNormal</span> <span class=p>=</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>InputVelocity</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>groundNormal</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>InputVelocity</span> <span class=p>=</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>ReorientVelocityToPlane</span><span class=p>(</span><span class=n>InputVelocity</span><span class=p>,</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>,</span> <span class=n>groundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// assign BaseVelocity with InputVelocity</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>IsSliding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// usually we don&#39;t want to lose control immediately, but gradually</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>+=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Lerp</span><span class=p>(</span><span class=n>InputVelocity</span><span class=p>,</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>,</span> <span class=m>1f</span> <span class=p>-</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Exp</span><span class=p>(-</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>LoseControlMoveSensibility</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// we want to move as desired velocity (InputVelocity) quickly, but not immediately</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Lerp</span><span class=p>(</span><span class=n>BaseVelocity</span><span class=p>,</span> <span class=n>InputVelocity</span><span class=p>,</span> <span class=m>1f</span> <span class=p>-</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Exp</span><span class=p>(-</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>ControlMoveSensibility</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=c1>// falling</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CanMoveInAir</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// when dashing, moving dir is 0,0,0</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>dir</span> <span class=p>=</span> <span class=n>MovingDirection</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>dir</span><span class=p>.</span><span class=n>y</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>horizontalBaseVelocity</span> <span class=p>=</span> <span class=n>dir</span><span class=p>.</span><span class=n>normalized</span> <span class=p>*</span> <span class=n>MoveSpeed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// when in air, don&#39;t change horizontal velocity if no input</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>horizontalBaseVelocity</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>BaseVelocity</span><span class=p>.</span><span class=n>x</span> <span class=p>=</span> <span class=n>horizontalBaseVelocity</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>BaseVelocity</span><span class=p>.</span><span class=n>z</span> <span class=p>=</span> <span class=n>horizontalBaseVelocity</span><span class=p>.</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BaseVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=å—åŠ›è¿åŠ¨applyotherenternalforce>å—åŠ›è¿åŠ¨<code>ApplyOtherEnternalForce</code><a hidden class=anchor aria-hidden=true href=#å—åŠ›è¿åŠ¨applyotherenternalforce>#</a></h2><p>Addforceæ”¯æŒå¤šç§æ–½åŠ›æ¨¡å¼ï¼Œå’Œåˆšä½“ç±»ä¼¼ã€‚è½¬åŒ–ä¸ºé€Ÿåº¦åï¼Œæœ€ååœ¨<code>ApplyOtherEnternalForce</code>ä¸­ç›´æ¥å åŠ åˆ°<code>VelocityNew</code>ã€‚</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>AddExternalForce</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>force</span><span class=p>,</span> <span class=n>ForceMode</span> <span class=n>mode</span> <span class=p>=</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span> <span class=p>*</span> <span class=n>DeltaTime</span> <span class=p>/</span> <span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Acceleration</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span> <span class=p>*</span> <span class=n>DeltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Impulse</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span> <span class=p>/</span> <span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>VelocityChange</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=å¤„ç†ç‰©ç†ç¢°æ’æ•ˆæœprocesscontrollerhits>å¤„ç†ç‰©ç†ç¢°æ’æ•ˆæœ<code>ProcessControllerHits</code><a hidden class=anchor aria-hidden=true href=#å¤„ç†ç‰©ç†ç¢°æ’æ•ˆæœprocesscontrollerhits>#</a></h2><p>è¢«æ¨æŒ¤è¿˜æ˜¯è¢«æ’é£æœ‰ä¸€ä¸ªåˆ¤å®šé˜ˆå€¼ã€‚<code>SolveCCTCollideWithMovableObject</code>å†…éƒ¨ï¼Œä¼šæ ¹æ®äºŒè€…ç›¸ç¢°æ—¶ç¢°æ’æ–¹å‘ä¸Šçš„é€Ÿåº¦å·®ï¼Œä»¥åŠäºŒè€…çš„è´¨é‡å·®ï¼Œå†³å®šæ˜¯å¼¹æ€§æˆ–æ˜¯éå¼¹æ€§ç¢°æ’ã€‚</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// This is called just after CCTMove</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>OnControllerColliderHit</span><span class=p>(</span><span class=n>ControllerColliderHit</span> <span class=n>hit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>mover</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>gameObject</span><span class=p>.</span><span class=n>GetComponentInParent</span><span class=p>&lt;</span><span class=n>IPhysicalMover</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mover</span> <span class=p>!=</span> <span class=kc>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ControllerHitInfo</span> <span class=n>projectionHit</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ControllerHitInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>HitNormal</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>HitPoint</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>point</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>Mover</span> <span class=p>=</span> <span class=n>mover</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>CCTHitVelocity</span> <span class=p>=</span> <span class=n>Velocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>m_ControllerHits</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>projectionHit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>private</span> <span class=k>void</span> <span class=n>ProcessControllerHits</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>m_ControllerHits</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>hitInfo</span> <span class=p>=</span> <span class=n>m_ControllerHits</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(!</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>IsValid</span><span class=p>()</span> <span class=p>||</span> <span class=n>m_HittedMovers</span><span class=p>.</span><span class=n>Contains</span><span class=p>(</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_HittedMovers</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// todo: what if Mover is other CCT/PhysicalMover</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>moverMass</span> <span class=p>=</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>GetMoverMass</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>cctMass</span> <span class=p>=</span> <span class=k>this</span><span class=p>.</span><span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>cctVelocityDeltaAfterCollision</span><span class=p>,</span> <span class=n>moverVelocityDeltaAfterCollision</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>isBounce</span> <span class=p>=</span> <span class=n>PhysicalContactSolver</span><span class=p>.</span><span class=n>SolveCCTCollideWithMovableObject</span><span class=p>(</span><span class=k>this</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>hitInfo</span><span class=p>.</span><span class=n>HitNormal</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>CCTHitVelocity</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>MoverHitVelocity</span><span class=p>,</span> <span class=n>cctMass</span><span class=p>,</span> <span class=n>moverMass</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>out</span> <span class=n>cctVelocityDeltaAfterCollision</span><span class=p>,</span> <span class=k>out</span> <span class=n>moverVelocityDeltaAfterCollision</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(!</span><span class=n>isBounce</span> <span class=p>&amp;&amp;</span> <span class=n>UseCustomPushForce</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>HitNormal</span> <span class=p>*</span> <span class=p>(-</span><span class=n>CustomPushForce</span><span class=p>),</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>HitPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>cctVelocityDeltaAfterCollision</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>moverVelocityDeltaAfterCollision</span><span class=p>,</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>VelocityChange</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>HitPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li><li><a href=https://pps43.github.io/tags/unity/>Unity</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/unite2024_wechatminigame/><span class=title>Â« Prev</span><br><span>WebGLå¹³å°çš„æ€§èƒ½é™åˆ¶å’Œè§£å†³æ–¹æ¡ˆï¼ˆä»¥å¾®ä¿¡å°æ¸¸æˆä¸ºä¾‹ï¼‰</span>
</a><a class=next href=https://pps43.github.io/posts/using_physx_cct/><span class=title>Next Â»</span><br><span>PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller</span></a></nav></footer></article></main><footer class=footer><span>Â© 2016-2023 By æ³¢æ³¢æ²™.</span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>