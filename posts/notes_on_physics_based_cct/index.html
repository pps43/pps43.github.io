<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>带物理交互的CharacterController设计与实现 | 波波沙🏠</title><meta name=keywords content="Game Dev,PhysX,Unity"><meta name=description content="本文也是PhysX物理引擎系列的番外篇。介绍了笔者基于CharacterController(CCT)设计的一个新的角色控制器，在修补Uni"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/notes_on_physics_based_cct/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="带物理交互的CharacterController设计与实现"><meta property="og:description" content="本文也是PhysX物理引擎系列的番外篇。介绍了笔者基于CharacterController(CCT)设计的一个新的角色控制器，在修补Uni"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/notes_on_physics_based_cct/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-03-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="带物理交互的CharacterController设计与实现"><meta name=twitter:description content="本文也是PhysX物理引擎系列的番外篇。介绍了笔者基于CharacterController(CCT)设计的一个新的角色控制器，在修补Uni"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"带物理交互的CharacterController设计与实现","item":"https://pps43.github.io/posts/notes_on_physics_based_cct/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"带物理交互的CharacterController设计与实现","name":"带物理交互的CharacterController设计与实现","description":"本文也是PhysX物理引擎系列的番外篇。介绍了笔者基于CharacterController(CCT)设计的一个新的角色控制器，在修补Uni","keywords":["Game Dev","PhysX","Unity"],"articleBody":" 本文也是PhysX物理引擎系列的番外篇。介绍了笔者基于CharacterController(CCT)设计的一个新的角色控制器，在修补Unity/PhysX的CCT的缺陷外，还增添了若干和物理交互相关的有趣特性。代码已经过实际项目验证，这里仅保留和具体业务无关的部分。\n背景和需求 前文结尾处提到一些PhysX自带的CCT（Unity也是基于此二次封装出CharacterController组件）在实际游戏开发中的缺点，这里再次总结：\nCCT不参与碰撞系统的检测。仅当CCT自身移动时会判断是否被其他刚体或CCT阻挡。这就造成一个BUG：CCT自身静止时，其他运动物体会穿过CCT且没有事件触发。官方论坛上有苦主持续8年向Unity反馈这个问题但无法解决，目前已知的唯一绕过方式是每帧给CCT附加一个微小的位移（下文中的SlightMove）。 Unity提供的接口CharacterController.isGrounded效果很不稳定。其内部只是判断CCT上次运动后底部是否触碰物体。即collisionFlags \u0026 eCOLLISION_DOWN::eCOLLISION_DOWN。但在上下坡或崎岖地形时，很容易出现侧面触碰或短暂浮空。如果用该接口驱动动画表现甚至跑跳逻辑，效果很差。需要自行基于SceneQuery封装出更加稳定的判定着地的函数。 Unity没有暴露CCT.upVector，角色总是竖直向上的。要实现反重力鞋在任意斜面上行走或像马里奥银河那样在曲面上跑跳穿梭，只能放弃使用CCT但也放弃了其在操作手感上的改善。其实拿到Unity的源码后，只用了十分钟将底层字段暴露到C#层就解决了该问题。 新的角色控制器需要增加的物理交互特性有：\n受力。 既可以像传统CCT一样精准操控运动，也可以像刚体一样对其施力。 其他刚体可以对其产生推挤、撞飞效果。 自身重力可在陡坡上产生滑行效果。 施力。运动时具有推力，自身重力可以对外做功。 重力方向。大小和方向动态可变，方向变化时可自动旋转CCT以调整姿态。 移动平台。CCT可附着在所有移动对象上跟随运动，不借助父子结构。 另外CCT还支持了两种网络同步方式：服务端跟随客户端（通过校验维持服务端权威性）、客户端跟随服务端（通过外插减小延迟），并且可以动态切换。考虑到篇幅，本篇对同步算法不展开介绍。\n技术路线 角色要实现丰富的物理交互，大体有三种思路：\n基于CCT，添加动力学模拟（施力、受力）。运动受控度最高，但算法复杂。 基于Kinematic刚体，添加CCT特性（Collide-and-Slide） 、添加动力学模拟（受力运动）。运动受控度高，但算法复杂。 基于Dynamic刚体，添加部分CCT特性。例如Active Ragdoll技术。运动受控度低，但逻辑简洁，且特别适合糖豆人这类休闲蠢萌角色。 结合玩法类型和项目实际情况，为了最大化复用原有角色功能，最终选择了第一种思路。\n框架设计 要模拟各类物理交互，有三个重要设计。\n所有交互最终都转化为速度这个物理量。每帧通过融合后的总速度产生一次cctmove。具体交互包括摇杆输入、API输入、重力、摩擦、碰撞时的冲量… 交互对象不限于刚体，而是所有实现了IPhysicalMover接口的对象。这样就将不参与刚体仿真的对象也统一起来（比如cct和被强制移动的static collider）。 将交互效果的计算，分为内核与接口。内核部分PhysicalCCT实现了物理交互的核心计算和流程，不同业务的角色类只需实现IPhysicalCharacter接口部分就能受内核驱动，并定制玩法相关的效果。 下面是两个接口的定义：\n/// /// a actor who has mass, velocity, and can add force to. (e.g. moving platform) /// public interface IPhysicalMover { float GetMoverMass(); Vector3 GetMoverCenterOfRotation(); Vector3 GetMoverVelocity(); //m/s Vector3 GetMoverAngularVelocity(); //degree/s void AddForceAtPosition(Vector3 force, ForceMode mode, Vector3 hitPoint); } public interface IPhysicalCharacter { void BeforeCCTUpdate(); void AfterCCTUpdate(); /// /// Can be used to do Landing/Take off game logic based on CurrentGroundState and LastGroundState /// void AfterUpdateGroundState(); /// /// Update CCT rotation according to input and game logic (e.g., change Forward to moving dir, or rotate Up to align with gravity). /// BaseRotation means auto-generated rotation if walking on the surface of a rotating platform. /// Return modified Rotation. /// Quaternion UpdateRotation(Quaternion BaseRotation, float gameTime, float deltaTime); /// /// Update CCT velocity according to input (walk, run, jump...should have different speed) and game logic (e.g., if Dead, set velocity to zero). /// Do not add gravity inside. /// Return modified Velocity. /// Vector3 UpdateVelocity(Vector3 BaseVelocity, float gameTime, float deltaTime); void OnGroundHit(Collider hitCollider, Vector3 hitNormal, Vector3 hitPoint); // during GroundDetection void OnCollideWith(Collider hitCollider); } 下面是框架调用流程。\nsequenceDiagram participant Game participant Character participant PhysicalCCT Game-\u003e\u003eCharacter: FixedUpdate Note over Character: ... Character-\u003e\u003ePhysicalCCT: UpdatePhase1 PhysicalCCT-\u003e\u003eCharacter: BeforeCCTUpdate Note over Character: ... Note over PhysicalCCT: GroundDetection PhysicalCCT-\u003e\u003eCharacter: OnGroundHit PhysicalCCT-\u003e\u003eCharacter: AfterUpdateGroundState Note over PhysicalCCT: FixVelocityOnGround critical GetPointVelocityOnMover PhysicalCCT -\u003e\u003e Mover: GetMoverVelocity PhysicalCCT -\u003e\u003e Mover: GetMoverAngularVelocity PhysicalCCT -\u003e\u003e Mover: GetMoverCenterOfRotation end Note over PhysicalCCT: CCTMoveWithGround Game --\u003e Mover: All movers should have moved to final pos Character-\u003e\u003ePhysicalCCT: UpdatePhase2 PhysicalCCT-\u003e\u003eCharacter: UpdateRotation Note over Character: RotateWithCamera/... PhysicalCCT-\u003e\u003eCharacter: UpdateVelocity Note over Character: BlendWithInputVelocity/Jump/... Note over PhysicalCCT: ApplyGravity Note over PhysicalCCT: ApplyOtherExternalForce Note over PhysicalCCT: ClampFinalVelocity Note over PhysicalCCT: CCTMove Note over PhysicalCCT: ProcessControllerHits PhysicalCCT -\u003e\u003e PhysicalCCT: modify self Velocity PhysicalCCT -\u003e\u003e Mover: AddForceAtPosition PhysicalCCT -\u003e\u003e Character: OnCollideWith PhysicalCCT -\u003e\u003e Character: AfterCCTUpdate Note over Character: ... 框架代码示意：\npublic void UpdatePhase1(float gameTime, float deltaTime) { m_Character.BeforeCCTUpdate(); ResetEveryFrame(deltaTime); GroundDetection(); // may modify PositionNew if force unground m_Character.AfterUpdateGroundState(); FixVelocityOnGround(deltaTime); // modify VelocityNew CCTMoveWithGround(deltaTime) // modify VelocityNew, RotationNew, PositionNew } public void UpdatePhase2(float gameTime, float deltaTime) { RotationNew = m_Character.UpdateRotation(RotationNew, gameTime, deltaTime); VelocityNew = m_Character.UpdateVelocity(VelocityNew, gameTime, deltaTime); // apply gravity if (UseGravity \u0026\u0026 !IsGrounded) { VelocityNew += GravityDirection * GravityScale * deltaTime * tuningRatio; } // apply other external force if (AdditionalForceToApply.sqrMagnitude \u003e 0) { VelocityNew += AdditionalForceToApply; AdditionalForceToApply = Vector3.zero; } VelocityNew = ClampVelocity(VelocityNew); CurrentCollisionFlags = DoCCTMove(ref PositionNew, VelocityNew, deltaTime); ProcessControllerHits(); // may modify VelocityNew //... Velocity = VelocityNew; // for outside logic m_Character.AfterCCTUpdate(); } 具体功能实现 下面列举几个关键功能的实现方式。\n着地状态检测GroundDetection 首先，PhysicalCCT中记录的关于着地状态的字段有：\npublic class PhysicalCCT : MonoBehaviour { //... [Serializable] public struct GroundingState { public bool IsGrounded; // todo: we can decide if on a stable ground, or on an edge. public Vector3 GroundNormal; public IPhysicalMover Mover; // can be null public Vector3 MoverVelocityAtPosition; public Vector3 MoverAngularVelocityAtPosition; } public GroundingState CurrentGroundState; public GroundingState LastGroundState; public const float GroundDetectionBackDistance = 0.002f; // avoid raycast exactly from ground. must smaller than MinGroundDetectionDistance public float MinGroundDetectionDistance = 0.005f; private RaycastHit[] m_GroundDetectionBuffer = new RaycastHit[8]; private bool m_ForceUnground = false; private int m_ForceUngroundReMainFrameCount = 0; public bool IsLanding { get { return !LastGroundState.IsGrounded \u0026\u0026 CurrentGroundState.IsGrounded; } } public bool IsSliding { get { return IsGroundTooSteep(CurrentGroundState); } } public bool IsGrounded { get { return CurrentGroundState.IsGrounded; } } private bool IsGroundTooSteep(GroundingState state) { if (state.IsGrounded) { float slopeAngle = Vector3.Angle(CharacterUp, state.GroundNormal); if (slopeAngle \u003e 90) { return false;// meaningless } return slopeAngle \u003e SlopeLimit; } return false; } } 流程图中GroundDetection内部逻辑如下：\nprivate void GroundDetection() { LastGroundState = CurrentGroundState; var newState = new GroundingState(); newState.IsGrounded = false; if (IsForcingUnGround) // e.g. request jump { m_ForceUngroundReMainFrameCount--; if (m_ForceUngroundReMainFrameCount \u003c= 0) { m_ForceUnground = false; PositionNew += CharacterUp * GroundDetectionBackDistance; // ensure next frame } } else { var groundLayerMask = PhysicsUtil.GetLayerMask(...); // use your own layer mask RaycastHit closestSweepHit; var startPos = PositionNew + CharacterUp * GroundDetectionBackDistance; //add a little offset to avoid raycast exactly from ground float distance = MinGroundDetectionDistance; var DetectionDirection = -CharacterUp; // not GravityDirection, because \"OnGround\" means stand on feet var isHit = CCTSweep(startPos, DetectionDirection, distance, groundLayerMask, out closestSweepHit); if (isHit \u0026\u0026 closestSweepHit.collider != null \u0026\u0026 !closestSweepHit.collider.isTrigger) { newState.IsGrounded = true; Vector3 hitPos; RaycastHit closestRaycastHit; var extraDistance = Mathf.Max(Radius, StepOffset); if (CCTRaycast(startPos, DetectionDirection, distance + extraDistance, groundLayerMask, out closestRaycastHit)) // more precise { newState.GroundNormal = closestRaycastHit.normal; newState.Mover = closestSweepHit.collider.gameObject.GetComponentInParent\u003cIPhysicalMover\u003e(); hitPos = closestRaycastHit.point; } else // fallback { newState.GroundNormal = closestSweepHit.normal; newState.Mover = closestSweepHit.collider.gameObject.GetComponentInParent\u003cIPhysicalMover\u003e(); hitPos = PositionNew; } if (newState.Mover != null) { var pressure = GravityDirection * GravityScale * Mass; newState.Mover.AddForceAtPosition(pressure, ForceMode.Force, hitPos); } } } CurrentGroundState = newState; } Vector3 m_sweep_point1 = Vector3.zero; Vector3 m_sweep_point2 = Vector3.zero; Vector3 m_sweep_direction = Vector3.zero; float m_sweep_distance = 0; float m_sweep_radius = 0; private bool CCTSweep(Vector3 position, Vector3 direction, float distance, int layermask, out RaycastHit closestHit) { closestHit = new RaycastHit(); if (distance \u003c= 0) { return false; } distance += SkinWidth; // must add skinwidth, since capsulecast m_sweep_point1 is hemi-sphere center, not capsule foot position var bias = Height * 0.5f - Radius; m_sweep_point1 = position + CharacterUp * (CenterOffset.y - bias); // foot hemi-sphere center m_sweep_point2 = position + CharacterUp * (CenterOffset.y + bias); // head hemi-sphere center m_sweep_distance = distance; m_sweep_radius = Radius; m_sweep_direction = direction.normalized; if (m_sweep_direction.sqrMagnitude \u003c= 0) { Debugger.Log(\"Invalid sweep direction:\" + direction.ToString(\"G3\")); return false; } int numberOfHits = Physics.CapsuleCastNonAlloc(m_sweep_point1, m_sweep_point2, m_sweep_radius, m_sweep_direction, m_GroundDetectionBuffer, m_sweep_distance, layermask); //find closest hit bool foundValidHit = false; float closestHitDistance = float.MaxValue; for (int i = 0; i \u003c numberOfHits; i++) { var hit = m_GroundDetectionBuffer[i]; if (hit.distance \u003e 0 \u0026\u0026 hit.distance \u003c closestHitDistance) { closestHitDistance = hit.distance; closestHit = hit; foundValidHit = true; } } return foundValidHit; } private bool CCTRaycast(Vector3 position, Vector3 direction, float distance, int layermask, out RaycastHit closestHit) { closestHit = new RaycastHit(); int numberOfHits = Physics.RaycastNonAlloc(position, direction, m_GroundDetectionBuffer, distance, layermask); //find closest hit bool foundValidHit = false; float closestHitDistance = float.MaxValue; for (int i = 0; i \u003c numberOfHits; i++) { var hit = m_GroundDetectionBuffer[i]; if (hit.distance \u003e 0 \u0026\u0026 hit.distance \u003c closestHitDistance) { closestHitDistance = hit.distance; closestHit = hit; foundValidHit = true; } } return foundValidHit; } 落地速度修正FixVelocityOnGround 这一步的目的是防止落地后弹跳等不自然表现，以及向上冲陡坡时的限制。\nprivate void FixVelocityOnGround(float deltaTime) { if (!IsGrounded) { return; } Vector3 tempVelocity = VelocityNew; if (IsLanding) { tempVelocity = ProjectVectorToPlane(tempVelocity, CharacterUp); // no jump up Vector3 vRight = Vector3.Cross(tempVelocity, CharacterUp); Vector3 tangentDir = Vector3.Cross(CurrentGroundState.GroundNormal, vRight).normalized; tempVelocity = tangentDir * tempVelocity.magnitude; // reorient velocity along ground tangent } if (IsSliding) { Vector3 slidingAcceleration = ProjectVectorToPlane(GravityDirection * GravityScale, CurrentGroundState.GroundNormal); tempVelocity = ProjectVectorToPlane(tempVelocity, CurrentGroundState.GroundNormal); if (ForbidUphillMovementWhenSliding) { var slidingProjection = Vector3.Dot(tempVelocity, slidingAcceleration.normalized); if (slidingProjection \u003c 0) // has uphill velocity { // discard uphill velocity tempVelocity -= slidingProjection * slidingAcceleration.normalized; } } tempVelocity += slidingAcceleration * deltaTime; } VelocityNew = tempVelocity; } /// /// Discard velocity that is perpendicular to the hit normal from v /// private Vector3 ProjectVectorToPlane(Vector3 v, Vector3 planeNormal) { return v - Vector3.Dot(v, planeNormal) * planeNormal; } 移动平台跟随CCTMoveWithGround 此时已经获得了着地状态，如果脚下是移动平台，需要处理跟随运动、以及跳进跳出时的惯性。\n{ Vector3 MoverVelocity = Vector3.zero; Vector3 MoverAngularVelocity = Vector3.zero; GetPointVelocityFromPhysicalMover(CurrentGroundState.Mover, PositionNew, deltaTime, out MoverVelocity, out MoverAngularVelocity); CurrentGroundState.MoverVelocityAtPosition = MoverVelocity; CurrentGroundState.MoverAngularVelocityAtPosition = MoverAngularVelocity; // jump between different moving grounds if (LastGroundState.Mover != null \u0026\u0026 CurrentGroundState.Mover != LastGroundState.Mover) { VelocityNew += LastGroundState.MoverVelocityAtPosition; VelocityNew -= CurrentGroundState.MoverVelocityAtPosition; } // do not bump when landing if (LastGroundState.Mover == null \u0026\u0026 CurrentGroundState.Mover != null) { VelocityNew -= ProjectVectorToPlane(CurrentGroundState.MoverVelocityAtPosition, CharacterUp); } // rotate with mover if (CurrentGroundState.MoverAngularVelocityAtPosition.sqrMagnitude \u003e 0) { Vector3 newForward = Quaternion.Euler(CurrentGroundState.MoverAngularVelocityAtPosition * deltaTime) * CharacterForward; newForward = ProjectVectorToPlane(newForward, CharacterUp).normalized; RotationNew = Quaternion.LookRotation(newForward, CharacterUp); } // translate with mover if (CurrentGroundState.MoverVelocityAtPosition.sqrMagnitude \u003e 0) { DoCCTMove(ref PositionNew, CurrentGroundState.MoverVelocityAtPosition, deltaTime); } } // Turn on SlightMove when user is not moving, this is to detect collision private CollisionFlags DoCCTMove(ref Vector3 position, Vector3 velocity, float deltaTime) { float noiseMovemet = MinMoveDistance \u003e 0 ? MinMoveDistance : 0.001f * deltaTime; Vector3 movement = SlightMove ? noiseMovemet * CharacterForward : Vector3.zero; if (velocity.sqrMagnitude \u003e 0) { movement = velocity * deltaTime; } var flags = m_CCT.Move(movement); position = m_CCT.transform.position; return flags; } 与输入速度混合BlendWithInputVelocity 这一步是在实现接口函数UpdateVelocity时，将传入的BaseVelocity和读取到的玩家输入进行混合，包括处理跳跃、空中移动等。\nVector3 IPhysicalCharacter.UpdateVelocity(Vector3 BaseVelocity, float gameTime, float deltaTime) { Vector3 originalV = BaseVelocity; // handle jump separately if (RequestJump) { RequestJump = false; if (PhysicalCCT.JumpCount \u003c PhysicalCCT.JumpMaxCount) { float jumpupSpeed = Mathf.Sqrt(PhysicalCCT.JumpHeight * 2 * PhysicalCCT.GravityScale); if (PhysicalCCT.CurrentGroundState.IsGrounded) { PhysicalCCT.JumpCount = 1; BaseVelocity += jumpupSpeed * PhysicalCCT.CharacterUp; PhysicalCCT.ForceUnground(); } else { // when second jump, it reset BaseVelocity along CharacterUp direction, rather than add to BaseVelocity var cutVelocity = Vector3.Dot(BaseVelocity, PhysicalCCT.CharacterUp) * PhysicalCCT.CharacterUp; var restVelocity = BaseVelocity - cutVelocity; BaseVelocity = restVelocity + jumpupSpeed * PhysicalCCT.CharacterUp; PhysicalCCT.JumpCount++; } } } else { Vector3 InputVelocity = Vector3.zero; if (PhysicalCCT.CurrentGroundState.IsGrounded) // standing, walking, running { PhysicalCCT.JumpCount = 0; // reset jump count InputVelocity = MovingDirection * MoveSpeed; // rotate InputVelocity onto ground plane, only if IsSliding false Vector3 groundNormal = PhysicalCCT.CurrentGroundState.GroundNormal; if (InputVelocity.sqrMagnitude \u003e 0 \u0026\u0026 groundNormal.sqrMagnitude \u003e 0) { InputVelocity = PhysicalCCT.ReorientVelocityToPlane(InputVelocity, PhysicalCCT.CharacterUp, groundNormal); } // assign BaseVelocity with InputVelocity if (PhysicalCCT.IsSliding) { // usually we don't want to lose control immediately, but gradually BaseVelocity += Vector3.Lerp(InputVelocity, Vector3.zero, 1f - Mathf.Exp(-PhysicalCCT.LoseControlMoveSensibility * deltaTime)); } else { // we want to move as desired velocity (InputVelocity) quickly, but not immediately BaseVelocity = Vector3.Lerp(BaseVelocity, InputVelocity, 1f - Mathf.Exp(-PhysicalCCT.ControlMoveSensibility * deltaTime)); } } else // falling { if (PhysicalCCT.CanMoveInAir) { // when dashing, moving dir is 0,0,0 var dir = MovingDirection; dir.y = 0; var horizontalBaseVelocity = dir.normalized * MoveSpeed; // when in air, don't change horizontal velocity if no input if (horizontalBaseVelocity.sqrMagnitude \u003e 0) { BaseVelocity.x = horizontalBaseVelocity.x; BaseVelocity.z = horizontalBaseVelocity.z; } } } } return BaseVelocity; } 受力运动ApplyOtherEnternalForce Addforce支持多种施力模式，和刚体类似。转化为速度后，最后在ApplyOtherEnternalForce中直接叠加到VelocityNew。\npublic void AddExternalForce(Vector3 force, ForceMode mode = ForceMode.Force) { switch (mode) { case ForceMode.Force: AdditionalForceToApply += force * DeltaTime / Mass; break; case ForceMode.Acceleration: AdditionalForceToApply += force * DeltaTime; break; case ForceMode.Impulse: AdditionalForceToApply += force / Mass; break; case ForceMode.VelocityChange: AdditionalForceToApply += force; break; default: break; } } 处理物理碰撞效果ProcessControllerHits 被推挤还是被撞飞有一个判定阈值。SolveCCTCollideWithMovableObject内部，会根据二者相碰时碰撞方向上的速度差，以及二者的质量差，决定是弹性或是非弹性碰撞。\n/// /// This is called just after CCTMove /// private void OnControllerColliderHit(ControllerColliderHit hit) { var mover = hit.gameObject.GetComponentInParent\u003cIPhysicalMover\u003e(); if (mover != null) { ControllerHitInfo projectionHit = new ControllerHitInfo(); projectionHit.HitNormal = hit.normal; projectionHit.HitPoint = hit.point; projectionHit.Mover = mover; projectionHit.CCTHitVelocity = Velocity; m_ControllerHits.Add(projectionHit); } } private void ProcessControllerHits() { for (int i = 0; i \u003c m_ControllerHits.Count; i++) { var hitInfo = m_ControllerHits[i]; if(!hitInfo.IsValid() || m_HittedMovers.Contains(hitInfo.Mover)) { continue; } m_HittedMovers.Add(hitInfo.Mover); // todo: what if Mover is other CCT/PhysicalMover float moverMass = hitInfo.Mover.GetMoverMass(); float cctMass = this.Mass; Vector3 cctVelocityDeltaAfterCollision, moverVelocityDeltaAfterCollision; bool isBounce = PhysicalContactSolver.SolveCCTCollideWithMovableObject(this, hitInfo.HitNormal, hitInfo.CCTHitVelocity, hitInfo.MoverHitVelocity, cctMass, moverMass, out cctVelocityDeltaAfterCollision, out moverVelocityDeltaAfterCollision); if (!isBounce \u0026\u0026 UseCustomPushForce) { hitInfo.Mover.AddForceAtPosition(hitInfo.HitNormal * (-CustomPushForce), ForceMode.Force, hitInfo.HitPoint); } else { VelocityNew += cctVelocityDeltaAfterCollision; hitInfo.Mover.AddForceAtPosition(moverVelocityDeltaAfterCollision, ForceMode.VelocityChange, hitInfo.HitPoint); } } } ","wordCount":"3774","inLanguage":"en","datePublished":"2024-03-18T00:00:00Z","dateModified":"2024-03-18T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/notes_on_physics_based_cct/"},"publisher":{"@type":"Organization","name":"波波沙🏠","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="波波沙🏠 (Alt + H)">波波沙🏠</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>带物理交互的CharacterController设计与实现</h1><div class=post-meta><span title='2024-03-18 00:00:00 +0000 UTC'>March 18, 2024</span>&nbsp;·&nbsp;8 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af%e5%92%8c%e9%9c%80%e6%b1%82 aria-label=背景和需求>背景和需求</a></li><li><a href=#%e6%8a%80%e6%9c%af%e8%b7%af%e7%ba%bf aria-label=技术路线>技术路线</a></li><li><a href=#%e6%a1%86%e6%9e%b6%e8%ae%be%e8%ae%a1 aria-label=框架设计>框架设计</a></li><li><a href=#%e5%85%b7%e4%bd%93%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0 aria-label=具体功能实现>具体功能实现</a><ul><li><a href=#%e7%9d%80%e5%9c%b0%e7%8a%b6%e6%80%81%e6%a3%80%e6%b5%8bgrounddetection aria-label=着地状态检测GroundDetection>着地状态检测<code>GroundDetection</code></a></li><li><a href=#%e8%90%bd%e5%9c%b0%e9%80%9f%e5%ba%a6%e4%bf%ae%e6%ad%a3fixvelocityonground aria-label=落地速度修正FixVelocityOnGround>落地速度修正<code>FixVelocityOnGround</code></a></li><li><a href=#%e7%a7%bb%e5%8a%a8%e5%b9%b3%e5%8f%b0%e8%b7%9f%e9%9a%8fcctmovewithground aria-label=移动平台跟随CCTMoveWithGround>移动平台跟随<code>CCTMoveWithGround</code></a></li><li><a href=#%e4%b8%8e%e8%be%93%e5%85%a5%e9%80%9f%e5%ba%a6%e6%b7%b7%e5%90%88blendwithinputvelocity aria-label=与输入速度混合BlendWithInputVelocity>与输入速度混合<code>BlendWithInputVelocity</code></a></li><li><a href=#%e5%8f%97%e5%8a%9b%e8%bf%90%e5%8a%a8applyotherenternalforce aria-label=受力运动ApplyOtherEnternalForce>受力运动<code>ApplyOtherEnternalForce</code></a></li><li><a href=#%e5%a4%84%e7%90%86%e7%89%a9%e7%90%86%e7%a2%b0%e6%92%9e%e6%95%88%e6%9e%9cprocesscontrollerhits aria-label=处理物理碰撞效果ProcessControllerHits>处理物理碰撞效果<code>ProcessControllerHits</code></a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>本文也是<a href=https://pps43.github.io/tags/physx/>PhysX物理引擎系列</a>的番外篇。介绍了笔者基于CharacterController(CCT)设计的一个新的角色控制器，在修补Unity/PhysX的CCT的缺陷外，还增添了若干和物理交互相关的有趣特性。代码已经过实际项目验证，这里仅保留和具体业务无关的部分。</p></blockquote><h1 id=背景和需求>背景和需求<a hidden class=anchor aria-hidden=true href=#背景和需求>#</a></h1><p><a href=https://pps43.github.io/posts/using_physx_cct/>前文</a>结尾处提到一些PhysX自带的CCT（Unity也是基于此二次封装出<code>CharacterController</code>组件）在实际游戏开发中的缺点，这里再次总结：</p><ul><li><strong>CCT不参与碰撞系统的检测</strong>。仅当CCT自身移动时会判断是否被其他刚体或CCT阻挡。这就造成一个BUG：CCT自身静止时，其他运动物体会穿过CCT且没有事件触发。<a href=https://discussions.unity.com/t/proper-collision-detection-with-charactercontroller/564371>官方论坛上有苦主</a>持续8年向Unity反馈这个问题但无法解决，目前已知的唯一绕过方式是每帧给CCT附加一个微小的位移（下文中的<code>SlightMove</code>）。</li><li><strong>Unity提供的接口<code>CharacterController.isGrounded</code>效果很不稳定</strong>。其内部只是判断CCT上次运动后底部是否触碰物体。即<code>collisionFlags & eCOLLISION_DOWN::eCOLLISION_DOWN</code>。但在上下坡或崎岖地形时，很容易出现侧面触碰或短暂浮空。如果用该接口驱动动画表现甚至跑跳逻辑，效果很差。需要自行基于SceneQuery封装出更加稳定的判定着地的函数。</li><li><strong>Unity没有暴露<code>CCT.upVector</code>，角色总是竖直向上的</strong>。要实现反重力鞋在任意斜面上行走或像<code>马里奥银河</code>那样在曲面上跑跳穿梭，只能放弃使用CCT但也放弃了其在操作手感上的改善。其实拿到Unity的源码后，只用了十分钟将底层字段暴露到C#层就解决了该问题。</li></ul><p>新的角色控制器需要增加的物理交互特性有：</p><ul><li>受力。<ul><li>既可以像传统CCT一样精准操控运动，也可以像刚体一样对其施力。</li><li>其他刚体可以对其产生推挤、撞飞效果。</li><li>自身重力可在陡坡上产生滑行效果。</li></ul></li><li>施力。运动时具有推力，自身重力可以对外做功。</li><li>重力方向。大小和方向动态可变，方向变化时可自动旋转CCT以调整姿态。</li><li>移动平台。CCT可附着在所有移动对象上跟随运动，不借助父子结构。</li></ul><p>另外CCT还支持了两种网络同步方式：服务端跟随客户端（通过校验维持服务端权威性）、客户端跟随服务端（通过外插减小延迟），并且可以动态切换。考虑到篇幅，<strong>本篇对同步算法不展开介绍</strong>。</p><h1 id=技术路线>技术路线<a hidden class=anchor aria-hidden=true href=#技术路线>#</a></h1><p>角色要实现丰富的物理交互，大体有三种思路：</p><ol><li>基于CCT，添加动力学模拟（施力、受力）。运动受控度最高，但算法复杂。</li><li>基于Kinematic刚体，添加CCT特性（<code>Collide-and-Slide</code>） 、添加动力学模拟（受力运动）。运动受控度高，但算法复杂。</li><li>基于Dynamic刚体，添加部分CCT特性。例如<code>Active Ragdoll</code>技术。运动受控度低，但逻辑简洁，且特别适合糖豆人这类休闲蠢萌角色。</li></ol><p>结合玩法类型和项目实际情况，为了最大化复用原有角色功能，最终选择了第一种思路。</p><h1 id=框架设计>框架设计<a hidden class=anchor aria-hidden=true href=#框架设计>#</a></h1><p>要模拟各类物理交互，有三个重要设计。</p><ol><li><strong>所有交互最终都转化为速度这个物理量</strong>。每帧通过融合后的总速度产生一次cctmove。具体交互包括摇杆输入、API输入、重力、摩擦、碰撞时的冲量&mldr;</li><li><strong>交互对象不限于刚体，而是所有实现了<code>IPhysicalMover</code>接口的对象</strong>。这样就将不参与刚体仿真的对象也统一起来（比如cct和被强制移动的static collider）。</li><li><strong>将交互效果的计算，分为内核与接口</strong>。内核部分<code>PhysicalCCT</code>实现了物理交互的核心计算和流程，不同业务的角色类只需实现<code>IPhysicalCharacter</code>接口部分就能受内核驱动，并定制玩法相关的效果。</li></ol><p>下面是两个接口的定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// a actor who has mass, velocity, and can add force to. (e.g. moving platform)</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>interface</span> <span class=nc>IPhysicalMover</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>GetMoverMass</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>GetMoverCenterOfRotation</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>GetMoverVelocity</span><span class=p>();</span> <span class=c1>//m/s</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>GetMoverAngularVelocity</span><span class=p>();</span> <span class=c1>//degree/s</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>force</span><span class=p>,</span> <span class=n>ForceMode</span> <span class=n>mode</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>hitPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>interface</span> <span class=nc>IPhysicalCharacter</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>BeforeCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>AfterCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Can be used to do Landing/Take off game logic based on CurrentGroundState and LastGroundState</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>AfterUpdateGroundState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Update CCT rotation according to input and game logic (e.g., change Forward to moving dir, or rotate Up to align with gravity). </span>
</span></span><span class=line><span class=cl>    <span class=cs>/// BaseRotation means auto-generated rotation if walking on the surface of a rotating platform.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Return modified Rotation.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Quaternion</span> <span class=n>UpdateRotation</span><span class=p>(</span><span class=n>Quaternion</span> <span class=n>BaseRotation</span><span class=p>,</span> <span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Update CCT velocity according to input (walk, run, jump...should have different speed) and game logic (e.g., if Dead, set velocity to zero).</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Do not add gravity inside.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Return modified Velocity.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>UpdateVelocity</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>BaseVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>OnGroundHit</span><span class=p>(</span><span class=n>Collider</span> <span class=n>hitCollider</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>hitNormal</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>hitPoint</span><span class=p>);</span> <span class=c1>// during GroundDetection</span>
</span></span><span class=line><span class=cl>    <span class=k>void</span> <span class=n>OnCollideWith</span><span class=p>(</span><span class=n>Collider</span> <span class=n>hitCollider</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面是框架调用流程。</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant Game
    participant Character
    participant PhysicalCCT
    Game-&gt;&gt;Character: FixedUpdate
    Note over Character: ...
    Character-&gt;&gt;PhysicalCCT: UpdatePhase1
    PhysicalCCT-&gt;&gt;Character: BeforeCCTUpdate
    Note over Character: ...
    Note over PhysicalCCT: GroundDetection
    PhysicalCCT-&gt;&gt;Character: OnGroundHit
    PhysicalCCT-&gt;&gt;Character: AfterUpdateGroundState
    Note over PhysicalCCT: FixVelocityOnGround
    critical GetPointVelocityOnMover
    PhysicalCCT -&gt;&gt; Mover: GetMoverVelocity
    PhysicalCCT -&gt;&gt; Mover: GetMoverAngularVelocity
    PhysicalCCT -&gt;&gt; Mover: GetMoverCenterOfRotation
    end
    Note over PhysicalCCT: CCTMoveWithGround
    Game --&gt; Mover: All movers should have moved to final pos
    Character-&gt;&gt;PhysicalCCT: UpdatePhase2
    PhysicalCCT-&gt;&gt;Character: UpdateRotation
    Note over Character: RotateWithCamera/...
    PhysicalCCT-&gt;&gt;Character: UpdateVelocity
    Note over Character: BlendWithInputVelocity/Jump/...
    Note over PhysicalCCT: ApplyGravity
    Note over PhysicalCCT: ApplyOtherExternalForce
    Note over PhysicalCCT: ClampFinalVelocity
    Note over PhysicalCCT: CCTMove
    Note over PhysicalCCT: ProcessControllerHits
    PhysicalCCT -&gt;&gt; PhysicalCCT: modify self Velocity
    PhysicalCCT -&gt;&gt; Mover: AddForceAtPosition
    PhysicalCCT -&gt;&gt; Character: OnCollideWith
    PhysicalCCT -&gt;&gt; Character: AfterCCTUpdate
    Note over Character: ...
    
</code></pre><p>框架代码示意：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=k>void</span> <span class=n>UpdatePhase1</span><span class=p>(</span><span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m_Character</span><span class=p>.</span><span class=n>BeforeCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ResetEveryFrame</span><span class=p>(</span><span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>GroundDetection</span><span class=p>();</span> <span class=c1>// may modify PositionNew if force unground</span>
</span></span><span class=line><span class=cl>    <span class=n>m_Character</span><span class=p>.</span><span class=n>AfterUpdateGroundState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>FixVelocityOnGround</span><span class=p>(</span><span class=n>deltaTime</span><span class=p>);</span> <span class=c1>// modify VelocityNew</span>
</span></span><span class=line><span class=cl>    <span class=n>CCTMoveWithGround</span><span class=p>(</span><span class=n>deltaTime</span><span class=p>)</span> <span class=c1>// modify VelocityNew, RotationNew, PositionNew</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>void</span> <span class=n>UpdatePhase2</span><span class=p>(</span><span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>RotationNew</span> <span class=p>=</span> <span class=n>m_Character</span><span class=p>.</span><span class=n>UpdateRotation</span><span class=p>(</span><span class=n>RotationNew</span><span class=p>,</span> <span class=n>gameTime</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>VelocityNew</span> <span class=p>=</span> <span class=n>m_Character</span><span class=p>.</span><span class=n>UpdateVelocity</span><span class=p>(</span><span class=n>VelocityNew</span><span class=p>,</span> <span class=n>gameTime</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// apply gravity</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>UseGravity</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>GravityDirection</span> <span class=p>*</span> <span class=n>GravityScale</span> <span class=p>*</span> <span class=n>deltaTime</span> <span class=p>*</span> <span class=n>tuningRatio</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// apply other external force</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>AdditionalForceToApply</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>AdditionalForceToApply</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>AdditionalForceToApply</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>VelocityNew</span> <span class=p>=</span> <span class=n>ClampVelocity</span><span class=p>(</span><span class=n>VelocityNew</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CurrentCollisionFlags</span> <span class=p>=</span> <span class=n>DoCCTMove</span><span class=p>(</span><span class=k>ref</span> <span class=n>PositionNew</span><span class=p>,</span> <span class=n>VelocityNew</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ProcessControllerHits</span><span class=p>();</span> <span class=c1>// may modify VelocityNew</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...</span>
</span></span><span class=line><span class=cl>    <span class=n>Velocity</span> <span class=p>=</span> <span class=n>VelocityNew</span><span class=p>;</span> <span class=c1>// for outside logic</span>
</span></span><span class=line><span class=cl>    <span class=n>m_Character</span><span class=p>.</span><span class=n>AfterCCTUpdate</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=具体功能实现>具体功能实现<a hidden class=anchor aria-hidden=true href=#具体功能实现>#</a></h1><p>下面列举几个关键功能的实现方式。</p><h2 id=着地状态检测grounddetection>着地状态检测<code>GroundDetection</code><a hidden class=anchor aria-hidden=true href=#着地状态检测grounddetection>#</a></h2><p>首先，PhysicalCCT中记录的关于着地状态的字段有：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>PhysicalCCT</span> <span class=p>:</span> <span class=n>MonoBehaviour</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//...</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Serializable]</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>struct</span> <span class=nc>GroundingState</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=kt>bool</span> <span class=n>IsGrounded</span><span class=p>;</span> <span class=c1>// todo: we can decide if on a stable ground, or on an edge.</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=n>Vector3</span> <span class=n>GroundNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=n>IPhysicalMover</span> <span class=n>Mover</span><span class=p>;</span> <span class=c1>// can be null</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=n>Vector3</span> <span class=n>MoverVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=n>Vector3</span> <span class=n>MoverAngularVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>GroundingState</span> <span class=n>CurrentGroundState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>GroundingState</span> <span class=n>LastGroundState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>const</span> <span class=kt>float</span> <span class=n>GroundDetectionBackDistance</span> <span class=p>=</span> <span class=m>0.002f</span><span class=p>;</span> <span class=c1>// avoid raycast exactly from ground. must smaller than MinGroundDetectionDistance</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>float</span> <span class=n>MinGroundDetectionDistance</span> <span class=p>=</span> <span class=m>0.005f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=n>RaycastHit</span><span class=p>[]</span> <span class=n>m_GroundDetectionBuffer</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RaycastHit</span><span class=p>[</span><span class=m>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>bool</span> <span class=n>m_ForceUnground</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>int</span> <span class=n>m_ForceUngroundReMainFrameCount</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>bool</span> <span class=n>IsLanding</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>!</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>bool</span> <span class=n>IsSliding</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>IsGroundTooSteep</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>bool</span> <span class=n>IsGrounded</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>get</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>bool</span> <span class=n>IsGroundTooSteep</span><span class=p>(</span><span class=n>GroundingState</span> <span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>state</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>float</span> <span class=n>slopeAngle</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Angle</span><span class=p>(</span><span class=n>CharacterUp</span><span class=p>,</span> <span class=n>state</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>slopeAngle</span> <span class=p>&gt;</span> <span class=m>90</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=k>false</span><span class=p>;</span><span class=c1>// meaningless</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>slopeAngle</span> <span class=p>&gt;</span> <span class=n>SlopeLimit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>流程图中<code>GroundDetection</code>内部逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>private</span> <span class=k>void</span> <span class=n>GroundDetection</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LastGroundState</span> <span class=p>=</span> <span class=n>CurrentGroundState</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>newState</span> <span class=p>=</span> <span class=k>new</span> <span class=n>GroundingState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>newState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsForcingUnGround</span><span class=p>)</span> <span class=c1>// e.g. request jump</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>m_ForceUngroundReMainFrameCount</span><span class=p>--;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>m_ForceUngroundReMainFrameCount</span> <span class=p>&lt;=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>m_ForceUnground</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>PositionNew</span> <span class=p>+=</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=n>GroundDetectionBackDistance</span><span class=p>;</span> <span class=c1>// ensure next frame</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>groundLayerMask</span> <span class=p>=</span> <span class=n>PhysicsUtil</span><span class=p>.</span><span class=n>GetLayerMask</span><span class=p>(...);</span> <span class=c1>// use your own layer mask</span>
</span></span><span class=line><span class=cl>        <span class=n>RaycastHit</span> <span class=n>closestSweepHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>startPos</span> <span class=p>=</span> <span class=n>PositionNew</span> <span class=p>+</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=n>GroundDetectionBackDistance</span><span class=p>;</span> <span class=c1>//add a little offset to avoid raycast exactly from ground</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>distance</span> <span class=p>=</span> <span class=n>MinGroundDetectionDistance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>DetectionDirection</span> <span class=p>=</span> <span class=p>-</span><span class=n>CharacterUp</span><span class=p>;</span> <span class=c1>// not GravityDirection, because &#34;OnGround&#34; means stand on feet</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>isHit</span> <span class=p>=</span> <span class=n>CCTSweep</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>DetectionDirection</span><span class=p>,</span> <span class=n>distance</span><span class=p>,</span> <span class=n>groundLayerMask</span><span class=p>,</span> <span class=k>out</span> <span class=n>closestSweepHit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>isHit</span> <span class=p>&amp;&amp;</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span> <span class=p>!=</span> <span class=k>null</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span><span class=p>.</span><span class=n>isTrigger</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>newState</span><span class=p>.</span><span class=n>IsGrounded</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>Vector3</span> <span class=n>hitPos</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>RaycastHit</span> <span class=n>closestRaycastHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>extraDistance</span> <span class=p>=</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Max</span><span class=p>(</span><span class=n>Radius</span><span class=p>,</span> <span class=n>StepOffset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>CCTRaycast</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>DetectionDirection</span><span class=p>,</span> <span class=n>distance</span> <span class=p>+</span> <span class=n>extraDistance</span><span class=p>,</span> <span class=n>groundLayerMask</span><span class=p>,</span> <span class=k>out</span> <span class=n>closestRaycastHit</span><span class=p>))</span> <span class=c1>// more precise</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>GroundNormal</span> <span class=p>=</span> <span class=n>closestRaycastHit</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>=</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span><span class=p>.</span><span class=n>gameObject</span><span class=p>.</span><span class=n>GetComponentInParent</span><span class=p>&lt;</span><span class=n>IPhysicalMover</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>                <span class=n>hitPos</span> <span class=p>=</span> <span class=n>closestRaycastHit</span><span class=p>.</span><span class=n>point</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=c1>// fallback</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>GroundNormal</span> <span class=p>=</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>=</span> <span class=n>closestSweepHit</span><span class=p>.</span><span class=n>collider</span><span class=p>.</span><span class=n>gameObject</span><span class=p>.</span><span class=n>GetComponentInParent</span><span class=p>&lt;</span><span class=n>IPhysicalMover</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>                <span class=n>hitPos</span> <span class=p>=</span> <span class=n>PositionNew</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>newState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>pressure</span> <span class=p>=</span> <span class=n>GravityDirection</span> <span class=p>*</span> <span class=n>GravityScale</span> <span class=p>*</span> <span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>newState</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>pressure</span><span class=p>,</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>,</span> <span class=n>hitPos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CurrentGroundState</span> <span class=p>=</span> <span class=n>newState</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>m_sweep_point1</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>m_sweep_point2</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>m_sweep_direction</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>m_sweep_distance</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>m_sweep_radius</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=kt>bool</span> <span class=n>CCTSweep</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>position</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>direction</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distance</span><span class=p>,</span> <span class=kt>int</span> <span class=n>layermask</span><span class=p>,</span> <span class=k>out</span> <span class=n>RaycastHit</span> <span class=n>closestHit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>closestHit</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RaycastHit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>distance</span> <span class=p>&lt;=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>distance</span> <span class=p>+=</span> <span class=n>SkinWidth</span><span class=p>;</span> <span class=c1>// must add skinwidth, since capsulecast m_sweep_point1 is hemi-sphere center, not capsule foot position</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>bias</span> <span class=p>=</span> <span class=n>Height</span> <span class=p>*</span> <span class=m>0.5f</span> <span class=p>-</span> <span class=n>Radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_point1</span> <span class=p>=</span> <span class=n>position</span> <span class=p>+</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=p>(</span><span class=n>CenterOffset</span><span class=p>.</span><span class=n>y</span> <span class=p>-</span> <span class=n>bias</span><span class=p>);</span> <span class=c1>// foot hemi-sphere center</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_point2</span> <span class=p>=</span> <span class=n>position</span> <span class=p>+</span> <span class=n>CharacterUp</span> <span class=p>*</span> <span class=p>(</span><span class=n>CenterOffset</span><span class=p>.</span><span class=n>y</span> <span class=p>+</span> <span class=n>bias</span><span class=p>);</span> <span class=c1>// head hemi-sphere center</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_distance</span> <span class=p>=</span> <span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_radius</span> <span class=p>=</span> <span class=n>Radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>m_sweep_direction</span> <span class=p>=</span> <span class=n>direction</span><span class=p>.</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>m_sweep_direction</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&lt;=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Debugger</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=s>&#34;Invalid sweep direction:&#34;</span> <span class=p>+</span> <span class=n>direction</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=s>&#34;G3&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numberOfHits</span> <span class=p>=</span> <span class=n>Physics</span><span class=p>.</span><span class=n>CapsuleCastNonAlloc</span><span class=p>(</span><span class=n>m_sweep_point1</span><span class=p>,</span> <span class=n>m_sweep_point2</span><span class=p>,</span> <span class=n>m_sweep_radius</span><span class=p>,</span> <span class=n>m_sweep_direction</span><span class=p>,</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>,</span> <span class=n>m_sweep_distance</span><span class=p>,</span> <span class=n>layermask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//find closest hit</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>foundValidHit</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=kt>float</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>numberOfHits</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>hit</span> <span class=p>=</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&lt;</span> <span class=n>closestHitDistance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHit</span> <span class=p>=</span> <span class=n>hit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>foundValidHit</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>foundValidHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=kt>bool</span> <span class=n>CCTRaycast</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>position</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>direction</span><span class=p>,</span> <span class=kt>float</span> <span class=n>distance</span><span class=p>,</span> <span class=kt>int</span> <span class=n>layermask</span><span class=p>,</span> <span class=k>out</span> <span class=n>RaycastHit</span> <span class=n>closestHit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>closestHit</span> <span class=p>=</span> <span class=k>new</span> <span class=n>RaycastHit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numberOfHits</span> <span class=p>=</span> <span class=n>Physics</span><span class=p>.</span><span class=n>RaycastNonAlloc</span><span class=p>(</span><span class=n>position</span><span class=p>,</span> <span class=n>direction</span><span class=p>,</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>,</span> <span class=n>distance</span><span class=p>,</span> <span class=n>layermask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//find closest hit</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>foundValidHit</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=kt>float</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>numberOfHits</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>hit</span> <span class=p>=</span> <span class=n>m_GroundDetectionBuffer</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span> <span class=p>&lt;</span> <span class=n>closestHitDistance</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHitDistance</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>distance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>closestHit</span> <span class=p>=</span> <span class=n>hit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>foundValidHit</span> <span class=p>=</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>foundValidHit</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=落地速度修正fixvelocityonground>落地速度修正<code>FixVelocityOnGround</code><a hidden class=anchor aria-hidden=true href=#落地速度修正fixvelocityonground>#</a></h2><p>这一步的目的是防止落地后弹跳等不自然表现，以及向上冲陡坡时的限制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>private</span> <span class=k>void</span> <span class=n>FixVelocityOnGround</span><span class=p>(</span><span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(!</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>VelocityNew</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsLanding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span> <span class=c1>// no jump up</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>vRight</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Cross</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>tangentDir</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Cross</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>,</span> <span class=n>vRight</span><span class=p>).</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>tangentDir</span> <span class=p>*</span> <span class=n>tempVelocity</span><span class=p>.</span><span class=n>magnitude</span><span class=p>;</span> <span class=c1>// reorient velocity along ground tangent</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsSliding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>slidingAcceleration</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>GravityDirection</span> <span class=p>*</span> <span class=n>GravityScale</span><span class=p>,</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ForbidUphillMovementWhenSliding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>slidingProjection</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Dot</span><span class=p>(</span><span class=n>tempVelocity</span><span class=p>,</span> <span class=n>slidingAcceleration</span><span class=p>.</span><span class=n>normalized</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>slidingProjection</span> <span class=p>&lt;</span> <span class=m>0</span><span class=p>)</span> <span class=c1>// has uphill velocity</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// discard uphill velocity</span>
</span></span><span class=line><span class=cl>                <span class=n>tempVelocity</span> <span class=p>-=</span> <span class=n>slidingProjection</span> <span class=p>*</span> <span class=n>slidingAcceleration</span><span class=p>.</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>tempVelocity</span> <span class=p>+=</span>  <span class=n>slidingAcceleration</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>VelocityNew</span> <span class=p>=</span> <span class=n>tempVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Discard velocity that is perpendicular to the hit normal from v</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=n>Vector3</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>v</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>planeNormal</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>v</span> <span class=p>-</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Dot</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>planeNormal</span><span class=p>)</span> <span class=p>*</span> <span class=n>planeNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=移动平台跟随cctmovewithground>移动平台跟随<code>CCTMoveWithGround</code><a hidden class=anchor aria-hidden=true href=#移动平台跟随cctmovewithground>#</a></h2><p>此时已经获得了着地状态，如果脚下是移动平台，需要处理跟随运动、以及跳进跳出时的惯性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>MoverVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>MoverAngularVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>GetPointVelocityFromPhysicalMover</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>Mover</span><span class=p>,</span> <span class=n>PositionNew</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>,</span> <span class=k>out</span> <span class=n>MoverVelocity</span><span class=p>,</span> <span class=k>out</span> <span class=n>MoverAngularVelocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span> <span class=p>=</span> <span class=n>MoverVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverAngularVelocityAtPosition</span> <span class=p>=</span> <span class=n>MoverAngularVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// jump between different moving grounds</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=k>null</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=n>LastGroundState</span><span class=p>.</span><span class=n>Mover</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>LastGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>-=</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// do not bump when landing</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>LastGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>==</span> <span class=k>null</span> <span class=p>&amp;&amp;</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>Mover</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>VelocityNew</span> <span class=p>-=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// rotate with mover</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverAngularVelocityAtPosition</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>newForward</span> <span class=p>=</span> <span class=n>Quaternion</span><span class=p>.</span><span class=n>Euler</span><span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverAngularVelocityAtPosition</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>)</span> <span class=p>*</span> <span class=n>CharacterForward</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>newForward</span> <span class=p>=</span> <span class=n>ProjectVectorToPlane</span><span class=p>(</span><span class=n>newForward</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>).</span><span class=n>normalized</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>RotationNew</span> <span class=p>=</span> <span class=n>Quaternion</span><span class=p>.</span><span class=n>LookRotation</span><span class=p>(</span><span class=n>newForward</span><span class=p>,</span> <span class=n>CharacterUp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// translate with mover</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DoCCTMove</span><span class=p>(</span><span class=k>ref</span> <span class=n>PositionNew</span><span class=p>,</span> <span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>MoverVelocityAtPosition</span><span class=p>,</span> <span class=n>deltaTime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Turn on SlightMove when user is not moving, this is to detect collision</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=n>CollisionFlags</span> <span class=n>DoCCTMove</span><span class=p>(</span><span class=k>ref</span> <span class=n>Vector3</span> <span class=n>position</span><span class=p>,</span> <span class=n>Vector3</span> <span class=n>velocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>noiseMovemet</span> <span class=p>=</span> <span class=n>MinMoveDistance</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>?</span> <span class=n>MinMoveDistance</span> <span class=p>:</span> <span class=m>0.001f</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>movement</span> <span class=p>=</span> <span class=n>SlightMove</span> <span class=p>?</span> <span class=n>noiseMovemet</span> <span class=p>*</span> <span class=n>CharacterForward</span> <span class=p>:</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>velocity</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>movement</span> <span class=p>=</span> <span class=n>velocity</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>flags</span> <span class=p>=</span> <span class=n>m_CCT</span><span class=p>.</span><span class=n>Move</span><span class=p>(</span><span class=n>movement</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>position</span> <span class=p>=</span> <span class=n>m_CCT</span><span class=p>.</span><span class=n>transform</span><span class=p>.</span><span class=n>position</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=与输入速度混合blendwithinputvelocity>与输入速度混合<code>BlendWithInputVelocity</code><a hidden class=anchor aria-hidden=true href=#与输入速度混合blendwithinputvelocity>#</a></h2><p>这一步是在实现接口函数<code>UpdateVelocity</code>时，将传入的<code>BaseVelocity</code>和读取到的玩家输入进行混合，包括处理跳跃、空中移动等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>Vector3</span> <span class=n>IPhysicalCharacter</span><span class=p>.</span><span class=n>UpdateVelocity</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>BaseVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>gameTime</span><span class=p>,</span> <span class=kt>float</span> <span class=n>deltaTime</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Vector3</span> <span class=n>originalV</span> <span class=p>=</span> <span class=n>BaseVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// handle jump separately</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>RequestJump</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>RequestJump</span> <span class=p>=</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span> <span class=p>&lt;</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpMaxCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>float</span> <span class=n>jumpupSpeed</span> <span class=p>=</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Sqrt</span><span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpHeight</span> <span class=p>*</span> <span class=m>2</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>GravityScale</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>+=</span> <span class=n>jumpupSpeed</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>ForceUnground</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// when second jump, it reset BaseVelocity along CharacterUp direction, rather than add to BaseVelocity</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>cutVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Dot</span><span class=p>(</span><span class=n>BaseVelocity</span><span class=p>,</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>)</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>restVelocity</span> <span class=p>=</span> <span class=n>BaseVelocity</span> <span class=p>-</span> <span class=n>cutVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>=</span> <span class=n>restVelocity</span> <span class=p>+</span> <span class=n>jumpupSpeed</span> <span class=p>*</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>InputVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>IsGrounded</span><span class=p>)</span> <span class=c1>// standing, walking, running</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>JumpCount</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=c1>// reset jump count</span>
</span></span><span class=line><span class=cl>            <span class=n>InputVelocity</span> <span class=p>=</span> <span class=n>MovingDirection</span> <span class=p>*</span> <span class=n>MoveSpeed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// rotate InputVelocity onto ground plane, only if IsSliding false</span>
</span></span><span class=line><span class=cl>            <span class=n>Vector3</span> <span class=n>groundNormal</span> <span class=p>=</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CurrentGroundState</span><span class=p>.</span><span class=n>GroundNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>InputVelocity</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>groundNormal</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>InputVelocity</span> <span class=p>=</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>ReorientVelocityToPlane</span><span class=p>(</span><span class=n>InputVelocity</span><span class=p>,</span> <span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CharacterUp</span><span class=p>,</span> <span class=n>groundNormal</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// assign BaseVelocity with InputVelocity</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>IsSliding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// usually we don&#39;t want to lose control immediately, but gradually</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>+=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Lerp</span><span class=p>(</span><span class=n>InputVelocity</span><span class=p>,</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>zero</span><span class=p>,</span> <span class=m>1f</span> <span class=p>-</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Exp</span><span class=p>(-</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>LoseControlMoveSensibility</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// we want to move as desired velocity (InputVelocity) quickly, but not immediately</span>
</span></span><span class=line><span class=cl>                <span class=n>BaseVelocity</span> <span class=p>=</span> <span class=n>Vector3</span><span class=p>.</span><span class=n>Lerp</span><span class=p>(</span><span class=n>BaseVelocity</span><span class=p>,</span> <span class=n>InputVelocity</span><span class=p>,</span> <span class=m>1f</span> <span class=p>-</span> <span class=n>Mathf</span><span class=p>.</span><span class=n>Exp</span><span class=p>(-</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>ControlMoveSensibility</span> <span class=p>*</span> <span class=n>deltaTime</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=c1>// falling</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>PhysicalCCT</span><span class=p>.</span><span class=n>CanMoveInAir</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// when dashing, moving dir is 0,0,0</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>dir</span> <span class=p>=</span> <span class=n>MovingDirection</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>dir</span><span class=p>.</span><span class=n>y</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>var</span> <span class=n>horizontalBaseVelocity</span> <span class=p>=</span> <span class=n>dir</span><span class=p>.</span><span class=n>normalized</span> <span class=p>*</span> <span class=n>MoveSpeed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=c1>// when in air, don&#39;t change horizontal velocity if no input</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>horizontalBaseVelocity</span><span class=p>.</span><span class=n>sqrMagnitude</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>BaseVelocity</span><span class=p>.</span><span class=n>x</span> <span class=p>=</span> <span class=n>horizontalBaseVelocity</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>BaseVelocity</span><span class=p>.</span><span class=n>z</span> <span class=p>=</span> <span class=n>horizontalBaseVelocity</span><span class=p>.</span><span class=n>z</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>BaseVelocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=受力运动applyotherenternalforce>受力运动<code>ApplyOtherEnternalForce</code><a hidden class=anchor aria-hidden=true href=#受力运动applyotherenternalforce>#</a></h2><p>Addforce支持多种施力模式，和刚体类似。转化为速度后，最后在<code>ApplyOtherEnternalForce</code>中直接叠加到<code>VelocityNew</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=k>void</span> <span class=n>AddExternalForce</span><span class=p>(</span><span class=n>Vector3</span> <span class=n>force</span><span class=p>,</span> <span class=n>ForceMode</span> <span class=n>mode</span> <span class=p>=</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>mode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span> <span class=p>*</span> <span class=n>DeltaTime</span> <span class=p>/</span> <span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Acceleration</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span> <span class=p>*</span> <span class=n>DeltaTime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Impulse</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span> <span class=p>/</span> <span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>VelocityChange</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>AdditionalForceToApply</span> <span class=p>+=</span> <span class=n>force</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=处理物理碰撞效果processcontrollerhits>处理物理碰撞效果<code>ProcessControllerHits</code><a hidden class=anchor aria-hidden=true href=#处理物理碰撞效果processcontrollerhits>#</a></h2><p>被推挤还是被撞飞有一个判定阈值。<code>SolveCCTCollideWithMovableObject</code>内部，会根据二者相碰时碰撞方向上的速度差，以及二者的质量差，决定是弹性或是非弹性碰撞。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// This is called just after CCTMove</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>void</span> <span class=n>OnControllerColliderHit</span><span class=p>(</span><span class=n>ControllerColliderHit</span> <span class=n>hit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>mover</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>gameObject</span><span class=p>.</span><span class=n>GetComponentInParent</span><span class=p>&lt;</span><span class=n>IPhysicalMover</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mover</span> <span class=p>!=</span> <span class=k>null</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ControllerHitInfo</span> <span class=n>projectionHit</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ControllerHitInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>HitNormal</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>normal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>HitPoint</span> <span class=p>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>point</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>Mover</span> <span class=p>=</span> <span class=n>mover</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>projectionHit</span><span class=p>.</span><span class=n>CCTHitVelocity</span> <span class=p>=</span> <span class=n>Velocity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>m_ControllerHits</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>projectionHit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>void</span> <span class=n>ProcessControllerHits</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>m_ControllerHits</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>hitInfo</span> <span class=p>=</span> <span class=n>m_ControllerHits</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(!</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>IsValid</span><span class=p>()</span> <span class=p>||</span> <span class=n>m_HittedMovers</span><span class=p>.</span><span class=n>Contains</span><span class=p>(</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_HittedMovers</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// todo: what if Mover is other CCT/PhysicalMover</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>moverMass</span> <span class=p>=</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>GetMoverMass</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>float</span> <span class=n>cctMass</span> <span class=p>=</span> <span class=k>this</span><span class=p>.</span><span class=n>Mass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Vector3</span> <span class=n>cctVelocityDeltaAfterCollision</span><span class=p>,</span> <span class=n>moverVelocityDeltaAfterCollision</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>isBounce</span> <span class=p>=</span> <span class=n>PhysicalContactSolver</span><span class=p>.</span><span class=n>SolveCCTCollideWithMovableObject</span><span class=p>(</span><span class=k>this</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=n>hitInfo</span><span class=p>.</span><span class=n>HitNormal</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>CCTHitVelocity</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>MoverHitVelocity</span><span class=p>,</span> <span class=n>cctMass</span><span class=p>,</span> <span class=n>moverMass</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=k>out</span> <span class=n>cctVelocityDeltaAfterCollision</span><span class=p>,</span> <span class=k>out</span> <span class=n>moverVelocityDeltaAfterCollision</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(!</span><span class=n>isBounce</span> <span class=p>&amp;&amp;</span> <span class=n>UseCustomPushForce</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>hitInfo</span><span class=p>.</span><span class=n>HitNormal</span> <span class=p>*</span> <span class=p>(-</span><span class=n>CustomPushForce</span><span class=p>),</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>Force</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>HitPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>VelocityNew</span> <span class=p>+=</span> <span class=n>cctVelocityDeltaAfterCollision</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>hitInfo</span><span class=p>.</span><span class=n>Mover</span><span class=p>.</span><span class=n>AddForceAtPosition</span><span class=p>(</span><span class=n>moverVelocityDeltaAfterCollision</span><span class=p>,</span> <span class=n>ForceMode</span><span class=p>.</span><span class=n>VelocityChange</span><span class=p>,</span> <span class=n>hitInfo</span><span class=p>.</span><span class=n>HitPoint</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li><li><a href=https://pps43.github.io/tags/unity/>Unity</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/unite2024_wechatminigame/><span class=title>« Prev</span><br><span>WebGL平台的性能限制和解决方案（以微信小游戏为例）</span></a>
<a class=next href=https://pps43.github.io/posts/using_physx_cct/><span class=title>Next »</span><br><span>PhysX物理引擎（4）Character Controller</span></a></nav></footer></article></main><footer class=footer><span>© 2016-2023 By 波波沙.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>