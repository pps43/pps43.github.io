<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysX零值Crash | 波波沙🏠</title><meta name=keywords content="Game Dev,PhysX"><meta name=description content="本文是PhysX物理引擎系列的特别篇，记录了影响近一周的物理引擎底层概率性Crash的定位过程和修复方法，具有很高的实践参考价值。“有多高？"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_solving_zero_value_crash/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="PhysX零值Crash"><meta property="og:description" content="本文是PhysX物理引擎系列的特别篇，记录了影响近一周的物理引擎底层概率性Crash的定位过程和修复方法，具有很高的实践参考价值。“有多高？"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/using_physx_solving_zero_value_crash/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-13T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-13T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysX零值Crash"><meta name=twitter:description content="本文是PhysX物理引擎系列的特别篇，记录了影响近一周的物理引擎底层概率性Crash的定位过程和修复方法，具有很高的实践参考价值。“有多高？"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"PhysX零值Crash","item":"https://pps43.github.io/posts/using_physx_solving_zero_value_crash/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysX零值Crash","name":"PhysX零值Crash","description":"本文是PhysX物理引擎系列的特别篇，记录了影响近一周的物理引擎底层概率性Crash的定位过程和修复方法，具有很高的实践参考价值。“有多高？","keywords":["Game Dev","PhysX"],"articleBody":" 本文是PhysX物理引擎系列的特别篇，记录了影响近一周的物理引擎底层概率性Crash的定位过程和修复方法，具有很高的实践参考价值。“有多高？”“三四层楼那么高啦！”\n发现问题 运维同事发现体验服和某区在新版本上线一小段时间后，会出现概率不高但持续出现的进程Crash。这里先简单说明一下：我们会在一台机器上部署多个GameServer实例，每个GameServer实例进程同时进行着多场不同的Match，如果某一场Match出现了业务层Crash，并不会影响其他Match。但如果是C++物理库内出现Crash，则会同时中止其他正常运行的Match，对玩家的影响较大。\n虽然看不到完整的堆栈，但从中还是发现和物理引擎的SceneQuery有关。 其实还有另一个很相似的堆栈（忘记保存截图了）在prefilter上方还有一行NpShape vtable...。由于prefilter实现逻辑中确实调用了shape.getFlags()，所以怀疑是跟shape相关逻辑中出现空指针引用。但由于shape是引擎内部维护的，所以上述怀疑并不能提供明确的修复方法。\n// prefilter implementaion PxQueryHitType::Enum PhysxQueryFilterCallback::preFilter(const PxFilterData\u0026 filterData, const PxShape* shape, const PxRigidActor* actor, PxHitFlags\u0026 queryFlags) { bool isTrigger = shape-\u003egetFlags() \u0026 physx::PxShapeFlag::eTRIGGER_SHAPE; if (isTrigger \u0026\u0026 !m_IncludeTrigger) { return PxQueryHitType::eNONE; } PxFilterData shapefilterData = shape-\u003egetQueryFilterData(); if (shapefilterData.word0 \u0026 filterData.word0) { // m_HitType should be PxQueryHitType::eBLOCK or PxQueryHitType::eTOUCH return m_HitType; } return PxQueryHitType::eNONE; } // shape-\u003egetFlags() implementation (fron physx source code) PxShapeFlags NpShape::getFlags() const { NP_READ_CHECK(getOwnerScene()); return mShape.getFlags(); } 由于同期发布的还有其他物理相关功能，先通过开关这些功能来对Crash做初步判定。有一个延迟删除Actor的优化较为可疑，关闭该功能后，Crash确实减少了一小部分。\n另外也尝试通过分析日志对这些Crash发生的情境做猜测，便于复现。前面提到过，物理层一旦Crash会影响到该进程下其他正常进行的比赛。所以只好抓取了Crash发生前200ms的所有相关比赛的日志，大致能看出最后几秒内玩家进行了哪些操作：商店购买、切换武器、伤害扣血、扔手雷。这里只有扔手雷和物理层有关联，进一步找到该场比赛的模式信息，告诉QA同学尝试复现。\n第一次尝试修复 测试环境中一直未能复现，所以先尝试了一些防御性判空修复。比如在每帧驱动物理更新时，对Scene的判空；又比如在OnContact时，增加了对actor和shape失效状态的判断，并且获取actor的方式由pairs[i].shapes[0]-\u003egetActor()改为pairHeader.actors[0]。这些修复确实能加强程序的健壮性，但可惜对本次的Crash并没有直接帮助。\nvoid PhysxSimulationEventCallback::onContact(const PxContactPairHeader\u0026 pairHeader, const PxContactPair* pairs, PxU32 nbPairs) { // add actor validation if (pairHeader.flags \u0026 PxContactPairHeaderFlag::eREMOVED_ACTOR_0 || pairHeader.flags \u0026 PxContactPairHeaderFlag::eREMOVED_ACTOR_1) { return; } PxRigidActor* actorA = (PxRigidActor*)pairHeader.actors[0]; PxRigidActor* actorB = (PxRigidActor*)pairHeader.actors[1]; for (PxU32 i = 0; i \u003c nbPairs; i++) { const PxContactPair\u0026 curPair = pairs[i]; // add shape validation if (curPair.flags \u0026 (PxContactPairFlag::eREMOVED_SHAPE_0 | PxContactPairFlag::eREMOVED_SHAPE_1)) { continue; } if (curPair.events \u0026 PxPairFlag::eNOTIFY_TOUCH_PERSISTS) { // do nothing when contact persists } else { PhysXContactResult result; result.Lost = curPair.events \u0026 PxPairFlag::eNOTIFY_TOUCH_LOST; result.ColliderA = actorA == NULL ? NULL : (PhysXActor*) actorA-\u003euserData; result.ColliderB = actorB == NULL ? NULL : (PhysXActor*) actorB-\u003euserData; if (result.ColliderA != NULL \u0026\u0026 result.ColliderB != NULL) { m_ContactRecords.push_back(result); } } } } 第二次尝试修复 为了获取更多信息，决定费一些周章，在一台线上机器部署Debug版物理库。事实证明，这个努力是值得的、立竿见影的。\n平时服务器程序打Release包时，链接到Release版的物理库工程（底层使用了physX）：\npackage physxgo /* #cgo CPPFLAGS: -Wno-attributes -I ./include -O3 -DNDEBUG #cgo LDFLAGS:-L ./lib -lPhysXWrapper_x64 -O3 */ import \"C 现改为链接到Debug版物理库工程：\npackage physxgo /* #cgo CPPFLAGS: -Wno-attributes -I ./include -O1 -DNDEBUG #cgo LDFLAGS:-L ./lib -lPhysXWrapperDEBUG_x64 -O1 */ import \"C\" 在本地Windows上测试通过后，部署到Linux却失败了：发现依然链接到Release物理库。\n这里稍加说明：服务器是Linux的，但为了平时能在Windows上开发调试物理库，我们搭建了两套构建流程。在Linux上使用makefile编译出.so，在Windows上构建出.dll供cgo调用。注意cgo使用gcc，由于name mangling方式和MSVC不同，在使用MSVC编译时需要在.def文件中指定每个导出的函数编译后的名字，形如x=y，这样MSVC会把自己编出的y翻译成x，以便和gcc兼容。\n举例：_ZN10PhysXActor11SetPositionEfff=?SetPosition@PhysXActor@@QEAAXMMM@Z\n原因是go build是强制使用了配置的环境变量以及缓存。使用go build -d清空缓存即可。\n成功部署Debug包到一台服务器上后，过15min就Crash了，在最后一刻传递出了新的信息：\n创建shape时参数不合法，首先怀疑传入了0或NaN。进一步的排查发现，这个版本使用了新版的创建函数，确实相比老的创建流程少了一个参数合法性校验。当发现某个维度出现0值时，虽然不会立即Crash，但在后续被Raycast等操作访问到时，会概率性Crash。解决方法很简单，在业务层已有代码中，发现传入0时给出警告并return；在底层代码中创建shape时，强制将值为0的维度改为一个微小的值，如下ForceNonZero。\nvoid ForceNonZero() { //EPS = 1.192092896e-07F (machine epsilon for float) if (physx::PxAbs(x) \u003c EPS) { x = x \u003e= 0 ? EPS : -EPS; } if (physx::PxAbs(y) \u003c EPS) { y = y \u003e= 0 ? EPS : -EPS; } if (physx::PxAbs(z) \u003c EPS) { z = z \u003e= 0 ? EPS : -EPS; } } 部署该修复后，Crash归零。\n并且通过Debug版给出的警告，我们还对数值类参数做了NaN或Inf校验physx::PxIsFinite，并且对方向类参数做了强制归一化，进一步提高了物理系统稳定性。值此，修复完成。\n总结 对于传入physX的参数必须严格保证有效性。\n基本要求：数值类不可以是NaN, Inf 尺寸类不可以是0 方向类矢量必须模长为1 平时开发中多关注Debug版的输出，对于警告和错误都要高度重视。\n问题发生时，如果传统的定位、复现问遇到困难，不妨考虑部署Debug版到线上环境，获取更多信息。\n","wordCount":"2208","inLanguage":"en","datePublished":"2023-06-13T00:00:00Z","dateModified":"2023-06-13T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_solving_zero_value_crash/"},"publisher":{"@type":"Organization","name":"波波沙🏠","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="波波沙🏠 (Alt + H)">波波沙🏠</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PhysX零值Crash</h1><div class=post-meta><span title='2023-06-13 00:00:00 +0000 UTC'>June 13, 2023</span>&nbsp;·&nbsp;5 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%8f%91%e7%8e%b0%e9%97%ae%e9%a2%98 aria-label=发现问题>发现问题</a></li><li><a href=#%e7%ac%ac%e4%b8%80%e6%ac%a1%e5%b0%9d%e8%af%95%e4%bf%ae%e5%a4%8d aria-label=第一次尝试修复>第一次尝试修复</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e6%ac%a1%e5%b0%9d%e8%af%95%e4%bf%ae%e5%a4%8d aria-label=第二次尝试修复>第二次尝试修复</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><blockquote><p>本文是<a href=https://pps43.github.io/tags/physx/>PhysX物理引擎系列</a>的特别篇，记录了影响近一周的物理引擎底层概率性Crash的定位过程和修复方法，具有<strong>很高</strong>的实践参考价值。<em>“有多高？”“三四层楼那么高啦！”</em></p></blockquote><h1 id=发现问题>发现问题<a hidden class=anchor aria-hidden=true href=#发现问题>#</a></h1><p>运维同事发现体验服和某区在新版本上线一小段时间后，会出现概率不高但持续出现的进程Crash。这里先简单说明一下：我们会在一台机器上部署多个GameServer实例，每个GameServer实例进程同时进行着多场不同的Match，如果某一场Match出现了业务层Crash，并不会影响其他Match。但如果是C++物理库内出现Crash，则会同时中止其他正常运行的Match，对玩家的影响较大。</p><p>虽然看不到完整的堆栈，但从中还是发现和物理引擎的<code>SceneQuery</code>有关。
<img loading=lazy src=/using_physx_solving_zero_value_crash/crash_log.png alt></p><p>其实还有另一个很相似的堆栈（忘记保存截图了）在<code>prefilter</code>上方还有一行<code>NpShape vtable...</code>。由于<code>prefilter</code>实现逻辑中确实调用了<code>shape.getFlags()</code>，所以怀疑是跟<code>shape</code>相关逻辑中出现空指针引用。但由于shape是引擎内部维护的，所以上述怀疑并不能提供明确的修复方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// prefilter implementaion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>Enum</span> <span class=n>PhysxQueryFilterCallback</span><span class=o>::</span><span class=n>preFilter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxFilterData</span><span class=o>&amp;</span> <span class=n>filterData</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actor</span><span class=p>,</span> <span class=n>PxHitFlags</span><span class=o>&amp;</span> <span class=n>queryFlags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>isTrigger</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>physx</span><span class=o>::</span><span class=n>PxShapeFlag</span><span class=o>::</span><span class=n>eTRIGGER_SHAPE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>isTrigger</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>m_IncludeTrigger</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PxFilterData</span> <span class=n>shapefilterData</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>shapefilterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData</span><span class=p>.</span><span class=n>word0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// m_HitType should be PxQueryHitType::eBLOCK or PxQueryHitType::eTOUCH
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=n>m_HitType</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>PxQueryHitType</span><span class=o>::</span><span class=n>eNONE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// shape-&gt;getFlags() implementation (fron physx source code)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PxShapeFlags</span> <span class=n>NpShape</span><span class=o>::</span><span class=n>getFlags</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>NP_READ_CHECK</span><span class=p>(</span><span class=n>getOwnerScene</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>mShape</span><span class=p>.</span><span class=n>getFlags</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于同期发布的还有其他物理相关功能，先通过开关这些功能来对Crash做初步判定。有一个延迟删除Actor的优化较为可疑，关闭该功能后，Crash确实减少了一小部分。</p><p>另外也尝试通过分析日志对这些Crash发生的情境做猜测，便于复现。前面提到过，物理层一旦Crash会影响到该进程下其他正常进行的比赛。所以只好抓取了Crash发生前200ms的所有相关比赛的日志，大致能看出最后几秒内玩家进行了哪些操作：商店购买、切换武器、伤害扣血、扔手雷。这里只有扔手雷和物理层有关联，进一步找到该场比赛的模式信息，告诉QA同学尝试复现。</p><h1 id=第一次尝试修复>第一次尝试修复<a hidden class=anchor aria-hidden=true href=#第一次尝试修复>#</a></h1><p>测试环境中一直未能复现，所以先尝试了一些防御性判空修复。比如在每帧驱动物理更新时，对Scene的判空；又比如在<code>OnContact</code>时，增加了对<code>actor</code>和<code>shape</code>失效状态的判断，并且获取<code>actor</code>的方式由<code>pairs[i].shapes[0]->getActor()</code>改为<code>pairHeader.actors[0]</code>。这些修复确实能加强程序的健壮性，但可惜对本次的Crash并没有直接帮助。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>PhysxSimulationEventCallback</span><span class=o>::</span><span class=n>onContact</span><span class=p>(</span><span class=k>const</span> <span class=n>PxContactPairHeader</span><span class=o>&amp;</span> <span class=n>pairHeader</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxContactPair</span><span class=o>*</span> <span class=n>pairs</span><span class=p>,</span> <span class=n>PxU32</span> <span class=n>nbPairs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// add actor validation
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>pairHeader</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>PxContactPairHeaderFlag</span><span class=o>::</span><span class=n>eREMOVED_ACTOR_0</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>		<span class=n>pairHeader</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>PxContactPairHeaderFlag</span><span class=o>::</span><span class=n>eREMOVED_ACTOR_1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actorA</span> <span class=o>=</span> <span class=p>(</span><span class=n>PxRigidActor</span><span class=o>*</span><span class=p>)</span><span class=n>pairHeader</span><span class=p>.</span><span class=n>actors</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>actorB</span> <span class=o>=</span> <span class=p>(</span><span class=n>PxRigidActor</span><span class=o>*</span><span class=p>)</span><span class=n>pairHeader</span><span class=p>.</span><span class=n>actors</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>PxU32</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nbPairs</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>PxContactPair</span><span class=o>&amp;</span> <span class=n>curPair</span> <span class=o>=</span> <span class=n>pairs</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// add shape validation
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>curPair</span><span class=p>.</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>PxContactPairFlag</span><span class=o>::</span><span class=n>eREMOVED_SHAPE_0</span> <span class=o>|</span> <span class=n>PxContactPairFlag</span><span class=o>::</span><span class=n>eREMOVED_SHAPE_1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>curPair</span><span class=p>.</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_PERSISTS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>// do nothing when contact persists
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=k>else</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>PhysXContactResult</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>result</span><span class=p>.</span><span class=n>Lost</span> <span class=o>=</span> <span class=n>curPair</span><span class=p>.</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>PxPairFlag</span><span class=o>::</span><span class=n>eNOTIFY_TOUCH_LOST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>result</span><span class=p>.</span><span class=n>ColliderA</span> <span class=o>=</span> <span class=n>actorA</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span> <span class=n>actorA</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>result</span><span class=p>.</span><span class=n>ColliderB</span> <span class=o>=</span> <span class=n>actorB</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=p>(</span><span class=n>PhysXActor</span><span class=o>*</span><span class=p>)</span> <span class=n>actorB</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>ColliderA</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>result</span><span class=p>.</span><span class=n>ColliderB</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>m_ContactRecords</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=第二次尝试修复>第二次尝试修复<a hidden class=anchor aria-hidden=true href=#第二次尝试修复>#</a></h1><p>为了获取更多信息，决定费一些周章，在一台线上机器部署Debug版物理库。事实证明，这个努力是值得的、立竿见影的。</p><p>平时服务器程序打Release包时，链接到Release版的物理库工程（底层使用了<code>physX</code>）：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>physxgo</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>#cgo CPPFLAGS: -Wno-attributes -I ./include -O3 -DNDEBUG
</span></span></span><span class=line><span class=cl><span class=cm>#cgo LDFLAGS:-L ./lib -lPhysXWrapper_x64 -O3
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=err>&#34;</span><span class=nx>C</span>
</span></span></code></pre></div><p>现改为链接到Debug版物理库工程：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>physxgo</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>#cgo CPPFLAGS: -Wno-attributes -I ./include -O1 -DNDEBUG
</span></span></span><span class=line><span class=cl><span class=cm>#cgo LDFLAGS:-L ./lib -lPhysXWrapperDEBUG_x64 -O1
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;C&#34;</span>
</span></span></code></pre></div><p>在本地Windows上测试通过后，部署到Linux却失败了：发现依然链接到Release物理库。</p><blockquote><p>这里稍加说明：服务器是Linux的，但为了平时能在Windows上开发调试物理库，我们搭建了两套构建流程。在Linux上使用makefile编译出<code>.so</code>，在Windows上构建出<code>.dll</code>供<code>cgo</code>调用。注意<code>cgo</code>使用<code>gcc</code>，由于name mangling方式和<code>MSVC</code>不同，在使用<code>MSVC</code>编译时需要在<code>.def</code>文件中指定每个导出的函数编译后的名字，形如<code>x=y</code>，这样<code>MSVC</code>会把自己编出的<code>y</code>翻译成<code>x</code>，以便和<code>gcc</code>兼容。</p><p>举例：<code>_ZN10PhysXActor11SetPositionEfff=?SetPosition@PhysXActor@@QEAAXMMM@Z</code></p></blockquote><p>原因是<code>go build</code>是强制使用了配置的环境变量以及缓存。使用<code>go build -d</code>清空缓存即可。</p><p>成功部署Debug包到一台服务器上后，过15min就Crash了，在最后一刻传递出了新的信息：</p><p><img loading=lazy src=/using_physx_solving_zero_value_crash/crash_log_2.png alt></p><p>创建shape时参数不合法，首先怀疑传入了0或NaN。进一步的排查发现，这个版本使用了新版的创建函数，确实相比老的创建流程少了一个参数合法性校验。当发现某个维度出现0值时，虽然不会立即Crash，但在后续被Raycast等操作访问到时，会概率性Crash。解决方法很简单，在业务层已有代码中，发现传入0时给出警告并return；在底层代码中创建shape时，强制将值为0的维度改为一个微小的值，如下<code>ForceNonZero</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ForceNonZero</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>//EPS = 1.192092896e-07F (machine epsilon for float)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>physx</span><span class=o>::</span><span class=n>PxAbs</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>EPS</span><span class=p>)</span> <span class=p>{</span> <span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>?</span> <span class=nl>EPS</span> <span class=p>:</span> <span class=o>-</span><span class=n>EPS</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>physx</span><span class=o>::</span><span class=n>PxAbs</span><span class=p>(</span><span class=n>y</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>EPS</span><span class=p>)</span> <span class=p>{</span> <span class=n>y</span> <span class=o>=</span> <span class=n>y</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>?</span> <span class=nl>EPS</span> <span class=p>:</span> <span class=o>-</span><span class=n>EPS</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>physx</span><span class=o>::</span><span class=n>PxAbs</span><span class=p>(</span><span class=n>z</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>EPS</span><span class=p>)</span> <span class=p>{</span> <span class=n>z</span> <span class=o>=</span> <span class=n>z</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>?</span> <span class=nl>EPS</span> <span class=p>:</span> <span class=o>-</span><span class=n>EPS</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>部署该修复后，Crash归零。</p><p><img loading=lazy src=/using_physx_solving_zero_value_crash/crash_over.png alt></p><p>并且通过Debug版给出的警告，我们还对数值类参数做了NaN或Inf校验<code>physx::PxIsFinite</code>，并且对方向类参数做了强制归一化，进一步提高了物理系统稳定性。值此，修复完成。</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><ul><li><p>对于传入<code>physX</code>的参数必须严格保证有效性。</p><ul><li>基本要求：数值类不可以是NaN, Inf</li><li>尺寸类不可以是0</li><li>方向类矢量必须模长为1</li></ul></li><li><p>平时开发中多关注Debug版的输出，对于警告和错误都要高度重视。</p></li><li><p>问题发生时，如果传统的定位、复现问遇到困难，不妨考虑部署Debug版到线上环境，获取更多信息。</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/notes_on_genius_in_ghibli/><span class=title>« Prev</span><br><span>吉卜力的天才们（铃木敏夫）</span></a>
<a class=next href=https://pps43.github.io/posts/notes_on_why_buddhism_is_true/><span class=title>Next »</span><br><span>洞见·为什么佛学是真的</span></a></nav></footer></article></main><footer class=footer><span>© 2016-2023 By 波波沙.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>