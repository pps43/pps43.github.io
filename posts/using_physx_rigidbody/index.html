<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics | Ê≥¢Ê≥¢Ê≤ôüè†</title>
<meta name=keywords content="Game Dev,PhysX"><meta name=description content="
Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ
PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ
Warm-up
Let&rsquo;s start with some key concepts:

Both Kinematic and Dynamic rigidbodies are represented as PxRigidDynamic in PhysX. You can switch between them at runtime using PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true).
Kinematic and Static actors remain stationary unless explicitly moved in code.
Moving Static actors can result in incorrect collision behavior with dynamic actors.
When moving Kinematic actors, always use PxRigidDynamic::setKinematicTarget each frame instead of PxRigidActor::setGlobalPose to ensure correct collision detection with dynamic actors.

This post focuses on dynamic rigidbody movement, covering topics such as force and torque, gravity, sleeping, and more."><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_rigidbody/><link crossorigin=anonymous href=/assets/css/stylesheet.da461cdc6aa5b1045299cab0ebd07edbb2f1e481e0c7ae775d260fc5af887327.css integrity="sha256-2kYc3GqlsQRSmcqw69B+27Lx5IHgx653XSYPxa+Icyc=" rel="preload stylesheet" as=style><link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://pps43.github.io/posts/using_physx_rigidbody/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script><script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL")}</script><meta property="og:url" content="https://pps43.github.io/posts/using_physx_rigidbody/"><meta property="og:site_name" content="Ê≥¢Ê≥¢Ê≤ôüè†"><meta property="og:title" content="PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics"><meta property="og:description" content=" Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ
PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ
Warm-up Let‚Äôs start with some key concepts:
Both Kinematic and Dynamic rigidbodies are represented as PxRigidDynamic in PhysX. You can switch between them at runtime using PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true). Kinematic and Static actors remain stationary unless explicitly moved in code. Moving Static actors can result in incorrect collision behavior with dynamic actors. When moving Kinematic actors, always use PxRigidDynamic::setKinematicTarget each frame instead of PxRigidActor::setGlobalPose to ensure correct collision detection with dynamic actors. This post focuses on dynamic rigidbody movement, covering topics such as force and torque, gravity, sleeping, and more."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-04T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T00:00:00+00:00"><meta property="article:tag" content="Game Dev"><meta property="article:tag" content="PhysX"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics"><meta name=twitter:description content="
Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ
PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ
Warm-up
Let&rsquo;s start with some key concepts:

Both Kinematic and Dynamic rigidbodies are represented as PxRigidDynamic in PhysX. You can switch between them at runtime using PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true).
Kinematic and Static actors remain stationary unless explicitly moved in code.
Moving Static actors can result in incorrect collision behavior with dynamic actors.
When moving Kinematic actors, always use PxRigidDynamic::setKinematicTarget each frame instead of PxRigidActor::setGlobalPose to ensure correct collision detection with dynamic actors.

This post focuses on dynamic rigidbody movement, covering topics such as force and torque, gravity, sleeping, and more."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":2,"name":"PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics","item":"https://pps43.github.io/posts/using_physx_rigidbody/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics","name":"PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics","description":" Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ\nPhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ\nWarm-up Let\u0026rsquo;s start with some key concepts:\nBoth Kinematic and Dynamic rigidbodies are represented as PxRigidDynamic in PhysX. You can switch between them at runtime using PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true). Kinematic and Static actors remain stationary unless explicitly moved in code. Moving Static actors can result in incorrect collision behavior with dynamic actors. When moving Kinematic actors, always use PxRigidDynamic::setKinematicTarget each frame instead of PxRigidActor::setGlobalPose to ensure correct collision detection with dynamic actors. This post focuses on dynamic rigidbody movement, covering topics such as force and torque, gravity, sleeping, and more.\n","keywords":["Game Dev","PhysX"],"articleBody":" Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ\nPhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ\nWarm-up Let‚Äôs start with some key concepts:\nBoth Kinematic and Dynamic rigidbodies are represented as PxRigidDynamic in PhysX. You can switch between them at runtime using PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true). Kinematic and Static actors remain stationary unless explicitly moved in code. Moving Static actors can result in incorrect collision behavior with dynamic actors. When moving Kinematic actors, always use PxRigidDynamic::setKinematicTarget each frame instead of PxRigidActor::setGlobalPose to ensure correct collision detection with dynamic actors. This post focuses on dynamic rigidbody movement, covering topics such as force and torque, gravity, sleeping, and more.\nBelow are the essential physical concepts with their mathematical formulas:\nTranslation formular Rotation formular Position \\(\\vec{x}\\) Orientation (3x3 matrix) \\(\\mathbf{R}\\) Linear Velocity \\(\\vec{v}=\\frac{d\\vec{x}}{dt}\\) Angular Velocity \\(\\vec{\\omega}=\\frac{\\vec{v}\\times\\vec{r}}{\\lVert{\\vec{r}}\\rVert^2}\\) Linear Acceleration \\(\\vec{a}=\\frac{d\\vec{v}}{dt}\\) Angular Acceleration \\(\\vec{\\alpha}=\\frac{d\\vec{\\omega}}{dt}\\) Mass \\(M=\\sum{m_i}\\) Intertia tensor \\(\\mathbf{I}=\\mathbf{R}\\mathbf{I}_0\\mathbf{R}^T\\) Linear momententum \\(\\vec{p}=M\\vec{v}\\) Angular momententum \\(\\vec{L}=\\mathbf{I}\\vec{\\omega}\\) Force \\(\\vec{F}=\\frac{d\\vec{p}}{dt}=m\\vec{a}\\) Torque \\(\\vec{\\tau}=\\frac{d\\vec{L}}{dt}\\) Setup Rigidbody A dynamic actor has 3 mass-related properties: mass, center of mass, and inertia tensor.\nSetting mass to 0 means it cannot move. Although the documentation suggests 0 is acceptable for mass, it actually causes random crashes. See Golden Tips for details.\nCenter of mass is the point where applied forces generate translation without rotation. It‚Äôs defined in local space as a Vector3, with a default value of (0,0,0).\nMoment of inertia is a scalar value describing the resistance to rotation about a specific axis, while the inertia tensor is a 3x3 matrix describing resistance to rotation about any axis. Setting the inertia tensor to (0,0,0) prevents rotation around any axis.\nThe simplest way to calculate mass properties is to use PxRigidBodyExt::updateMassAndInertia. You don‚Äôt need setMassAndUpdateInertia.\nIn the official North Pole demo (PhysX_3.4\\Samples\\SampleNorthPole\\SampleNorthPoleDynamics.cpp), all objects have a low center of mass but use different configurations to achieve varied physical behaviors.\nHere‚Äôs my code snippet for initializing a dynamic rigidbody:\nvoid ActorWrapper::InitRigidbody(bool useGravity, float mass, const PxVec3\u0026 centerOfMass, const PxVec3\u0026 interiaTensor, const PxVec3\u0026 velocity, float drag, const PxVec3\u0026 angularVelocity, float maxAngularVelocity, float angularDrag, int constrainFlags) { PxRigidDynamic* actor = PxActorAs\u003cPxRigidDynamic\u003e(); if (actor == NULL || actor-\u003egetScene() == NULL) { return; } actor-\u003esetActorFlag(PxActorFlag::eDISABLE_GRAVITY, !useGravity); actor-\u003esetMaxAngularVelocity(maxAngularVelocity); //SetConstrains (todo) actor-\u003esetLinearDamping(drag); angularDrag = PxMax(0.01f, angularDrag); // 0 is unstable for angular drag actor-\u003esetAngularDamping(angularDrag); actor-\u003esetMass(mass); actor-\u003esetCMassLocalPose(PxTransform(centerOfMass)); actor-\u003esetMassSpaceInertiaTensor(interiaTensor); // not kinematic if (!(actor-\u003egetRigidBodyFlags() \u0026 PxRigidBodyFlag::eKINEMATIC)) { // if has constrain, modify velocity here actor-\u003esetLinearVelocity(velocity); actor-\u003esetAngularVelocity(angularVelocity); } } void ActorWrapper::SetDensity(float density) { PxRigidDynamic* actor = PxActorAs\u003cPxRigidDynamic\u003e(); if (actor == NULL || actor-\u003egetScene() == NULL) { return; } density = PxClamp(density, 0.0f, 1e6f); PxRigidBodyExt::updateMassAndInertia(*actor, density); } Fix Large Mass When a rigidbody with large mass (\u003e 100kg) collides with other objects (e.g., static ground), the simulation can quickly become unrealistic or even collapse.\nThe image below shows 5 rigidbodies falling to the ground with masses of 1kg, 10kg, 100kg, 1000kg, and 10,000kg (from left to right). There are several parameters you can tune to stabilize the simulation. The configuration below can boost the maximum supported mass from ~400kg to ~3800kg:\nScene-level\nsceneDesc.flags |= PxSceneFlag::eENABLE_PCM - PCM (Persistent Contact Manifold) makes objects more stable when at rest. sceneDesc.flags |= PxSceneFlag::eADAPTIVE_FORCE - Adaptive force makes stacked objects more stable. Actor-level\nPxRigidDynamic::setSolverIterationCounts(32,8) - This is the most significant change for stability, though it comes at a performance cost. PxRigidbody::setMaxDepenetrationVelocity(10) - This prevents excessive velocity during collision resolution. Shape-level\nPxShape::setContactOffset(0.02) - PhysX will resolve collisions earlier, improving stability. Add Force \u0026 Torque addForce causes translation addTorque causes rotation addForceAtPos causes both translation and rotation if the position is not at the center of mass Both force and torque support 4 modes:\nPxForceMode Physics Equivalent eFORCE \\(ma\\) eIMPULSE \\(mat\\) eVELOCITY_CHANGE \\(at\\) eACCELERATION \\(a\\) Here‚Äôs my code snippet for implementing addForce and addTorque:\nvoid ActorWrapper::AddForce(const PxVec3\u0026 force, int forceMode) { // validation if (force.IsAllZero() || !force.IsFinite()) { return; } PxRigidDynamic* actor = GetRigidDynamicActor(); if (actor == NULL || actor-\u003egetScene() == NULL || (actor-\u003egetRigidBodyFlags() \u0026 PxRigidBodyFlag::eKINEMATIC)) { return; } actor-\u003eaddForce(force, forceMode); } void ActorWrapper::AddRelativeForce(const PxVec3\u0026 force, int forceMode) { // same validation as AddForce PxVec3 globalForce = actor-\u003egetGlobalPose().rotate(localForce); actor-\u003eaddForce(globalForce, forceMode); } void ActorWrapper::AddTorque(const PxVec3\u0026 torque, int forceMode) { // same validation as AddForce actor-\u003eaddTorque(torque, forceMode); } void ActorWrapper::AddRelativeTorque(const PxVec3\u0026 torque, int forceMode) { // same validation as AddForce PxVec3 globalTorque = actor-\u003egetGlobalPose().rotate(torque); actor-\u003eaddForce(globalForce, forceMode); } void ActorWrapper::UGCAddForceAtPosition(const PxVec3\u0026 force, int forceMode, const PxVec3\u0026 position) { // same validation as AddForce if (!position.IsFinite()) { return; } // Only eFORCE and eIMPULSE are supported! if (forceMode == PxForceMode::eFORCE || forceMode == PxForceMode::eIMPULSE) { PxRigidBodyExt::addForceAtPos(*actor, force, position); } } Change Gravity Gravity is scene-wide for all dynamic rigidbodies and is set using PxScene::setGravity().\nYou can exclude specific dynamic actors from scene-wide gravity by calling PxActor::setActorFlag(PxActorFlag::eDISABLE_GRAVITY, true). Then manually apply forces each frame using addForce to implement custom gravity for that actor.\nSleep \u0026 Awake Why Sleep Matters Sleeping rigidbodies have virtually no performance cost. Putting less important rigidbodies to sleep can significantly reduce CPU usage, especially when dealing with thousands of objects.\nSleep Mechanism An actor goes to sleep when its mass-normalized kinetic energy (i.e., \\(\\frac{1}{2}v^2\\)) remains below a threshold for a certain duration. Internally, PhysX uses a wake-counter; when it reaches 0, the actor becomes a candidate for sleeping.\nThe default threshold is \\(5‚àó10^{‚àí5}‚àóv^2\\), where \\(v\\) is PxTolerancesScale.velocity. This means actors are allowed to sleep when their velocity drops below 1% of PxTolerancesScale.velocity. You can customize this threshold using PxRigidDynamic::setSleepThreshold.\nYou can also directly control the wake-counter using PxRigidDynamic::setWakeCounter.\nCommon APIs for sleeping (only for dynamic actors):\nName Notes PxRigidDynamic::setSleepThreshold Set the energy threshold for sleeping PxRigidDynamic::setWakeCounter Calling on a sleeping rigidbody will automatically wake it up PxRigidDynamic::isSleeping() Check if the actor is currently sleeping PxRigidDynamic::wakeUp() Force the actor to wake up PxRigidDynamic::putToSleep() Force the actor to sleep PxSimulationEventCallback::onWake/onSleep To receive these events, set the flag: PxActorFlag::eSEND_SLEEP_NOTIFIES Awake Mechanism The following actions will wake an actor up:\nCalling PxRigidDynamic::setKinematicTarget() on a kinematic actor Calling PxRigidActor::setGlobalPose() with the autowake parameter set to true (default) Raising the PxActorFlag::eDISABLE_SIMULATION flag Calling PxScene::resetFiltering() Calling PxShape::setSimulationFilterData() that results in a different filtering outcome Contact with an actor that is awake A touching rigid actor is removed from the scene Loss of contact with a static rigid actor Loss of contact with a dynamic rigid actor (wakes up in the next simulation step) Being hit by a two-way interaction particle Golden Tips When calling PxRigidBodyExt::setMassAndUpdateInertia(actor, mass), ensure mass is above zero for dynamic rigidbodies, otherwise random crashes will occur during collisions. When calling PxRigidDynamic::setAngularDamping(value), ensure value is above zero, otherwise rotation becomes unstable. Changing the scene-wide gravity value will NOT automatically wake sleeping rigidbodies. Call PxRigidDynamic::wakeUp() manually if needed. ","wordCount":"1181","inLanguage":"en","datePublished":"2023-09-04T00:00:00Z","dateModified":"2023-09-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_rigidbody/"},"publisher":{"@type":"Organization","name":"Ê≥¢Ê≥¢Ê≤ôüè†","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io/ accesskey=h title="Ê≥¢Ê≥¢Ê≤ôüè† (Alt + H)">Ê≥¢Ê≥¢Ê≤ôüè†</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics</h1><div class=post-meta><span title='2023-09-04 00:00:00 +0000 UTC'>September 4, 2023</span>&nbsp;¬∑&nbsp;3 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#warm-up aria-label=Warm-up>Warm-up</a></li><li><a href=#setup-rigidbody aria-label="Setup Rigidbody">Setup Rigidbody</a></li><li><a href=#fix-large-mass aria-label="Fix Large Mass">Fix Large Mass</a></li><li><a href=#add-force--torque aria-label="Add Force & Torque">Add Force & Torque</a></li><li><a href=#change-gravity aria-label="Change Gravity">Change Gravity</a></li><li><a href=#sleep--awake aria-label="Sleep & Awake">Sleep & Awake</a><ul><li><a href=#why-sleep-matters aria-label="Why Sleep Matters">Why Sleep Matters</a></li><li><a href=#sleep-mechanism aria-label="Sleep Mechanism">Sleep Mechanism</a></li><li><a href=#awake-mechanism aria-label="Awake Mechanism">Awake Mechanism</a></li></ul></li><li><a href=#golden-tips aria-label="Golden Tips">Golden Tips</a></li></ul></div></details></div><div class=post-content><blockquote><p>Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ</p><p><a href=https://pps43.github.io/tags/physx/>PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàó</a>ËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºà<a href=https://github.com/pps43/PhysX-3.4>Code</a>, <a href=https://github.com/pps43/PhysX-3.4/raw/master/PhysX_3.4/Documentation/PhysXGuide.chm>Doc</a>ÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ</p></blockquote><h1 id=warm-up>Warm-up<a hidden class=anchor aria-hidden=true href=#warm-up>#</a></h1><p>Let&rsquo;s start with some key concepts:</p><ul><li>Both <code>Kinematic</code> and <code>Dynamic</code> rigidbodies are represented as <code>PxRigidDynamic</code> in PhysX. You can switch between them at runtime using <code>PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true)</code>.</li><li><code>Kinematic</code> and <code>Static</code> actors remain stationary unless explicitly moved in code.</li><li>Moving <code>Static</code> actors can result in incorrect collision behavior with dynamic actors.</li><li>When moving <code>Kinematic</code> actors, always use <code>PxRigidDynamic::setKinematicTarget</code> each frame instead of <code>PxRigidActor::setGlobalPose</code> to ensure correct collision detection with dynamic actors.</li></ul><p>This post focuses on dynamic rigidbody movement, covering topics such as <strong>force and torque, gravity, sleeping</strong>, and more.</p><p>Below are the essential physical concepts with their mathematical formulas:</p><table><thead><tr><th>Translation</th><th>formular</th><th>Rotation</th><th>formular</th></tr></thead><tbody><tr><td>Position</td><td>\(\vec{x}\)</td><td>Orientation (3x3 matrix)</td><td>\(\mathbf{R}\)</td></tr><tr><td>Linear Velocity</td><td>\(\vec{v}=\frac{d\vec{x}}{dt}\)</td><td>Angular Velocity</td><td>\(\vec{\omega}=\frac{\vec{v}\times\vec{r}}{\lVert{\vec{r}}\rVert^2}\)</td></tr><tr><td>Linear Acceleration</td><td>\(\vec{a}=\frac{d\vec{v}}{dt}\)</td><td>Angular Acceleration</td><td>\(\vec{\alpha}=\frac{d\vec{\omega}}{dt}\)</td></tr><tr><td>Mass</td><td>\(M=\sum{m_i}\)</td><td>Intertia tensor</td><td>\(\mathbf{I}=\mathbf{R}\mathbf{I}_0\mathbf{R}^T\)</td></tr><tr><td>Linear momententum</td><td>\(\vec{p}=M\vec{v}\)</td><td>Angular momententum</td><td>\(\vec{L}=\mathbf{I}\vec{\omega}\)</td></tr><tr><td>Force</td><td>\(\vec{F}=\frac{d\vec{p}}{dt}=m\vec{a}\)</td><td>Torque</td><td>\(\vec{\tau}=\frac{d\vec{L}}{dt}\)</td></tr></tbody></table><h1 id=setup-rigidbody>Setup Rigidbody<a hidden class=anchor aria-hidden=true href=#setup-rigidbody>#</a></h1><p>A dynamic actor has 3 mass-related properties: <strong>mass</strong>, <strong>center of mass</strong>, and <strong>inertia tensor</strong>.</p><blockquote><p><del>Setting <strong>mass</strong> to 0 means it cannot move.</del> Although the documentation suggests 0 is acceptable for mass, it actually causes random crashes. See <a href=/posts/using_physx_rigidbody/#golden-tips>Golden Tips</a> for details.</p><p><strong>Center of mass</strong> is the point where applied forces generate translation without rotation. It&rsquo;s defined in local space as a Vector3, with a default value of (0,0,0).</p><p><strong>Moment of inertia</strong> is a scalar value describing the resistance to rotation about a specific axis, while the <strong>inertia tensor</strong> is a 3x3 matrix describing resistance to rotation about any axis. Setting the <strong>inertia tensor</strong> to (0,0,0) prevents rotation around any axis.</p></blockquote><p>The simplest way to calculate mass properties is to use <code>PxRigidBodyExt::updateMassAndInertia</code>. You don&rsquo;t need <code>setMassAndUpdateInertia</code>.</p><p>In the official <code>North Pole</code> demo (<code>PhysX_3.4\Samples\SampleNorthPole\SampleNorthPoleDynamics.cpp</code>), all objects have a low center of mass but use different configurations to achieve varied physical behaviors.</p><p>Here&rsquo;s my code snippet for initializing a dynamic rigidbody:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>InitRigidbody</span><span class=p>(</span><span class=kt>bool</span> <span class=n>useGravity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>mass</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>centerOfMass</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>interiaTensor</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>velocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>drag</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>angularVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>maxAngularVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>angularDrag</span><span class=p>,</span> <span class=kt>int</span> <span class=n>constrainFlags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidDynamic</span><span class=o>*</span> <span class=n>actor</span> <span class=o>=</span> <span class=n>PxActorAs</span><span class=o>&lt;</span><span class=n>PxRigidDynamic</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>actor</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getScene</span><span class=p>()</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setActorFlag</span><span class=p>(</span><span class=n>PxActorFlag</span><span class=o>::</span><span class=n>eDISABLE_GRAVITY</span><span class=p>,</span> <span class=o>!</span><span class=n>useGravity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setMaxAngularVelocity</span><span class=p>(</span><span class=n>maxAngularVelocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    <span class=c1>//SetConstrains (todo)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setLinearDamping</span><span class=p>(</span><span class=n>drag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>angularDrag</span> <span class=o>=</span> <span class=n>PxMax</span><span class=p>(</span><span class=mf>0.01f</span><span class=p>,</span> <span class=n>angularDrag</span><span class=p>);</span> <span class=c1>// 0 is unstable for angular drag
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setAngularDamping</span><span class=p>(</span><span class=n>angularDrag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setMass</span><span class=p>(</span><span class=n>mass</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setCMassLocalPose</span><span class=p>(</span><span class=n>PxTransform</span><span class=p>(</span><span class=n>centerOfMass</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setMassSpaceInertiaTensor</span><span class=p>(</span><span class=n>interiaTensor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// not kinematic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>getRigidBodyFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eKINEMATIC</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if has constrain, modify velocity here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>actor</span><span class=o>-&gt;</span><span class=n>setLinearVelocity</span><span class=p>(</span><span class=n>velocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>setAngularVelocity</span><span class=p>(</span><span class=n>angularVelocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>SetDensity</span><span class=p>(</span><span class=kt>float</span> <span class=n>density</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRigidDynamic</span><span class=o>*</span> <span class=n>actor</span> <span class=o>=</span> <span class=n>PxActorAs</span><span class=o>&lt;</span><span class=n>PxRigidDynamic</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>actor</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getScene</span><span class=p>()</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>density</span> <span class=o>=</span> <span class=n>PxClamp</span><span class=p>(</span><span class=n>density</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>,</span> <span class=mf>1e6</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRigidBodyExt</span><span class=o>::</span><span class=n>updateMassAndInertia</span><span class=p>(</span><span class=o>*</span><span class=n>actor</span><span class=p>,</span> <span class=n>density</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=fix-large-mass>Fix Large Mass<a hidden class=anchor aria-hidden=true href=#fix-large-mass>#</a></h1><p>When a rigidbody with large mass (> 100kg) collides with other objects (e.g., static ground), the simulation can quickly become unrealistic or even collapse.</p><blockquote><p>The image below shows 5 rigidbodies falling to the ground with masses of 1kg, 10kg, 100kg, 1000kg, and 10,000kg (from left to right).
<img loading=lazy src=/using_physx_rigidbody/large_mass_simulation_pvd.png></p></blockquote><p>There are several parameters you can tune to stabilize the simulation. The configuration below can boost the maximum supported mass from ~400kg to ~3800kg:</p><ul><li><p><strong>Scene-level</strong></p><ul><li><code>sceneDesc.flags |= PxSceneFlag::eENABLE_PCM</code> - PCM (Persistent Contact Manifold) makes objects more stable when at rest.</li><li><code>sceneDesc.flags |= PxSceneFlag::eADAPTIVE_FORCE</code> - Adaptive force makes stacked objects more stable.</li></ul></li><li><p><strong>Actor-level</strong></p><ul><li><code>PxRigidDynamic::setSolverIterationCounts(32,8)</code> - This is the most significant change for stability, though it comes at a performance cost.</li><li><code>PxRigidbody::setMaxDepenetrationVelocity(10)</code> - This prevents excessive velocity during collision resolution.</li></ul></li><li><p><strong>Shape-level</strong></p><ul><li><code>PxShape::setContactOffset(0.02)</code> - PhysX will resolve collisions earlier, improving stability.</li></ul></li></ul><h1 id=add-force--torque>Add Force & Torque<a hidden class=anchor aria-hidden=true href=#add-force--torque>#</a></h1><ul><li><code>addForce</code> causes translation</li><li><code>addTorque</code> causes rotation</li><li><code>addForceAtPos</code> causes both translation and rotation if the position is not at the center of mass</li></ul><p>Both force and torque support 4 modes:</p><table><thead><tr><th>PxForceMode</th><th>Physics Equivalent</th></tr></thead><tbody><tr><td>eFORCE</td><td>\(ma\)</td></tr><tr><td>eIMPULSE</td><td>\(mat\)</td></tr><tr><td>eVELOCITY_CHANGE</td><td>\(at\)</td></tr><tr><td>eACCELERATION</td><td>\(a\)</td></tr></tbody></table><p>Here&rsquo;s my code snippet for implementing addForce and addTorque:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddForce</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>force</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// validation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>force</span><span class=p>.</span><span class=n>IsAllZero</span><span class=p>()</span> <span class=o>||</span> <span class=o>!</span><span class=n>force</span><span class=p>.</span><span class=n>IsFinite</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRigidDynamic</span><span class=o>*</span> <span class=n>actor</span> <span class=o>=</span> <span class=n>GetRigidDynamicActor</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>actor</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getScene</span><span class=p>()</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=p>(</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>getRigidBodyFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eKINEMATIC</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addForce</span><span class=p>(</span><span class=n>force</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddRelativeForce</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>force</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>PxVec3</span> <span class=n>globalForce</span> <span class=o>=</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getGlobalPose</span><span class=p>().</span><span class=n>rotate</span><span class=p>(</span><span class=n>localForce</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addForce</span><span class=p>(</span><span class=n>globalForce</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddTorque</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>torque</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addTorque</span><span class=p>(</span><span class=n>torque</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddRelativeTorque</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>torque</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>PxVec3</span> <span class=n>globalTorque</span> <span class=o>=</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getGlobalPose</span><span class=p>().</span><span class=n>rotate</span><span class=p>(</span><span class=n>torque</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addForce</span><span class=p>(</span><span class=n>globalForce</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>UGCAddForceAtPosition</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>force</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>position</span><span class=p>.</span><span class=n>IsFinite</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Only eFORCE and eIMPULSE are supported!
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>forceMode</span> <span class=o>==</span> <span class=n>PxForceMode</span><span class=o>::</span><span class=n>eFORCE</span> <span class=o>||</span> <span class=n>forceMode</span> <span class=o>==</span> <span class=n>PxForceMode</span><span class=o>::</span><span class=n>eIMPULSE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PxRigidBodyExt</span><span class=o>::</span><span class=n>addForceAtPos</span><span class=p>(</span><span class=o>*</span><span class=n>actor</span><span class=p>,</span> <span class=n>force</span><span class=p>,</span> <span class=n>position</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=change-gravity>Change Gravity<a hidden class=anchor aria-hidden=true href=#change-gravity>#</a></h1><p>Gravity is scene-wide for all dynamic rigidbodies and is set using <code>PxScene::setGravity()</code>.</p><p>You can exclude specific dynamic actors from scene-wide gravity by calling <code>PxActor::setActorFlag(PxActorFlag::eDISABLE_GRAVITY, true)</code>. Then manually apply forces each frame using <code>addForce</code> to implement custom gravity for that actor.</p><h1 id=sleep--awake>Sleep & Awake<a hidden class=anchor aria-hidden=true href=#sleep--awake>#</a></h1><h2 id=why-sleep-matters>Why Sleep Matters<a hidden class=anchor aria-hidden=true href=#why-sleep-matters>#</a></h2><p>Sleeping rigidbodies have virtually no performance cost. Putting less important rigidbodies to sleep can significantly reduce CPU usage, especially when dealing with thousands of objects.</p><h2 id=sleep-mechanism>Sleep Mechanism<a hidden class=anchor aria-hidden=true href=#sleep-mechanism>#</a></h2><p>An actor goes to sleep when its mass-normalized kinetic energy (i.e., \(\frac{1}{2}v^2\)) remains <strong>below a threshold for a certain duration</strong>. Internally, PhysX uses a wake-counter; when it reaches 0, the actor becomes a candidate for sleeping.</p><p>The default threshold is \(5‚àó10^{‚àí5}‚àóv^2\), where \(v\) is <code>PxTolerancesScale.velocity</code>. This means actors are allowed to sleep when their velocity drops below 1% of <code>PxTolerancesScale.velocity</code>. You can customize this threshold using <code>PxRigidDynamic::setSleepThreshold</code>.</p><p>You can also directly control the wake-counter using <code>PxRigidDynamic::setWakeCounter</code>.</p><p>Common APIs for sleeping (only for dynamic actors):</p><table><thead><tr><th>Name</th><th>Notes</th></tr></thead><tbody><tr><td>PxRigidDynamic::setSleepThreshold</td><td>Set the energy threshold for sleeping</td></tr><tr><td>PxRigidDynamic::setWakeCounter</td><td>Calling on a sleeping rigidbody will automatically wake it up</td></tr><tr><td>PxRigidDynamic::isSleeping()</td><td>Check if the actor is currently sleeping</td></tr><tr><td>PxRigidDynamic::wakeUp()</td><td>Force the actor to wake up</td></tr><tr><td>PxRigidDynamic::putToSleep()</td><td>Force the actor to sleep</td></tr><tr><td>PxSimulationEventCallback::onWake/onSleep</td><td>To receive these events, set the flag: <code>PxActorFlag::eSEND_SLEEP_NOTIFIES</code></td></tr></tbody></table><h2 id=awake-mechanism>Awake Mechanism<a hidden class=anchor aria-hidden=true href=#awake-mechanism>#</a></h2><p>The following actions will wake an actor up:</p><ul><li>Calling <code>PxRigidDynamic::setKinematicTarget()</code> on a kinematic actor</li><li>Calling <code>PxRigidActor::setGlobalPose()</code> with the autowake parameter set to true (default)</li><li>Raising the <code>PxActorFlag::eDISABLE_SIMULATION</code> flag</li><li>Calling <code>PxScene::resetFiltering()</code></li><li>Calling <code>PxShape::setSimulationFilterData()</code> that results in a different filtering outcome</li><li>Contact with an actor that is awake</li><li>A touching rigid actor is removed from the scene</li><li>Loss of contact with a static rigid actor</li><li>Loss of contact with a dynamic rigid actor (wakes up in the next simulation step)</li><li>Being hit by a two-way interaction particle</li></ul><h1 id=golden-tips>Golden Tips<a hidden class=anchor aria-hidden=true href=#golden-tips>#</a></h1><ul><li>When calling <code>PxRigidBodyExt::setMassAndUpdateInertia(actor, mass)</code>, ensure <code>mass</code> is <strong>above zero</strong> for dynamic rigidbodies, otherwise random crashes will occur during collisions.</li><li>When calling <code>PxRigidDynamic::setAngularDamping(value)</code>, ensure <code>value</code> is <strong>above zero</strong>, otherwise rotation becomes unstable.</li><li>Changing the scene-wide gravity value will <strong>NOT</strong> automatically wake sleeping rigidbodies. Call <code>PxRigidDynamic::wakeUp()</code> manually if needed.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/using_physx_cct/><span class=title>¬´ Prev</span><br><span>PhysXÁâ©ÁêÜÂºïÊìéÔºà4ÔºâCharacter Controller</span>
</a><a class=next href=https://pps43.github.io/posts/using_physx_collision/><span class=title>Next ¬ª</span><br><span>PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision</span></a></nav></footer></article></main><footer class=footer><span>¬© 2016-2023 By Ê≥¢Ê≥¢Ê≤ô.</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>