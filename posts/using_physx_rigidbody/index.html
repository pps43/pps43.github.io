<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics | Ê≥¢Ê≥¢Ê≤ôüè†</title><meta name=keywords content="Game Dev,PhysX"><meta name=description content="Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode,"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_rigidbody/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics"><meta property="og:description" content="Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode,"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/using_physx_rigidbody/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-04T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics"><meta name=twitter:description content="Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode,"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics","item":"https://pps43.github.io/posts/using_physx_rigidbody/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics","name":"PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics","description":"Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode,","keywords":["Game Dev","PhysX"],"articleBody":" Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ\nPhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàóËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºàCode, DocÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ\nWarm-up We already know that\nKinematic and Dynamic rigidbody are both PxRigidDynamic in PhysX. Use PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true) to turn a dynamic actor into kinematic at runtime, and vice versa. Kinematic and Static actors always stay in the same location unless you move them in your code. When moving Static actors, their collisions with dynamic actors can be wrong. When moving Kinematic actors, you should always use PxRigidDynamic::setKinematicTarget in each frame rather than PxRigidActor::setGlobalPose to achieve correct collisions with other dynamic actors. In this post we focus on dynamic rigidbody movement, e.g., force and torque, gravity, sleeping and so on.\nHere are necessary physical concepts with math formulas.\nTranslation formular Rotation formular Position \\(\\vec{x}\\) Orientation (3x3 matrix) \\(\\mathbf{R}\\) Linear Velocity \\(\\vec{v}=\\frac{d\\vec{x}}{dt}\\) Angular Velocity \\(\\vec{\\omega}=\\frac{\\vec{v}\\times\\vec{r}}{\\lVert{\\vec{r}}\\rVert^2}\\) Linear Acceleration \\(\\vec{a}=\\frac{d\\vec{v}}{dt}\\) Angular Acceleration \\(\\vec{\\alpha}=\\frac{d\\vec{\\omega}}{dt}\\) Mass \\(M=\\sum{m_i}\\) Intertia tensor \\(\\mathbf{I}=\\mathbf{R}\\mathbf{I}_0\\mathbf{R}^T\\) Linear momententum \\(\\vec{p}=M\\vec{v}\\) Angular momententum \\(\\vec{L}=\\mathbf{I}\\vec{\\omega}\\) Force \\(\\vec{F}=\\frac{d\\vec{p}}{dt}=m\\vec{a}\\) Torque \\(\\vec{\\tau}=\\frac{d\\vec{L}}{dt}\\) Setup Rigidbody Dynamic actor has 3 mass related properties: mass, center of mass, inertia tensor.\nLet mass be 0 means it cannot move.\nCenter of mass is the position where force applys upon to generate a translation without rotating. It‚Äôs defined in local space as Vector3, default value is (0,0,0).\nMoment of inertia is a single number that describes how hard it is to rotate an object about a particular axis, while the inertia tensor is a 3x3 matrix that describes how hard it is to rotate an object about any axis. Let inertia tensor be (0,0,0) means it cannot rotate by any axis.\nThe easiest way to calculate mass properties is to always use the PxRigidBodyExt::updateMassAndInertia. You don‚Äôt need setMassAndUpdateInertia.\nIn Official demo North Pole (PhysX_3.4\\Samples\\SampleNorthPole\\SampleNorthPoleDynamics.cpp), all of them are low center of mass, but with different config to achieve different feeling.\nHere are my code snippet to initialize a dynamic rigidbody.\nvoid ActorWrapper::InitRigidbody(bool useGravity, float mass, const PxVec3\u0026 centerOfMass, const PxVec3\u0026 interiaTensor, const PxVec3\u0026 velocity, float drag, const PxVec3\u0026 angularVelocity, float maxAngularVelocity, float angularDrag, int constrainFlags) { PxRigidDynamic* actor = PxActorAs\u003cPxRigidDynamic\u003e(); if (actor == NULL || actor-\u003egetScene() == NULL) { return; } actor-\u003esetActorFlag(PxActorFlag::eDISABLE_GRAVITY, !useGravity); actor-\u003esetMaxAngularVelocity(maxAngularVelocity); //SetConstrains (todo) actor-\u003esetLinearDamping(drag); angularDrag = PxMax(0.01f, angularDrag); // 0 is unstable for angular drag actor-\u003esetAngularDamping(angularDrag); actor-\u003esetMass(mass); actor-\u003esetCMassLocalPose(PxTransform(centerOfMass)); actor-\u003esetMassSpaceInertiaTensor(interiaTensor); // not kinematic if (!(actor-\u003egetRigidBodyFlags() \u0026 PxRigidBodyFlag::eKINEMATIC)) { // if has constrain, modify velocity here actor-\u003esetLinearVelocity(velocity); actor-\u003esetAngularVelocity(angularVelocity); } } void ActorWrapper::SetDensity(float density) { PxRigidDynamic* actor = PxActorAs\u003cPxRigidDynamic\u003e(); if (actor == NULL || actor-\u003egetScene() == NULL) { return; } density = PxClamp(density, 0.0f, 1e6f); PxRigidBodyExt::updateMassAndInertia(*actor, density); } Add Force \u0026 Torque addForce causes a translation, addTorque causes rotation, and addForceAtPos causes linear and rotation if pos is not the center of mass.\nBoth force and torque support 4 modes:\nPxForceMode physics equivalent eFORCE \\(ma\\) eIMPULSE \\(mat\\) eVELOCITY_CHANGE \\(at\\) eACCELERATION \\(a\\) Here are my code snippet to implement addForce and addTorque:\nvoid ActorWrapper::AddForce(const PxVec3\u0026 force, int forceMode) { // validation if (force.IsAllZero() || !force.IsFinite()) { return; } PxRigidDynamic* actor = GetRigidDynamicActor(); if (actor == NULL || actor-\u003egetScene() == NULL || (actor-\u003egetRigidBodyFlags() \u0026 PxRigidBodyFlag::eKINEMATIC)) { return; } actor-\u003eaddForce(force, forceMode); } void ActorWrapper::AddRelativeForce(const PxVec3\u0026 force, int forceMode) { // same validation as AddForce PxVec3 globalForce = actor-\u003egetGlobalPose().rotate(localForce); actor-\u003eaddForce(globalForce, forceMode); } void ActorWrapper::AddTorque(const PxVec3\u0026 torque, int forceMode) { // same validation as AddForce actor-\u003eaddTorque(torque, forceMode); } void ActorWrapper::AddRelativeTorque(const PxVec3\u0026 torque, int forceMode) { // same validation as AddForce PxVec3 globalTorque = actor-\u003egetGlobalPose().rotate(torque); actor-\u003eaddForce(globalForce, forceMode); } void ActorWrapper::UGCAddForceAtPosition(const PxVec3\u0026 force, int forceMode, const PxVec3\u0026 position) { // same validation as AddForce if (!position.IsFinite()) { return; } // Only eFORCE and eIMPULSE are supported! if (forceMode == PxForceMode::eFORCE || forceMode == PxForceMode::eIMPULSE) { PxRigidBodyExt::addForceAtPos(*actor, force, position); } } Change Gravity Gravity is scene-wide for dynamic rigidbodies in the scene, by PxScene::setGravity().\nWe can let some dynamic actors are not influenced by scene-wide gravity by PxActor::setActorFlag(PxActorFlag::eDISABLE_GRAVITY,true). Then addForce each frame manually to make your customized gravity on this actor.\nSleep \u0026 Awake Why Sleep Matters Sleeping rigidbodies almost cost nothing. You can put less important rigidbodies to sleep, which can significantly lower CPU cost when you have thousands of them.\nSleep Mechanism An actor goes to sleep when: its mass-normalized kinetic energy (a.k.a. \\(\\frac{1}{2}v^2\\)) is below a given threshold for a certain time (Internally they use a wake-counter, when counter reaches 0, actor is a candidate to sleep).\nDefault threshold is \\(5‚àó10^{‚àí5}‚àóv^2\\), where \\(v\\) is PxTolerancesScale.velocity. Thus the logic of the formular is that when actor‚Äôs velocity is below 1% of PxTolerancesScale.velocity, they are allowed to go to sleep. Set threshold by PxRigidDynamic::setSleepThreshold\nYou can also set wake-counter value to control sleeping, by PxRigidDynamic::setWakeCounter.\nCommon APIs about sleeping (only for dynamic actors!):\nName Notes PxRigidDynamic::setSleepThreshold PxRigidDynamic::setWakeCounter Calling on a sleeping rigidbody will auto-wakeup PxRigidDynamic::isSleeping() PxRigidDynamic::wakeUp() Force wakeup. PxRigidDynamic::putToSleep() Force sleep. PxSimulationEventCallback::onWake/onSleep To receive these events, set flag on actor: PxActorFlag::eSEND_SLEEP_NOTIFIES Awake Mechanism Overall, these actions wake an actor up:\nPxRigidDynamic::setKinematicTarget() for kinematic actor. PxRigidActor::setGlobalPose(), if the autowake parameter is set to true (default). Raising PxActorFlag::eDISABLE_SIMULATION Calling PxScene::resetFiltering(). Calling PxShape::setSimulationFilterData() and cause a different filtering result. Touch with an actor that is awake. A touching rigid actor gets removed from the scene. Contact with a static rigid actor is lost. Contact with a dynamic rigid actor is lost (awake in the next simulation step). Actor gets hit by a two-way interaction particle Golden Tips When calling PxRigidDynamic::setAngularDamping(value), make sure value is above zero otherwise it goes unstable for rotating. Changing scene-wide gravity value will NOT auto-wake sleeping rigidbody. Call PxRigidDynamic::wakeUp() manually if required. ","wordCount":"1002","inLanguage":"en","datePublished":"2023-09-04T00:00:00Z","dateModified":"2023-09-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_rigidbody/"},"publisher":{"@type":"Organization","name":"Ê≥¢Ê≥¢Ê≤ôüè†","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="Ê≥¢Ê≥¢Ê≤ôüè† (Alt + H)">Ê≥¢Ê≥¢Ê≤ôüè†</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PhysXÁâ©ÁêÜÂºïÊìéÔºà3ÔºâRigidbody Dynamics</h1><div class=post-meta><span title='2023-09-04 00:00:00 +0000 UTC'>September 4, 2023</span>&nbsp;¬∑&nbsp;2 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#warm-up aria-label=Warm-up>Warm-up</a></li><li><a href=#setup-rigidbody aria-label="Setup Rigidbody">Setup Rigidbody</a></li><li><a href=#add-force--torque aria-label="Add Force &amp;amp; Torque">Add Force & Torque</a></li><li><a href=#change-gravity aria-label="Change Gravity">Change Gravity</a></li><li><a href=#sleep--awake aria-label="Sleep &amp;amp; Awake">Sleep & Awake</a><ul><li><a href=#why-sleep-matters aria-label="Why Sleep Matters">Why Sleep Matters</a></li><li><a href=#sleep-mechanism aria-label="Sleep Mechanism">Sleep Mechanism</a></li><li><a href=#awake-mechanism aria-label="Awake Mechanism">Awake Mechanism</a></li></ul></li><li><a href=#golden-tips aria-label="Golden Tips">Golden Tips</a></li></ul></div></details></div><div class=post-content><blockquote><p>Êú¨Êñá‰∏ªË¶Å‰ªãÁªçPhysXÂàö‰ΩìÂä®ÂäõÂ≠¶Áõ∏ÂÖ≥ÁöÑÂÜÖÈÉ®Êú∫Âà∂Âíå‰ΩøÁî®ÊñπÊ≥ï„ÄÇ</p><p><a href=(/tags/physx/)>PhysXÁâ©ÁêÜÂºïÊìéÁ≥ªÂàó</a>ËÆ∞ÂΩï‰∫ÜÂú®ÂÆûÈôÖÈ°πÁõÆ‰∏≠‰ΩøÁî®Nvdia PhysX 3.4Áâ©ÁêÜÂºïÊìéÔºà<a href=https://github.com/pps43/PhysX-3.4>Code</a>, <a href=https://github.com/pps43/PhysX-3.4/raw/master/PhysX_3.4/Documentation/PhysXGuide.chm>Doc</a>ÔºâÁöÑ‰∏Ä‰∫õÁªèÈ™åÔºåÊúâ‰∏çÂ∞ëÂØπÂÆòÊñπËµÑÊñôÁöÑË°•ÂÖÖ„ÄÇ</p></blockquote><h1 id=warm-up>Warm-up<a hidden class=anchor aria-hidden=true href=#warm-up>#</a></h1><p>We already know that</p><ul><li><code>Kinematic</code> and <code>Dynamic</code> rigidbody are both <code>PxRigidDynamic</code> in PhysX. Use <code>PxRigidBody::setRigidBodyFlag(PxRigidBodyFlag::eKINEMATIC, true)</code> to turn a dynamic actor into kinematic at runtime, and vice versa.</li><li><code>Kinematic</code> and <code>Static</code> actors always stay in the same location unless you move them in your code.</li><li>When moving <code>Static</code> actors, their collisions with dynamic actors can be wrong.</li><li>When moving <code>Kinematic</code> actors, you should always use <code>PxRigidDynamic::setKinematicTarget</code> in each frame rather than <code>PxRigidActor::setGlobalPose</code> to achieve correct collisions with other dynamic actors.</li></ul><p>In this post we focus on dynamic rigidbody movement, e.g., <strong>force and torque, gravity, sleeping</strong> and so on.</p><p>Here are necessary physical concepts with math formulas.</p><table><thead><tr><th>Translation</th><th>formular</th><th>Rotation</th><th>formular</th></tr></thead><tbody><tr><td>Position</td><td>\(\vec{x}\)</td><td>Orientation (3x3 matrix)</td><td>\(\mathbf{R}\)</td></tr><tr><td>Linear Velocity</td><td>\(\vec{v}=\frac{d\vec{x}}{dt}\)</td><td>Angular Velocity</td><td>\(\vec{\omega}=\frac{\vec{v}\times\vec{r}}{\lVert{\vec{r}}\rVert^2}\)</td></tr><tr><td>Linear Acceleration</td><td>\(\vec{a}=\frac{d\vec{v}}{dt}\)</td><td>Angular Acceleration</td><td>\(\vec{\alpha}=\frac{d\vec{\omega}}{dt}\)</td></tr><tr><td>Mass</td><td>\(M=\sum{m_i}\)</td><td>Intertia tensor</td><td>\(\mathbf{I}=\mathbf{R}\mathbf{I}_0\mathbf{R}^T\)</td></tr><tr><td>Linear momententum</td><td>\(\vec{p}=M\vec{v}\)</td><td>Angular momententum</td><td>\(\vec{L}=\mathbf{I}\vec{\omega}\)</td></tr><tr><td>Force</td><td>\(\vec{F}=\frac{d\vec{p}}{dt}=m\vec{a}\)</td><td>Torque</td><td>\(\vec{\tau}=\frac{d\vec{L}}{dt}\)</td></tr></tbody></table><h1 id=setup-rigidbody>Setup Rigidbody<a hidden class=anchor aria-hidden=true href=#setup-rigidbody>#</a></h1><p>Dynamic actor has 3 mass related properties: <strong>mass</strong>, <strong>center of mass</strong>, <strong>inertia tensor</strong>.</p><blockquote><p>Let <strong>mass</strong> be 0 means it cannot move.</p><p><strong>Center of mass</strong> is the position where force applys upon to generate a translation without rotating. It&rsquo;s defined in local space as Vector3, default value is (0,0,0).</p><p><strong>Moment of inertia</strong> is a single number that describes how hard it is to rotate an object about a particular axis, while the <strong>inertia tensor</strong> is a 3x3 matrix that describes how hard it is to rotate an object about any axis. Let <strong>inertia tensor</strong> be (0,0,0) means it cannot rotate by any axis.</p></blockquote><p>The easiest way to calculate mass properties is to always use the <code>PxRigidBodyExt::updateMassAndInertia</code>. You don&rsquo;t need <code>setMassAndUpdateInertia</code>.</p><p>In Official demo <code>North Pole</code> (<code>PhysX_3.4\Samples\SampleNorthPole\SampleNorthPoleDynamics.cpp</code>), all of them are low center of mass, but with different config to achieve different feeling.</p><p>Here are my code snippet to initialize a dynamic rigidbody.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>InitRigidbody</span><span class=p>(</span><span class=kt>bool</span> <span class=n>useGravity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>mass</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>centerOfMass</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>interiaTensor</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>velocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>drag</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>angularVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>maxAngularVelocity</span><span class=p>,</span> <span class=kt>float</span> <span class=n>angularDrag</span><span class=p>,</span> <span class=kt>int</span> <span class=n>constrainFlags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidDynamic</span><span class=o>*</span> <span class=n>actor</span> <span class=o>=</span> <span class=n>PxActorAs</span><span class=o>&lt;</span><span class=n>PxRigidDynamic</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>actor</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getScene</span><span class=p>()</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setActorFlag</span><span class=p>(</span><span class=n>PxActorFlag</span><span class=o>::</span><span class=n>eDISABLE_GRAVITY</span><span class=p>,</span> <span class=o>!</span><span class=n>useGravity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setMaxAngularVelocity</span><span class=p>(</span><span class=n>maxAngularVelocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>    <span class=c1>//SetConstrains (todo)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setLinearDamping</span><span class=p>(</span><span class=n>drag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>angularDrag</span> <span class=o>=</span> <span class=n>PxMax</span><span class=p>(</span><span class=mf>0.01f</span><span class=p>,</span> <span class=n>angularDrag</span><span class=p>);</span> <span class=c1>// 0 is unstable for angular drag
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setAngularDamping</span><span class=p>(</span><span class=n>angularDrag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setMass</span><span class=p>(</span><span class=n>mass</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setCMassLocalPose</span><span class=p>(</span><span class=n>PxTransform</span><span class=p>(</span><span class=n>centerOfMass</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=o>-&gt;</span><span class=n>setMassSpaceInertiaTensor</span><span class=p>(</span><span class=n>interiaTensor</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// not kinematic
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>getRigidBodyFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eKINEMATIC</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// if has constrain, modify velocity here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>actor</span><span class=o>-&gt;</span><span class=n>setLinearVelocity</span><span class=p>(</span><span class=n>velocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>setAngularVelocity</span><span class=p>(</span><span class=n>angularVelocity</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>SetDensity</span><span class=p>(</span><span class=kt>float</span> <span class=n>density</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRigidDynamic</span><span class=o>*</span> <span class=n>actor</span> <span class=o>=</span> <span class=n>PxActorAs</span><span class=o>&lt;</span><span class=n>PxRigidDynamic</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>actor</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getScene</span><span class=p>()</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>density</span> <span class=o>=</span> <span class=n>PxClamp</span><span class=p>(</span><span class=n>density</span><span class=p>,</span> <span class=mf>0.0f</span><span class=p>,</span> <span class=mf>1e6</span><span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRigidBodyExt</span><span class=o>::</span><span class=n>updateMassAndInertia</span><span class=p>(</span><span class=o>*</span><span class=n>actor</span><span class=p>,</span> <span class=n>density</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=add-force--torque>Add Force & Torque<a hidden class=anchor aria-hidden=true href=#add-force--torque>#</a></h1><p><code>addForce</code> causes a translation, <code>addTorque</code> causes rotation, and <code>addForceAtPos</code> causes linear and rotation if pos is not the center of mass.</p><p>Both force and torque support 4 modes:</p><table><thead><tr><th>PxForceMode</th><th>physics equivalent</th></tr></thead><tbody><tr><td>eFORCE</td><td>\(ma\)</td></tr><tr><td>eIMPULSE</td><td>\(mat\)</td></tr><tr><td>eVELOCITY_CHANGE</td><td>\(at\)</td></tr><tr><td>eACCELERATION</td><td>\(a\)</td></tr></tbody></table><p>Here are my code snippet to implement addForce and addTorque:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddForce</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>force</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// validation
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>force</span><span class=p>.</span><span class=n>IsAllZero</span><span class=p>()</span> <span class=o>||</span> <span class=o>!</span><span class=n>force</span><span class=p>.</span><span class=n>IsFinite</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>PxRigidDynamic</span><span class=o>*</span> <span class=n>actor</span> <span class=o>=</span> <span class=n>GetRigidDynamicActor</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>actor</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getScene</span><span class=p>()</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=p>(</span><span class=n>actor</span><span class=o>-&gt;</span><span class=n>getRigidBodyFlags</span><span class=p>()</span> <span class=o>&amp;</span> <span class=n>PxRigidBodyFlag</span><span class=o>::</span><span class=n>eKINEMATIC</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addForce</span><span class=p>(</span><span class=n>force</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddRelativeForce</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>force</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>PxVec3</span> <span class=n>globalForce</span> <span class=o>=</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getGlobalPose</span><span class=p>().</span><span class=n>rotate</span><span class=p>(</span><span class=n>localForce</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addForce</span><span class=p>(</span><span class=n>globalForce</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddTorque</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>torque</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addTorque</span><span class=p>(</span><span class=n>torque</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>AddRelativeTorque</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>torque</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>PxVec3</span> <span class=n>globalTorque</span> <span class=o>=</span> <span class=n>actor</span><span class=o>-&gt;</span><span class=n>getGlobalPose</span><span class=p>().</span><span class=n>rotate</span><span class=p>(</span><span class=n>torque</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>actor</span><span class=o>-&gt;</span><span class=n>addForce</span><span class=p>(</span><span class=n>globalForce</span><span class=p>,</span> <span class=n>forceMode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ActorWrapper</span><span class=o>::</span><span class=n>UGCAddForceAtPosition</span><span class=p>(</span><span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>force</span><span class=p>,</span> <span class=kt>int</span> <span class=n>forceMode</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxVec3</span><span class=o>&amp;</span> <span class=n>position</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// same validation as AddForce
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>position</span><span class=p>.</span><span class=n>IsFinite</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Only eFORCE and eIMPULSE are supported!
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span> <span class=p>(</span><span class=n>forceMode</span> <span class=o>==</span> <span class=n>PxForceMode</span><span class=o>::</span><span class=n>eFORCE</span> <span class=o>||</span> <span class=n>forceMode</span> <span class=o>==</span> <span class=n>PxForceMode</span><span class=o>::</span><span class=n>eIMPULSE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PxRigidBodyExt</span><span class=o>::</span><span class=n>addForceAtPos</span><span class=p>(</span><span class=o>*</span><span class=n>actor</span><span class=p>,</span> <span class=n>force</span><span class=p>,</span> <span class=n>position</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=change-gravity>Change Gravity<a hidden class=anchor aria-hidden=true href=#change-gravity>#</a></h1><p>Gravity is scene-wide for dynamic rigidbodies in the scene, by <code>PxScene::setGravity()</code>.</p><p>We can let some dynamic actors are not influenced by scene-wide gravity by <code>PxActor::setActorFlag(PxActorFlag::eDISABLE_GRAVITY,true)</code>. Then <code>addForce</code> each frame manually to make your customized gravity on this actor.</p><h1 id=sleep--awake>Sleep & Awake<a hidden class=anchor aria-hidden=true href=#sleep--awake>#</a></h1><h2 id=why-sleep-matters>Why Sleep Matters<a hidden class=anchor aria-hidden=true href=#why-sleep-matters>#</a></h2><p>Sleeping rigidbodies almost cost nothing. You can put less important rigidbodies to sleep, which can significantly lower CPU cost when you have thousands of them.</p><h2 id=sleep-mechanism>Sleep Mechanism<a hidden class=anchor aria-hidden=true href=#sleep-mechanism>#</a></h2><p>An actor goes to sleep when: its mass-normalized kinetic energy (a.k.a. \(\frac{1}{2}v^2\)) is <strong>below a given threshold for a certain time</strong> (Internally they use a wake-counter, when counter reaches 0, actor is a candidate to sleep).</p><p>Default threshold is \(5‚àó10^{‚àí5}‚àóv^2\), where \(v\) is <code>PxTolerancesScale.velocity</code>. Thus the logic of the formular is that when actor&rsquo;s velocity is below 1% of <code>PxTolerancesScale.velocity</code>, they are allowed to go to sleep. Set threshold by <code>PxRigidDynamic::setSleepThreshold</code></p><p>You can also set wake-counter value to control sleeping, by <code>PxRigidDynamic::setWakeCounter</code>.</p><p>Common APIs about sleeping (only for dynamic actors!):</p><table><thead><tr><th>Name</th><th>Notes</th></tr></thead><tbody><tr><td>PxRigidDynamic::setSleepThreshold</td><td></td></tr><tr><td>PxRigidDynamic::setWakeCounter</td><td>Calling on a sleeping rigidbody will auto-wakeup</td></tr><tr><td>PxRigidDynamic::isSleeping()</td><td></td></tr><tr><td>PxRigidDynamic::wakeUp()</td><td>Force wakeup.</td></tr><tr><td>PxRigidDynamic::putToSleep()</td><td>Force sleep.</td></tr><tr><td>PxSimulationEventCallback::onWake/onSleep</td><td>To receive these events, set flag on actor: <code>PxActorFlag::eSEND_SLEEP_NOTIFIES</code></td></tr></tbody></table><h2 id=awake-mechanism>Awake Mechanism<a hidden class=anchor aria-hidden=true href=#awake-mechanism>#</a></h2><p>Overall, these actions wake an actor up:</p><ul><li><code>PxRigidDynamic::setKinematicTarget()</code> for kinematic actor.</li><li><code>PxRigidActor::setGlobalPose()</code>, if the autowake parameter is set to true (default).</li><li>Raising <code>PxActorFlag::eDISABLE_SIMULATION</code></li><li>Calling <code>PxScene::resetFiltering()</code>.</li><li>Calling <code>PxShape::setSimulationFilterData()</code> and cause a different filtering result.</li><li>Touch with an actor that is awake.</li><li>A touching rigid actor gets removed from the scene.</li><li>Contact with a static rigid actor is lost.</li><li>Contact with a dynamic rigid actor is lost (awake in the next simulation step).</li><li>Actor gets hit by a two-way interaction particle</li></ul><h1 id=golden-tips>Golden Tips<a hidden class=anchor aria-hidden=true href=#golden-tips>#</a></h1><ul><li>When calling <code>PxRigidDynamic::setAngularDamping(value)</code>, make sure <code>value</code> is <strong>above zero</strong> otherwise it goes unstable for rotating.</li><li>Changing scene-wide gravity value will <strong>NOT</strong> auto-wake sleeping rigidbody. Call <code>PxRigidDynamic::wakeUp()</code> manually if required.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/thinking_of_software_engineering/><span class=title>¬´ Prev</span><br><span>Facts and wisdom on software engineering</span></a>
<a class=next href=https://pps43.github.io/posts/using_physx_collision/><span class=title>Next ¬ª</span><br><span>PhysXÁâ©ÁêÜÂºïÊìéÔºà2ÔºâCollision</span></a></nav></footer></article></main><footer class=footer><span>¬© 2016-2023 By Ê≥¢Ê≥¢Ê≤ô.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>