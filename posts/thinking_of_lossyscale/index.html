<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>深入 LossyScale | 波波沙🏠</title><meta name=keywords content="Game Dev,PhysX,数学"><meta name=description content="本文是PhysX物理引擎系列的番外篇，其实要弄明白一个3D数学问题：如何处理父节点带有非均匀缩放和旋转时，子节点的最终大小和形态。 问题源自笔"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/thinking_of_lossyscale/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="深入 LossyScale"><meta property="og:description" content="本文是PhysX物理引擎系列的番外篇，其实要弄明白一个3D数学问题：如何处理父节点带有非均匀缩放和旋转时，子节点的最终大小和形态。 问题源自笔"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/thinking_of_lossyscale/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-19T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-19T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="深入 LossyScale"><meta name=twitter:description content="本文是PhysX物理引擎系列的番外篇，其实要弄明白一个3D数学问题：如何处理父节点带有非均匀缩放和旋转时，子节点的最终大小和形态。 问题源自笔"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"深入 LossyScale","item":"https://pps43.github.io/posts/thinking_of_lossyscale/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"深入 LossyScale","name":"深入 LossyScale","description":"本文是PhysX物理引擎系列的番外篇，其实要弄明白一个3D数学问题：如何处理父节点带有非均匀缩放和旋转时，子节点的最终大小和形态。 问题源自笔","keywords":["Game Dev","PhysX","数学"],"articleBody":" 本文是PhysX物理引擎系列的番外篇，其实要弄明白一个3D数学问题：如何处理父节点带有非均匀缩放和旋转时，子节点的最终大小和形态。 问题源自笔者在修改物理引擎为其添加scale属性时遇到的一个bug。解决后对WorldScale为什么叫做LossyScale、空间变换和基变换有了更深的理解。\n背景 PhysX引擎中，场景内的Actor之间并没有父子层级关系，仅有的层级是Shape可以绑定到Actor作为子节点。 PhysX引擎中并没有Scale的概念，即PxTransform只包含Position和Rotation，而大小只反映在最底层Shape的尺寸上（比如球形碰撞盒有半径这个属性）。所以设置缩放比例的实现方式是改变物体尺寸。 问题的出现 Actor下可以有若干Shape，这里只讨论一个Shape。增加属性Actor.Scale，修改该属性时要保证Shape.Dimension的正确性。\nclassDiagram direction LR class Actor { PxVec3 Position PxQuat Rotation PxVec3 Scale } class Shape { PxVec3 LocalPosition PxQuat LocalRotation PxVec3 OriginalDimension PxVec3 Dimension } Actor o-- Shape 经实践，更方便的方式是记录Shape的初始尺寸OriginalDimension，然后乘上改变Actor.Scale后对应Shape的“缩放系数”。而不是为了节省存储通过Actor.Scale改变前后的比例来计算。总之，问题简化为实现GetShapeScale()。\nShape.Dimension = Shape.OriginalDimension * GetShapeScale(); 当Shape相对Actor没有旋转，即Shape.LocalRotation = (0,0,0,1)时，容易发现：\nPxVec3 GetShapeScale() { return actor.Scale; } 但是当同时存在旋转和非均匀缩放呢？简单来说，当Actor.Scale=(1,4,1)，而Shape绕z轴转了90度，那么预期的结果应该是(4,1,1)，即Shape相对于自己在横向上扩大到2倍。若绕z轴转了45度，那么预期的结果是(2,2,1)。要如何达到这种效果呢？\n似是而非的算法 一个很自然的想法是，要达到上面的效果，其实是将Actor.Scale像方向矢量那样旋转到Shape空间内。\nPxVec3 GetShapeScale() { PxTransform shapeSpace = shape-\u003egetLocalPose(); return shapeSpace-\u003erotate(actor.Scale); } 然而反例是：actorScale=(1,1,1)经过旋转后可能不再是(1,1,1)，即Shape叠加了一个缩放。这是与事实违背的。针对(1,1,1)特殊处理也并不正确，因为对于任意(X,Y,Z)，总有一种旋转让其某个分量为0。\n这种算法的错误之处在最后一节会额外讨论。\n正确的算法 在Unity的文档中，对于Transform.LossyScale这样说明：\nThe global scale of the object (Read Only).\nPlease note that if you have a parent transform with scale and a child that is arbitrarily rotated, the scale will be skewed. Thus scale can not be represented correctly in a 3 component vector but only a 3x3 matrix. Such a representation is quite inconvenient to work with however. lossyScale is a convenience property that attempts to match the actual world scale as much as it can. If your objects are not skewed the value will be completely correct and most likely the value will not be very different if it contains skew too.\n理解，但不完全理解。直到找来源码分析了一番。去粗取精，根据代码提炼出公式：\n$$ R_{world}=R_1R_2…R_N $$ $$ W_{world}=R_1S_1R_2S_2…R_NS_N $$ $$ S_{world}=R_{world}^{-1}W_{world} $$ $$ s = diag(S_{world}) $$\n上式中，\\(1…N\\)是根节点到叶子节点的编号，所有矩阵均采用列优先矩阵。\\(R_i\\)是只包含自身旋转信息的3x3旋转矩阵。\\(S_i\\)是质保函自身缩放信息的3x3对角矩阵。最终结果\\(s\\)是3x1列矢量，取自\\(S_{world}\\)的对角线元素。\n算法推导与解释 为什么是这样呢？这要从TRS变换矩阵说起。在3D中间中的姿态、运动和坐标系都可以用矩阵表达。 一般\\(T\\)表示位移，\\(R\\)表示旋转，\\(S\\) 表示缩放。\n贴心提示：\n用欧拉角表示则需要规定旋转轴次序否则有歧义（感兴趣可以搜索万向节死锁）。经过实验Unity使用YXZ，即对于\\((\\theta_x,\\theta_y,\\theta_z)\\)，先按照Y轴转 \\(\\theta_y\\) ，再按照转动后的X轴转\\(\\theta_x\\)，再按照转动后的Z轴转\\(\\theta_z\\)。 有时使用4x4而不是3x3矩阵只是一个数学上的技巧，为了让所有变换都可以用矩阵乘法串联起来。 有时使用分块矩阵也只是一个数学上的技巧，为了简化公式发现规律。 对于列优先矩阵，将列矢量\\(v_1\\)先按照\\(M_1\\)再按照\\(M_2\\)变换到\\(v_2\\)写作\\(v_2=M_2M_1v_1\\)。 更多资料如《游戏引擎架构》、任何讲解3D游戏开发或图形学的书籍。 $$ T= \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 Tx \\\\ 0 \u0026 1 \u0026 0 \u0026 Ty \\\\ 0 \u0026 0 \u0026 1 \u0026 Tz \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix}= \\begin{pmatrix} I \u0026 \\bar{T}\\\\ 0 \u0026 0 \\end{pmatrix} $$\n$$ R_x= \\begin{pmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 \\cos\\theta_x \u0026 -\\sin\\theta_x \u0026 0 \\\\ 0 \u0026 \\sin\\theta_x \u0026 \\cos\\theta_x \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$\n$$ R_y= \\begin{pmatrix} \\cos\\theta_y \u0026 0 \u0026 \\sin\\theta_y \u0026 0 \\\\ 0 \u0026 1 \u0026 0 \u0026 0 \\\\ -\\sin\\theta_y \u0026 0 \u0026 \\cos\\theta_y \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$\n$$ R_z= \\begin{pmatrix} \\cos\\theta_z \u0026 -\\sin\\theta_z \u0026 0 \u0026 0 \\\\ \\sin\\theta_z \u0026 \\cos\\theta_z \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix} $$\n$$ R = R_zR_xR_y= \\begin{pmatrix} r_{11} \u0026 r_{12} \u0026 r_{13} \u0026 0 \\\\ r_{21} \u0026 r_{22} \u0026 r_{23} \u0026 0 \\\\ r_{31} \u0026 r_{32} \u0026 r_{33} \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix}= \\begin{pmatrix} \\bar{R} \u0026 0 \\\\ 0 \u0026 1 \\end{pmatrix} $$\n$$ S= \\begin{pmatrix} s_x \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 s_y \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 s_z \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix}= \\begin{pmatrix} \\bar{S} \u0026 0 \\\\ 0 \u0026 1 \\end{pmatrix} $$\n则对于一个节点，其本地坐标系的TRS变换矩阵可以写作：\n$$ M=\\begin{pmatrix} r_{11}S_x \u0026 r_{12}S_y \u0026 r_{13}S_z \u0026 T_x \\\\ r_{21}S_x \u0026 r_{22}S_y \u0026 r_{23}S_z \u0026 T_y \\\\ r_{31}S_x \u0026 r_{32}S_y \u0026 r_{33}S_z \u0026 T_z \\\\ 0 \u0026 0 \u0026 0 \u0026 1 \\end{pmatrix}= \\begin{pmatrix} \\bar{R}\\bar{S} \u0026 \\bar{T} \\\\ 0 \u0026 1 \\end{pmatrix} $$\n则对于父子节点\\(M_1\\)中的子节点\\(M_2\\)，其相对于世界坐标系的变换矩阵可以写作：\n$$ M=M_2M_1= \\begin{pmatrix} \\bar{R_2}\\bar{S_2} \u0026 \\bar{T_2} \\\\ 0 \u0026 1 \\end{pmatrix} \\begin{pmatrix} \\bar{R_1}\\bar{S_1} \u0026 \\bar{T_1} \\\\ 0 \u0026 1 \\end{pmatrix}= \\begin{pmatrix} \\bar{R_2}\\bar{S_2}\\bar{R_1}\\bar{S_1} \u0026 \\bar{R_2}\\bar{S_2}\\bar{T_1}+\\bar{T_2} \\\\ 0 \u0026 1 \\end{pmatrix} $$\n从另一个角度思考，若要将\\(M\\)拆分成TRS三个分量，是否就对应世界坐标系下的位移、旋转、缩放（全局缩放正是我们所需要的）呢？容易观察到全局位移是：\n$$ T_{world}= \\begin{pmatrix} \\bar{R_2}\\bar{S_2}\\bar{T_1}+\\bar{T_2} \\end{pmatrix} $$\n而全局旋转由于其物理意义，必然是：\n$$ R_{world}= \\bar{R_2}\\bar{R_1} $$\n则全局缩放只能是：\n$$ S_{world}=R_{world}^{-1}\\bar{R_2}\\bar{S_2}\\bar{R_1}\\bar{S_1}=(\\bar{R}_1^{-1}\\bar{S_2}\\bar{R_1})\\bar{S_1} $$\n一般来说，\\(S_{world}\\)是一个非对角矩阵，即主对角线之外也有非零值。若只将主对角线元素取出来作为scale，则缩放信息是有损的，这便是Unity中LossyScale名字的由来。\n当父节点是均匀缩放时（即\\(\\bar{S_2}=s_2I\\)），缩放系数可以化简为\\(S_{world}=\\bar{S_2}\\bar{S_1}=[s_x,s_y,s_z]^T\\)，则整体世界变换可以独立分解为TRS三个维度分别做世界变换的组合！而且此时\\(S_{world}\\)是一个对角矩阵，即LossyScale包含了完整的缩放信息。\n$$ M_{world}=T_{world}R_{world}S_{world} $$\n问题的终结 回到最初的问题上来，对Actor设置缩放时要更新所属Shape的尺寸，为此要实现的GetShapeScale()完整版：\nShape.Dimension = Shape.OriginalDimension * GetShapeScale(); PhysXVec3 GetShapeScale() { PxQuat worldRot = actor.Rotation * shapeTransform.q; PxMat33 inverseWorldRotMat = PxMat33(worldRot.getConjugate()); PxMat33 localRotMat = PxMat33(shapeTransform.q); PxMat33 actorRotMat = PxMat33(actor.Rotation); PxMat33 actorScaleMat = PxMat33().createDiagonal(actor.Scale); PxMat33 worldRotAndScaleMat = actorRotMat * actorScaleMat * localRotMat /* * localScaleMat*/; // localScaleMat is always Identity Matrix, so we omit it PxMat33 worldScaleMat = inverseWorldRotMat * worldRotAndScaleMat; PhysXVec3 worldscale = PhysXVec3(worldScaleMat[0][0], worldScaleMat[1][1], worldScaleMat[2][2]); // can have extra logic to make sure all values in worldscale are non-zero return worldscale; } 额外的讨论 已知正确的算法是：\n$$ S_{world}=(\\bar{R}_1^{-1}\\bar{S_2}\\bar{R_1})\\bar{S_1} $$\n而似是而非的算法其实是：\n$$ S_{world}=(\\bar{R_1}s_2)\\bar{S_1} $$\n本质错误在于：\n正确的算法是将缩放本身视为一个空间变换\\(S_2\\)，进行基变换。 错误的算法是将缩放系数视为一个普通矢量\\(s_2\\) ，进行空间变换。 这些在大一的课堂上早已学过。往往正向解释很简单，难的是反向思考，即遇到实际问题怎么选择合适的概念去解决。\n纸上得来终觉浅，绝知此事要躬行。\n","wordCount":"2790","inLanguage":"en","datePublished":"2023-07-19T00:00:00Z","dateModified":"2023-07-19T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/thinking_of_lossyscale/"},"publisher":{"@type":"Organization","name":"波波沙🏠","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="波波沙🏠 (Alt + H)">波波沙🏠</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>深入 LossyScale</h1><div class=post-meta><span title='2023-07-19 00:00:00 +0000 UTC'>July 19, 2023</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%83%8c%e6%99%af aria-label=背景>背景</a></li><li><a href=#%e9%97%ae%e9%a2%98%e7%9a%84%e5%87%ba%e7%8e%b0 aria-label=问题的出现>问题的出现</a></li><li><a href=#%e4%bc%bc%e6%98%af%e8%80%8c%e9%9d%9e%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=似是而非的算法>似是而非的算法</a></li><li><a href=#%e6%ad%a3%e7%a1%ae%e7%9a%84%e7%ae%97%e6%b3%95 aria-label=正确的算法>正确的算法</a></li><li><a href=#%e7%ae%97%e6%b3%95%e6%8e%a8%e5%af%bc%e4%b8%8e%e8%a7%a3%e9%87%8a aria-label=算法推导与解释>算法推导与解释</a></li><li><a href=#%e9%97%ae%e9%a2%98%e7%9a%84%e7%bb%88%e7%bb%93 aria-label=问题的终结>问题的终结</a></li><li><a href=#%e9%a2%9d%e5%a4%96%e7%9a%84%e8%ae%a8%e8%ae%ba aria-label=额外的讨论>额外的讨论</a></li></ul></div></details></div><div class=post-content><blockquote><p>本文是<a href=https://pps43.github.io/tags/physx/>PhysX物理引擎系列</a>的番外篇，其实要弄明白一个3D数学问题：如何处理父节点带有非均匀缩放和旋转时，子节点的最终大小和形态。
问题源自笔者在修改物理引擎为其添加<code>scale</code>属性时遇到的一个bug。解决后对<code>WorldScale</code>为什么叫做<code>LossyScale</code>、空间变换和基变换有了更深的理解。</p></blockquote><h1 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h1><ul><li>PhysX引擎中，场景内的Actor之间并没有父子层级关系，仅有的层级是Shape可以绑定到Actor作为子节点。</li><li>PhysX引擎中并没有<code>Scale</code>的概念，即<code>PxTransform</code>只包含<code>Position</code>和<code>Rotation</code>，而大小只反映在最底层<code>Shape</code>的尺寸上（比如球形碰撞盒有半径这个属性）。所以设置缩放比例的实现方式是改变物体尺寸。</li></ul><h1 id=问题的出现>问题的出现<a hidden class=anchor aria-hidden=true href=#问题的出现>#</a></h1><p>Actor下可以有若干Shape，这里只讨论一个Shape。增加属性<code>Actor.Scale</code>，修改该属性时要保证<code>Shape.Dimension</code>的正确性。</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>classDiagram
direction LR
class Actor {
    PxVec3 Position
    PxQuat Rotation
    PxVec3 Scale
}
class Shape {
    PxVec3 LocalPosition
    PxQuat LocalRotation
    PxVec3 OriginalDimension
    PxVec3 Dimension
}
Actor o-- Shape
</code></pre><p>经实践，更方便的方式是记录Shape的初始尺寸<code>OriginalDimension</code>，然后乘上改变<code>Actor.Scale</code>后对应Shape的“缩放系数”。而不是为了节省存储通过<code>Actor.Scale</code>改变前后的比例来计算。总之，问题简化为实现<code>GetShapeScale()</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Shape</span><span class=p>.</span><span class=n>Dimension</span> <span class=o>=</span> <span class=n>Shape</span><span class=p>.</span><span class=n>OriginalDimension</span> <span class=o>*</span> <span class=n>GetShapeScale</span><span class=p>();</span>
</span></span></code></pre></div><p>当Shape相对Actor没有旋转，即<code>Shape.LocalRotation = (0,0,0,1)</code>时，容易发现：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PxVec3</span> <span class=nf>GetShapeScale</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>actor</span><span class=p>.</span><span class=n>Scale</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>但是当同时存在旋转和非均匀缩放呢？简单来说，当<code>Actor.Scale=(1,4,1)</code>，而Shape绕z轴转了90度，那么预期的结果应该是<code>(4,1,1)</code>，即Shape相对于自己在横向上扩大到2倍。若绕z轴转了45度，那么预期的结果是<code>(2,2,1)</code>。要如何达到这种效果呢？</p><h1 id=似是而非的算法>似是而非的算法<a hidden class=anchor aria-hidden=true href=#似是而非的算法>#</a></h1><p>一个很自然的想法是，要达到上面的效果，其实是将<code>Actor.Scale</code>像方向矢量那样旋转到Shape空间内。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PxVec3</span> <span class=nf>GetShapeScale</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PxTransform</span> <span class=n>shapeSpace</span> <span class=o>=</span> <span class=n>shape</span><span class=o>-&gt;</span><span class=n>getLocalPose</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>shapeSpace</span><span class=o>-&gt;</span><span class=n>rotate</span><span class=p>(</span><span class=n>actor</span><span class=p>.</span><span class=n>Scale</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然而反例是：<code>actorScale=(1,1,1)</code>经过旋转后可能不再是<code>(1,1,1)</code>，即Shape叠加了一个缩放。这是与事实违背的。针对<code>(1,1,1)</code>特殊处理也并不正确，因为对于任意<code>(X,Y,Z)</code>，总有一种旋转让其某个分量为<code>0</code>。</p><p>这种算法的错误之处在最后一节会额外讨论。</p><h1 id=正确的算法>正确的算法<a hidden class=anchor aria-hidden=true href=#正确的算法>#</a></h1><p>在<a href=https://docs.unity3d.com/ScriptReference/Transform-lossyScale.html>Unity的文档</a>中，对于Transform.LossyScale这样说明：</p><blockquote><p>The global scale of the object (Read Only).</p><p>Please note that if you have a parent transform with scale and a child that is arbitrarily rotated, the scale will be skewed. <code>Thus scale can not be represented correctly in a 3 component vector but only a 3x3 matrix</code>. Such a representation is quite inconvenient to work with however. <code>lossyScale is a convenience property that attempts to match the actual world scale as much as it can</code>. If your objects are not skewed the value will be completely correct and most likely the value will not be very different if it contains skew too.</p></blockquote><p>理解，但不完全理解。直到找来源码分析了一番。去粗取精，根据代码提炼出公式：</p><p>$$
R_{world}=R_1R_2&mldr;R_N
$$
$$
W_{world}=R_1S_1R_2S_2&mldr;R_NS_N
$$
$$
S_{world}=R_{world}^{-1}W_{world}
$$
$$
s = diag(S_{world})
$$</p><p>上式中，\(1&mldr;N\)是根节点到叶子节点的编号，所有矩阵均采用列优先矩阵。\(R_i\)是只包含自身旋转信息的3x3旋转矩阵。\(S_i\)是质保函自身缩放信息的3x3对角矩阵。最终结果\(s\)是3x1列矢量，取自\(S_{world}\)的对角线元素。</p><h1 id=算法推导与解释>算法推导与解释<a hidden class=anchor aria-hidden=true href=#算法推导与解释>#</a></h1><p>为什么是这样呢？这要从<code>TRS</code>变换矩阵说起。在3D中间中的姿态、运动和坐标系都可以用矩阵表达。
一般\(T\)表示位移，\(R\)表示旋转，\(S\) 表示缩放。</p><blockquote><p>贴心提示：</p><ul><li>用欧拉角表示则需要规定旋转轴次序否则有歧义（感兴趣可以搜索万向节死锁）。经过实验<strong>Unity使用YXZ</strong>，即对于\((\theta_x,\theta_y,\theta_z)\)，先按照Y轴转 \(\theta_y\) ，再按照转动后的X轴转\(\theta_x\)，再按照转动后的Z轴转\(\theta_z\)。</li><li>有时使用4x4而不是3x3矩阵只是一个数学上的技巧，为了让所有变换都可以用矩阵乘法串联起来。</li><li>有时使用分块矩阵也只是一个数学上的技巧，为了简化公式发现规律。</li><li>对于列优先矩阵，将列矢量\(v_1\)先按照\(M_1\)再按照\(M_2\)变换到\(v_2\)写作\(v_2=M_2M_1v_1\)。</li><li>更多资料如《<a href=https://www.gameenginebook.com/>游戏引擎架构</a>》、任何讲解3D游戏开发或图形学的书籍。</li></ul></blockquote><p>$$
T=
\begin{pmatrix}
1 & 0 & 0 & Tx \\
0 & 1 & 0 & Ty \\
0 & 0 & 1 & Tz \\
0 & 0 & 0 & 1
\end{pmatrix}=
\begin{pmatrix}
I & \bar{T}\\
0 & 0
\end{pmatrix}
$$</p><p>$$
R_x=
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & \cos\theta_x & -\sin\theta_x & 0 \\
0 & \sin\theta_x & \cos\theta_x & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$</p><p>$$
R_y=
\begin{pmatrix}
\cos\theta_y & 0 & \sin\theta_y & 0 \\
0 & 1 & 0 & 0 \\
-\sin\theta_y & 0 & \cos\theta_y & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$</p><p>$$
R_z=
\begin{pmatrix}
\cos\theta_z & -\sin\theta_z & 0 & 0 \\
\sin\theta_z & \cos\theta_z & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}
$$</p><p>$$
R = R_zR_xR_y=
\begin{pmatrix}
r_{11} & r_{12} & r_{13} & 0 \\
r_{21} & r_{22} & r_{23} & 0 \\
r_{31} & r_{32} & r_{33} & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}=
\begin{pmatrix}
\bar{R} & 0 \\
0 & 1
\end{pmatrix}
$$</p><p>$$
S=
\begin{pmatrix}
s_x & 0 & 0 & 0 \\
0 & s_y & 0 & 0 \\
0 & 0 & s_z & 0 \\
0 & 0 & 0 & 1
\end{pmatrix}=
\begin{pmatrix}
\bar{S} & 0 \\
0 & 1
\end{pmatrix}
$$</p><p>则对于一个节点，其本地坐标系的TRS变换矩阵可以写作：</p><p>$$
M=\begin{pmatrix}
r_{11}S_x & r_{12}S_y & r_{13}S_z & T_x \\
r_{21}S_x & r_{22}S_y & r_{23}S_z & T_y \\
r_{31}S_x & r_{32}S_y & r_{33}S_z & T_z \\
0 & 0 & 0 & 1
\end{pmatrix}=
\begin{pmatrix}
\bar{R}\bar{S} & \bar{T} \\
0 & 1
\end{pmatrix}
$$</p><p>则对于父子节点\(M_1\)中的子节点\(M_2\)，其相对于世界坐标系的变换矩阵可以写作：</p><p>$$
M=M_2M_1=
\begin{pmatrix}
\bar{R_2}\bar{S_2} & \bar{T_2} \\
0 & 1
\end{pmatrix}
\begin{pmatrix}
\bar{R_1}\bar{S_1} & \bar{T_1} \\
0 & 1
\end{pmatrix}=
\begin{pmatrix}
\bar{R_2}\bar{S_2}\bar{R_1}\bar{S_1} & \bar{R_2}\bar{S_2}\bar{T_1}+\bar{T_2} \\
0 & 1
\end{pmatrix}
$$</p><p>从另一个角度思考，若要将\(M\)拆分成TRS三个分量，是否就对应世界坐标系下的位移、旋转、缩放（全局缩放正是我们所需要的）呢？容易观察到全局位移是：</p><p>$$
T_{world}=
\begin{pmatrix}
\bar{R_2}\bar{S_2}\bar{T_1}+\bar{T_2}
\end{pmatrix}
$$</p><p>而全局旋转由于其物理意义，必然是：</p><p>$$
R_{world}= \bar{R_2}\bar{R_1}
$$</p><p>则全局缩放只能是：</p><p>$$
S_{world}=R_{world}^{-1}\bar{R_2}\bar{S_2}\bar{R_1}\bar{S_1}=(\bar{R}_1^{-1}\bar{S_2}\bar{R_1})\bar{S_1}
$$</p><p>一般来说，\(S_{world}\)是一个非对角矩阵，即主对角线之外也有非零值。若只将主对角线元素取出来作为scale，则缩放信息是有损的，这便是Unity中<code>LossyScale</code>名字的由来。</p><p>当父节点是均匀缩放时（即\(\bar{S_2}=s_2I\)），缩放系数可以化简为\(S_{world}=\bar{S_2}\bar{S_1}=[s_x,s_y,s_z]^T\)，则整体世界变换可以独立分解为TRS三个维度分别做世界变换的组合！而且此时\(S_{world}\)是一个对角矩阵，即<code>LossyScale</code>包含了完整的缩放信息。</p><p>$$
M_{world}=T_{world}R_{world}S_{world}
$$</p><h1 id=问题的终结>问题的终结<a hidden class=anchor aria-hidden=true href=#问题的终结>#</a></h1><p>回到最初的问题上来，对Actor设置缩放时要更新所属Shape的尺寸，为此要实现的<code>GetShapeScale()</code>完整版：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Shape</span><span class=p>.</span><span class=n>Dimension</span> <span class=o>=</span> <span class=n>Shape</span><span class=p>.</span><span class=n>OriginalDimension</span> <span class=o>*</span> <span class=n>GetShapeScale</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PhysXVec3</span> <span class=nf>GetShapeScale</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>PxQuat</span> <span class=n>worldRot</span> <span class=o>=</span> <span class=n>actor</span><span class=p>.</span><span class=n>Rotation</span> <span class=o>*</span> <span class=n>shapeTransform</span><span class=p>.</span><span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PxMat33</span> <span class=n>inverseWorldRotMat</span> <span class=o>=</span> <span class=n>PxMat33</span><span class=p>(</span><span class=n>worldRot</span><span class=p>.</span><span class=n>getConjugate</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>PxMat33</span> <span class=n>localRotMat</span> <span class=o>=</span> <span class=n>PxMat33</span><span class=p>(</span><span class=n>shapeTransform</span><span class=p>.</span><span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>PxMat33</span> <span class=n>actorRotMat</span> <span class=o>=</span> <span class=n>PxMat33</span><span class=p>(</span><span class=n>actor</span><span class=p>.</span><span class=n>Rotation</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>PxMat33</span> <span class=n>actorScaleMat</span> <span class=o>=</span> <span class=n>PxMat33</span><span class=p>().</span><span class=n>createDiagonal</span><span class=p>(</span><span class=n>actor</span><span class=p>.</span><span class=n>Scale</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>PxMat33</span> <span class=n>worldRotAndScaleMat</span> <span class=o>=</span> <span class=n>actorRotMat</span> <span class=o>*</span> <span class=n>actorScaleMat</span> <span class=o>*</span> <span class=n>localRotMat</span> <span class=cm>/* * localScaleMat*/</span><span class=p>;</span> <span class=c1>// localScaleMat is always Identity Matrix, so we omit it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PxMat33</span> <span class=n>worldScaleMat</span> <span class=o>=</span> <span class=n>inverseWorldRotMat</span> <span class=o>*</span> <span class=n>worldRotAndScaleMat</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>PhysXVec3</span> <span class=n>worldscale</span> <span class=o>=</span> <span class=n>PhysXVec3</span><span class=p>(</span><span class=n>worldScaleMat</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>],</span> <span class=n>worldScaleMat</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=mi>1</span><span class=p>],</span> <span class=n>worldScaleMat</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// can have extra logic to make sure all values in worldscale are non-zero
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>worldscale</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=额外的讨论>额外的讨论<a hidden class=anchor aria-hidden=true href=#额外的讨论>#</a></h1><p>已知正确的算法是：</p><p>$$
S_{world}=(\bar{R}_1^{-1}\bar{S_2}\bar{R_1})\bar{S_1}
$$</p><p>而似是而非的算法其实是：</p><p>$$
S_{world}=(\bar{R_1}s_2)\bar{S_1}
$$</p><p>本质错误在于：</p><ul><li>正确的算法是将缩放本身视为一个空间变换\(S_2\)，进行<strong>基变换</strong>。</li><li>错误的算法是将缩放系数视为一个普通矢量\(s_2\) ，进行<strong>空间变换</strong>。</li></ul><p>这些在大一的课堂上早已学过。往往正向解释很简单，难的是反向思考，即遇到实际问题怎么选择合适的概念去解决。</p><blockquote><p>纸上得来终觉浅，绝知此事要躬行。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li><li><a href=https://pps43.github.io/tags/%E6%95%B0%E5%AD%A6/>数学</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/using_physx_collision/><span class=title>« Prev</span><br><span>PhysX物理引擎（2）Collision</span></a>
<a class=next href=https://pps43.github.io/posts/notes_on_genius_in_ghibli/><span class=title>Next »</span><br><span>吉卜力的天才们（铃木敏夫）</span></a></nav></footer></article></main><footer class=footer><span>© 2016-2023 By 波波沙.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>