<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller | æ³¢æ³¢æ²™ğŸ </title><meta name=keywords content="Game Dev,PhysX"><meta name=description content="æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXè§’è‰²æ§åˆ¶å™¨ç›¸å…³çš„å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode,"><meta name=author content><link rel=canonical href=https://pps43.github.io/posts/using_physx_cct/><link crossorigin=anonymous href=/assets/css/stylesheet.dc6c194da045b61516d4431bed7d37869927fdf64deae5a9483581931f34796a.css integrity="sha256-3GwZTaBFthUW1EMb7X03hpkn/fZN6uWpSDWBkx80eWo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://pps43.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://pps43.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://pps43.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://pps43.github.io/apple-touch-icon.png><link rel=mask-icon href=https://pps43.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css integrity="sha512-0aPQyyeZrWj9sCA46UlmWgKOP0mUipLQ6OZXu8l4IcAmD2u31EPEy9VcIMvl7SoAaKe8bLXZhYoMaE/in+gcgA==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://unpkg.com/mermaid/dist/mermaid.min.js></script>
<script>const config={startOnLoad:!0,theme:"neutral",themeVariables:{lineColor:"#aaaaaa"},flowchart:{useMaxWidth:!1,htmlLabels:!0}};mermaid.initialize(config),window.onload=()=>{window.mermaid.init(void 0,document.querySelectorAll(".language-mermaid"))}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-7GDH7EZ6GL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-7GDH7EZ6GL",{anonymize_ip:!1})}</script><meta property="og:title" content="PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller"><meta property="og:description" content="æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXè§’è‰²æ§åˆ¶å™¨ç›¸å…³çš„å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode,"><meta property="og:type" content="article"><meta property="og:url" content="https://pps43.github.io/posts/using_physx_cct/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-04T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller"><meta name=twitter:description content="æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXè§’è‰²æ§åˆ¶å™¨ç›¸å…³çš„å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode,"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://pps43.github.io/posts/"},{"@type":"ListItem","position":3,"name":"PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller","item":"https://pps43.github.io/posts/using_physx_cct/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller","name":"PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller","description":"æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXè§’è‰²æ§åˆ¶å™¨ç›¸å…³çš„å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚ PhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode,","keywords":["Game Dev","PhysX"],"articleBody":" æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXè§’è‰²æ§åˆ¶å™¨ç›¸å…³çš„å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚\nPhysXç‰©ç†å¼•æ“ç³»åˆ—è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆCode, Docï¼‰çš„ä¸€äº›ç»éªŒï¼Œæœ‰ä¸å°‘å¯¹å®˜æ–¹èµ„æ–™çš„è¡¥å……ã€‚\nWarm-up Character Controller (a.k.a CCT) is a special physical object handling player movement. In PhysX, CCT is not a Rigidbody, which means it does not integrate seamlessly in collision system. However, there is a kinematic actor underlying in CCT, and you can attach custom data via PxController::getActor()-\u003euserData.\nGenerally, CCT can be kinematic or dynamic, but according to PhysX document, kinematic controller has below advantages:\nDirect control. For dynamic rigidbody, Adding force/impulse/velocity to move player to final position is impossible. Built-in CCD. No jitter in a corner. No friction to finetune. Standing on a slope requires +inf friction, but walking on a slope without slowing down requires 0 friction. Itâ€™s difficult to tune. No restitution. For dynamic rigidbody, even with 0 restitution, it will bounce a bit, due to imperferct nature of linear solver, and the way of recovering from penetration. Easy to stick to ground. Easy to keep standup and never rotate. For dynamic rigidbody, itâ€™s difficult to really constrain that way. Joints are often used, but with less robustness and speed. Above advantages apply to all kinematic CCT, not exclusive to PhysXâ€™s CCT implementation. You can just use a real kinematic rigidbody to implement your own CCT (Ground detection, Collide-and-Slide algorithm), which can be even more flexibile than PhysXâ€™s CCT.\nCCT Setup There are two shapes of CCT, AABB and Capsule. Take Capsule as example.\nâš  In Unity, the height in inspector equals to CCT.height + 2 * CCT.radius.\nTo change height, use setHeight or resize. Skin Width To avoid numerical issue, there is a skin around character, defined by PxControllerDesc::contactOffset. E.g. 0.08, or 10% of the radius. Also called â€œContact Offsetâ€.\nFoot Position Foot position is helpful in some cases, access via PxController::getFootPosition/setFootPosition\nIf need to keep foot position when change height, use PxController::resize.\nUp Direction Up direction can be arbitrary, defined by PxController::setUpDirection().\nâš  Unity locks up direction to (0,1,0), which makes no sense and they have not changed that for years. Unity Forum\nExample Below is the creation process of a CCT, using the layer defined in â€œPhysXç‰©ç†å¼•æ“ï¼ˆ2ï¼‰Collisionâ€.\nbool PhysXManager::AddCCT(ActorWrapper \u0026actor, float radius, float height, float skinWidth, float stepOffset, float slopeLimit, int layer, int layerAgainst) { if (!m_pxControllerManager) { m_pxControllerManager = PxCreateControllerManager(*m_pxScene, true); //m_pxControllerManager-\u003esetOverlapRecoveryModule(true); m_pxControllerManager-\u003esetPreciseSweeps(false); } PxCapsuleControllerDesc desc; desc.scaleCoeff = 1; desc.position = actor.GetPosition(); desc.contactOffset = skinWidth; // (0, radius] desc.stepOffset = stepOffset \u003e height ? height : stepOffset; // [0, height] desc.slopeLimit = slopeLimit \u003e 0? slopeLimit : 0; // cos(theta), [0, 1] desc.radius = radius; // [0, ] float h = height - 2 * radius; desc.height = h \u003c 0 ? 0.001 : h; // (0, ] desc.upDirection = PxVec3(0, 1, 0); desc.material = m_pxMaterial; desc.climbingMode = PxCapsuleClimbingMode::eCONSTRAINED; desc.reportCallback = actor.GetCCTHitReportHandler(); //desc.behaviorCallback = NULL; currently we don't need this //create controller PxController* controller = m_pxControllerManager-\u003ecreateController(desc); controller-\u003egetActor()-\u003euserData = \u0026actor; actor.SetPxActor(controller); actor.SetActorType(EActorType_CCT); //set query info PxShape* shape = NULL; controller-\u003egetActor()-\u003egetShapes(\u0026shape, 1); if (shape) { PxFilterData filterData; filterData.word0 = layer; shape-\u003esetQueryFilterData(filterData); PxFilterData simFilterData; simFilterData.word0 = layer; simFilterData.word1 = layerAgainst; shape-\u003esetSimulationFilterData(simFilterData); } return false; } CCT Move Rather than PxController::setPosition, PxController::move uses a â€œcollide-and-slideâ€ algorithm. Internally, it use sweep tests in required direction. If found obstacle, CCT will slide smoothly against it.\nflags = PxController::move(disp, minDist, elapsedTime, filters, obstacles=NULL); name type description flags PxControllerCollisionFlags combination of eCOLLISION_SIDES, eCOLLISION_UP, eCOLLISION_DOWN disp PxVec3 displacement, or delta. You need to apply gravity yourself. minDist PxF32 epsilon for moving. you would better keep it 0. elapsedTime PxF32 how much time passed since last call to move. filters PxControllerFilters customize how CCT collides against the world, and with other CCT. obstacle PxObstacleContext user-defined obstacles (can be moving), only for CCT, without shape object in scene. Collide-And-Slide Here are basic ideas on implementing â€œcollide and slideâ€ algorithm yourself.\nCall a Sweep from the current position of the CCT shape to its goal position. If no initial overlap is detected, move the CCT shape to the position of the first hit, and adjust the trajectory of the CCT by removing the motion relative to the contact normal of the hit. Repeat Steps 1 and 2 until the goal is reached, or until an Sweep in Step 1 detects an initial overlap. If a Sweep in Step 1 detects an initial overlap, use the Penetration Depth computation function to generate a direction for depenetration. Move the CCT shape out of penetration and begin again with Step 1. Custom Gravity There is no internal Gravity applied on CCT. Calculate yourself and add it when calling cct-\u003emove. You may want to modify up-direction at the same time.\nCCT Interaction Hit Callback âš This is called when the CCT moves and hits a shape. This will not be called when a moving shape hits a non-moving CCT.\nHere is how to add hit callback.\nInherit class PxUserControllerHitReport and override its onShapeHit, onControllerHit, onObstacleHit to record hitinfo. E.g., in onShapeHit, you can apply forces to other rigidbody, play sounds, etc. In Unity, it records this and throw OnControllerColliderHit event. class MyControllerHitReport : public PxUserControllerHitReport { public: virtual void onShapeHit(const PxControllerShapeHit\u0026 hit); virtual void onControllerHit(const PxControllersHit\u0026 hit); virtual void onObstacleHit(const PxControllerObstacleHit\u0026 hit) {} // don't need this void Clear(); bool GetResult(PhysXCCTHitReportList\u0026 out); private: PhysXCCTHitReportList m_HitRecords; }; void MyControllerHitReport::onShapeHit(const PxControllerShapeHit\u0026 hit) { PhysXCCTHitReport result; PxRigidActor* controllerActor = hit.controller-\u003egetActor(); PxRigidActor* otherActor = hit.shape-\u003egetActor(); result.Controller = controllerActor == NULL? NULL : (ActorWrapper*)controllerActor-\u003euserData; result.Other = otherActor == NULL? NULL : (ActorWrapper*)otherActor-\u003euserData; result.HitNormal = hit.worldNormal; result.HitPosition = physx::toVec3(hit.worldPos); result.Dir = hit.dir; result.Distance = hit.length; m_HitRecords.push_back(result); } void MyControllerHitReport::onControllerHit(const PxControllersHit\u0026 hit) { //similiar to onShapeHit } //other functions When creating CharacterController, create a object of above class and assign to PxCapsuleControllerDesc.reportCallback Behaviour Callback This is called after CCT hit different objects to define three different behaviours:\nflag meaning eCCT_CAN_RIDE_ON_OBJECT Travel horizontally with the object it is standing on. eCCT_SLIDE Slide when standing on the object. It can be used to make CCT fall off a platformâ€™s edge if you think itâ€™s not enough to climb on it. eCCT_USER_DEFINED_RIDE Disable all built-in logic Here is how to add a behaviour callback.\nInherit class PxControllerBehaviorCallback and overide its â€œgetBehaviorFlagsâ€. Notice there are 3 different functions with same name, used for against shapes, CCTs and internal obstacles. Return above flag. When creating CharacterController, create a object of above class and assign to PxCapsuleControllerDesc.behaviorCallback. CCT vs Rigidbody As for CCT pushes Rigidbody, itâ€™s difficult to control by applying force at contact points. You should use onShapeHit just mentioned.\nAs for Rigidbody pushes CCT, as mentioned above, when a CCT is not moving, hitcallback wonâ€™t even called. There is no official way to solve this, see next section.\nCCT vs CCT Inherit class PxControllerFilterCallback and override its â€œfilter(const PxController\u0026 a, const PxController\u0026 b)â€ to determin if two CCTs can interact.\nIf you simply want two CCTs just overlap each other, return false. Return true means they will collide-and-slide. You can add custom logic using their shapesâ€™ PxFilterData.\nclass ControllerFilterCallback : PxControllerFilterCallback { public: virtual bool filter(const PxController\u0026 a, const PxController\u0026 b) { PxShape* shapeA = NULL; a.getActor()-\u003egetShapes(\u0026shapeA, 1); PxShape* shapeB = NULL; b.getActor()-\u003egetShapes(\u0026shapeB, 1); const physx::PxFilterData filterData0 = shapeA-\u003egetQueryFilterData(); const physx::PxFilterData filterData1 = shapeB-\u003egetQueryFilterData(); if ((0 == (filterData0.word0 \u0026 filterData1.word1)) || (0 == (filterData1.word0 \u0026 filterData0.word1))) { return false; } return true; } } In each CCT.Move, create a object of above class and pass as filter. Golden Tips CCTâ€™s slopeLimit must be [0, 1] ([0, 90] in degree). Otherwise PhysX crashes.\nCCTâ€™s stepOffset must be [0, height]. Otherwise PhysX crashes.\nCCTâ€™s height must be positive number (0, ). Otherwise Physx crashes.\nCCTâ€™s skinWidth must be positive number (0, radius). Otherwise Physx crashes.\nUnity does not draw skinWidth in scene view, but it exists as part of volumn.\nUnity locks upvector to (0,1,0) so you canâ€™t rotate controller.\nUnityâ€™s IsGrounded is NOT reliable at all. Itâ€™s just implemented as collisionFlags \u0026 eCOLLISION_DOWN::eCOLLISION_DOWN, but very often when running uphill, the flag is eCOLLISION_SIDES so you get wrong result that IsGrounded == false. You should use capsule raycast or anything else to implement your own Ground-Detection algorithm. When CCT is not moving, it loses the ability to collide with non-dynamic physical objects. That is, it will penetrate into a kinematic moving platform. There is NO official way to solve it since itâ€™s as designed by PhysX. To solve this, add a minor movement every frame on your CCT, e.g., 0.001 * Forward * deltaTime. See more discussion.\n","wordCount":"1514","inLanguage":"en","datePublished":"2023-12-04T00:00:00Z","dateModified":"2023-12-04T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://pps43.github.io/posts/using_physx_cct/"},"publisher":{"@type":"Organization","name":"æ³¢æ³¢æ²™ğŸ ","logo":{"@type":"ImageObject","url":"https://pps43.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://pps43.github.io accesskey=h title="æ³¢æ³¢æ²™ğŸ  (Alt + H)">æ³¢æ³¢æ²™ğŸ </a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://pps43.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://pps43.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://pps43.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://book.enginew.cn/ title=BookOfGameDev><span>BookOfGameDev</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>PhysXç‰©ç†å¼•æ“ï¼ˆ4ï¼‰Character Controller</h1><div class=post-meta><span title='2023-12-04 00:00:00 +0000 UTC'>December 4, 2023</span>&nbsp;Â·&nbsp;4 min</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#warm-up aria-label=Warm-up>Warm-up</a></li><li><a href=#cct-setup aria-label="CCT Setup">CCT Setup</a><ul><li><a href=#skin-width aria-label="Skin Width">Skin Width</a></li><li><a href=#foot-position aria-label="Foot Position">Foot Position</a></li><li><a href=#up-direction aria-label="Up Direction">Up Direction</a></li><li><a href=#example aria-label=Example>Example</a></li></ul></li><li><a href=#cct-move aria-label="CCT Move">CCT Move</a><ul><li><a href=#collide-and-slide aria-label=Collide-And-Slide>Collide-And-Slide</a></li><li><a href=#custom-gravity aria-label="Custom Gravity">Custom Gravity</a></li></ul></li><li><a href=#cct-interaction aria-label="CCT Interaction">CCT Interaction</a><ul><li><a href=#hit-callback aria-label="Hit Callback">Hit Callback</a></li><li><a href=#behaviour-callback aria-label="Behaviour Callback">Behaviour Callback</a></li><li><a href=#cct-vs-rigidbody aria-label="CCT vs Rigidbody">CCT vs Rigidbody</a></li><li><a href=#cct-vs-cct aria-label="CCT vs CCT">CCT vs CCT</a></li></ul></li><li><a href=#golden-tips aria-label="Golden Tips">Golden Tips</a></li></ul></div></details></div><div class=post-content><blockquote><p>æœ¬æ–‡ä¸»è¦ä»‹ç»PhysXè§’è‰²æ§åˆ¶å™¨ç›¸å…³çš„å†…éƒ¨æœºåˆ¶å’Œä½¿ç”¨æ–¹æ³•ã€‚</p><p><a href=https://pps43.github.io/tags/physx/>PhysXç‰©ç†å¼•æ“ç³»åˆ—</a>è®°å½•äº†åœ¨å®é™…é¡¹ç›®ä¸­ä½¿ç”¨Nvdia PhysX 3.4ç‰©ç†å¼•æ“ï¼ˆ<a href=https://github.com/pps43/PhysX-3.4>Code</a>, <a href=https://github.com/pps43/PhysX-3.4/raw/master/PhysX_3.4/Documentation/PhysXGuide.chm>Doc</a>ï¼‰çš„ä¸€äº›ç»éªŒï¼Œæœ‰ä¸å°‘å¯¹å®˜æ–¹èµ„æ–™çš„è¡¥å……ã€‚</p></blockquote><h1 id=warm-up>Warm-up<a hidden class=anchor aria-hidden=true href=#warm-up>#</a></h1><p>Character Controller (a.k.a CCT) is a special physical object handling player movement. In PhysX, CCT is not a Rigidbody, which means it does not integrate seamlessly in collision system. However, there is a kinematic actor underlying in CCT, and you can attach custom data via <code>PxController::getActor()->userData</code>.</p><p>Generally, CCT can be kinematic or dynamic, but according to PhysX document, kinematic controller has below advantages:</p><ul><li>Direct control. For dynamic rigidbody, Adding force/impulse/velocity to move player to final position is impossible.</li><li>Built-in CCD.</li><li>No <strong>jitter</strong> in a corner.</li><li>No <strong>friction</strong> to finetune. Standing on a slope requires +inf friction, but walking on a slope without slowing down requires 0 friction. It&rsquo;s difficult to tune.</li><li>No <strong>restitution</strong>. For dynamic rigidbody, even with 0 restitution, it will bounce a bit, due to imperferct nature of linear solver, and the way of recovering from penetration.</li><li>Easy to stick to ground.</li><li>Easy to keep standup and never rotate. For dynamic rigidbody, it&rsquo;s difficult to really constrain that way. Joints are often used, but with less robustness and speed.</li></ul><blockquote><p>Above advantages apply to all kinematic CCT, not exclusive to PhysX&rsquo;s CCT implementation. You can just use a real kinematic rigidbody to implement your own CCT (Ground detection, Collide-and-Slide algorithm), which can be even more flexibile than PhysX&rsquo;s CCT.</p></blockquote><h1 id=cct-setup>CCT Setup<a hidden class=anchor aria-hidden=true href=#cct-setup>#</a></h1><p>There are two shapes of CCT, AABB and Capsule. Take Capsule as example.</p><p><img loading=lazy src=/using_physx_cct/capsule_shape.png alt></p><blockquote><p>âš  In Unity, the height in inspector equals to <code>CCT.height + 2 * CCT.radius</code>.</p></blockquote><p>To change height, use <code>setHeight</code> or <code>resize</code>.
<img loading=lazy src=/using_physx_cct/resize.png alt></p><h2 id=skin-width>Skin Width<a hidden class=anchor aria-hidden=true href=#skin-width>#</a></h2><p>To avoid numerical issue, there is a skin around character, defined by <code>PxControllerDesc::contactOffset</code>. E.g. 0.08, or 10% of the radius. Also called &ldquo;Contact Offset&rdquo;.</p><h2 id=foot-position>Foot Position<a hidden class=anchor aria-hidden=true href=#foot-position>#</a></h2><p><img loading=lazy src=/using_physx_cct/footposition.png alt></p><p>Foot position is helpful in some cases, access via <code>PxController::getFootPosition/setFootPosition</code></p><p>If need to keep foot position when change height, use <code>PxController::resize</code>.</p><h2 id=up-direction>Up Direction<a hidden class=anchor aria-hidden=true href=#up-direction>#</a></h2><p><img loading=lazy src=/using_physx_cct/upvector.png alt></p><p>Up direction can be arbitrary, defined by <code>PxController::setUpDirection()</code>.</p><blockquote><p>âš  Unity locks up direction to <code>(0,1,0)</code>, which makes no sense and they have not changed that for years. <a href=https://forum.unity.com/threads/request-unity-to-add-support-for-arbitrary-up-axis-for-charactercontroller.480962/>Unity Forum</a></p></blockquote><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><p>Below is the creation process of a CCT, using the layer defined in <a href=https://pps43.github.io/posts/using_physx_collision/>&ldquo;PhysXç‰©ç†å¼•æ“ï¼ˆ2ï¼‰Collision&rdquo;</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=n>PhysXManager</span><span class=o>::</span><span class=n>AddCCT</span><span class=p>(</span><span class=n>ActorWrapper</span> <span class=o>&amp;</span><span class=n>actor</span><span class=p>,</span> <span class=kt>float</span> <span class=n>radius</span><span class=p>,</span> <span class=kt>float</span> <span class=n>height</span><span class=p>,</span> <span class=kt>float</span> <span class=n>skinWidth</span><span class=p>,</span> <span class=kt>float</span> <span class=n>stepOffset</span><span class=p>,</span> <span class=kt>float</span> <span class=n>slopeLimit</span><span class=p>,</span> <span class=kt>int</span> <span class=n>layer</span><span class=p>,</span> <span class=kt>int</span> <span class=n>layerAgainst</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>m_pxControllerManager</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>m_pxControllerManager</span> <span class=o>=</span> <span class=n>PxCreateControllerManager</span><span class=p>(</span><span class=o>*</span><span class=n>m_pxScene</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>//m_pxControllerManager-&gt;setOverlapRecoveryModule(true);
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>m_pxControllerManager</span><span class=o>-&gt;</span><span class=n>setPreciseSweeps</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>PxCapsuleControllerDesc</span> <span class=n>desc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>scaleCoeff</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>position</span> <span class=o>=</span> <span class=n>actor</span><span class=p>.</span><span class=n>GetPosition</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>contactOffset</span> <span class=o>=</span> <span class=n>skinWidth</span><span class=p>;</span> <span class=c1>// (0, radius]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>desc</span><span class=p>.</span><span class=n>stepOffset</span> <span class=o>=</span> <span class=n>stepOffset</span> <span class=o>&gt;</span> <span class=n>height</span> <span class=o>?</span> <span class=nl>height</span> <span class=p>:</span> <span class=n>stepOffset</span><span class=p>;</span> <span class=c1>// [0, height]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>desc</span><span class=p>.</span><span class=n>slopeLimit</span> <span class=o>=</span> <span class=n>slopeLimit</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=o>?</span> <span class=nl>slopeLimit</span> <span class=p>:</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// cos(theta), [0, 1]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>desc</span><span class=p>.</span><span class=n>radius</span> <span class=o>=</span> <span class=n>radius</span><span class=p>;</span> <span class=c1>// [0, ]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>float</span> <span class=n>h</span> <span class=o>=</span> <span class=n>height</span> <span class=o>-</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>radius</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>height</span> <span class=o>=</span> <span class=n>h</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=o>?</span> <span class=mf>0.001</span> <span class=o>:</span> <span class=n>h</span><span class=p>;</span> <span class=c1>// (0, ]
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>desc</span><span class=p>.</span><span class=n>upDirection</span> <span class=o>=</span> <span class=n>PxVec3</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>material</span> <span class=o>=</span> <span class=n>m_pxMaterial</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>climbingMode</span> <span class=o>=</span> <span class=n>PxCapsuleClimbingMode</span><span class=o>::</span><span class=n>eCONSTRAINED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>desc</span><span class=p>.</span><span class=n>reportCallback</span> <span class=o>=</span> <span class=n>actor</span><span class=p>.</span><span class=n>GetCCTHitReportHandler</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>//desc.behaviorCallback = NULL; currently we don&#39;t need this
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>//create controller
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>PxController</span><span class=o>*</span> <span class=n>controller</span> <span class=o>=</span> <span class=n>m_pxControllerManager</span><span class=o>-&gt;</span><span class=n>createController</span><span class=p>(</span><span class=n>desc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>controller</span><span class=o>-&gt;</span><span class=n>getActor</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>userData</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>actor</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=p>.</span><span class=n>SetPxActor</span><span class=p>(</span><span class=n>controller</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>actor</span><span class=p>.</span><span class=n>SetActorType</span><span class=p>(</span><span class=n>EActorType_CCT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//set query info
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>PxShape</span><span class=o>*</span> <span class=n>shape</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>controller</span><span class=o>-&gt;</span><span class=n>getActor</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getShapes</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shape</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>shape</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PxFilterData</span> <span class=n>filterData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>filterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=n>layer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>shape</span><span class=o>-&gt;</span><span class=n>setQueryFilterData</span><span class=p>(</span><span class=n>filterData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>PxFilterData</span> <span class=n>simFilterData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>simFilterData</span><span class=p>.</span><span class=n>word0</span> <span class=o>=</span> <span class=n>layer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>simFilterData</span><span class=p>.</span><span class=n>word1</span> <span class=o>=</span> <span class=n>layerAgainst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>shape</span><span class=o>-&gt;</span><span class=n>setSimulationFilterData</span><span class=p>(</span><span class=n>simFilterData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=cct-move>CCT Move<a hidden class=anchor aria-hidden=true href=#cct-move>#</a></h1><p>Rather than <code>PxController::setPosition</code>, <code>PxController::move</code> uses a &ldquo;collide-and-slide&rdquo; algorithm. Internally, it use sweep tests in required direction. If found obstacle, CCT will slide smoothly against it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>flags</span> <span class=o>=</span> <span class=n>PxController</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>disp</span><span class=p>,</span> <span class=n>minDist</span><span class=p>,</span> <span class=n>elapsedTime</span><span class=p>,</span> <span class=n>filters</span><span class=p>,</span> <span class=n>obstacles</span><span class=o>=</span><span class=nb>NULL</span><span class=p>);</span>
</span></span></code></pre></div><table><thead><tr><th>name</th><th>type</th><th>description</th></tr></thead><tbody><tr><td>flags</td><td>PxControllerCollisionFlags</td><td>combination of <code>eCOLLISION_SIDES</code>, <code>eCOLLISION_UP</code>, <code>eCOLLISION_DOWN</code></td></tr><tr><td>disp</td><td>PxVec3</td><td>displacement, or delta. You need to apply gravity yourself.</td></tr><tr><td>minDist</td><td>PxF32</td><td>epsilon for moving. you would better keep it 0.</td></tr><tr><td>elapsedTime</td><td>PxF32</td><td>how much time passed since last call to move.</td></tr><tr><td>filters</td><td>PxControllerFilters</td><td>customize how CCT collides against the world, and with other CCT.</td></tr><tr><td>obstacle</td><td>PxObstacleContext</td><td>user-defined obstacles (can be moving), only for CCT, without shape object in scene.</td></tr></tbody></table><h2 id=collide-and-slide>Collide-And-Slide<a hidden class=anchor aria-hidden=true href=#collide-and-slide>#</a></h2><p>Here are basic ideas on implementing &ldquo;collide and slide&rdquo; algorithm yourself.</p><ol><li>Call a Sweep from the current position of the CCT shape to its goal position.</li><li>If no initial overlap is detected, move the CCT shape to the position of the first hit, and adjust the trajectory of the CCT by removing the motion relative to the contact normal of the hit.</li><li>Repeat Steps 1 and 2 until the goal is reached, or until an Sweep in Step 1 detects an initial overlap.</li><li>If a Sweep in Step 1 detects an initial overlap, use the Penetration Depth computation function to generate a direction for depenetration. Move the CCT shape out of penetration and begin again with Step 1.</li></ol><h2 id=custom-gravity>Custom Gravity<a hidden class=anchor aria-hidden=true href=#custom-gravity>#</a></h2><p>There is no internal Gravity applied on CCT. Calculate yourself and add it when calling <code>cct->move</code>. You may want to modify up-direction at the same time.</p><h1 id=cct-interaction>CCT Interaction<a hidden class=anchor aria-hidden=true href=#cct-interaction>#</a></h1><h2 id=hit-callback>Hit Callback<a hidden class=anchor aria-hidden=true href=#hit-callback>#</a></h2><p>âš <strong>This is called when the CCT moves and hits a shape. This will not be called when a moving shape hits a non-moving CCT</strong>.</p><p>Here is how to add hit callback.</p><ol><li>Inherit class <code>PxUserControllerHitReport</code> and override its <code>onShapeHit</code>, <code>onControllerHit</code>, <code>onObstacleHit</code> to record hitinfo. E.g., in <code>onShapeHit</code>, you can apply forces to other rigidbody, play sounds, etc. In Unity, it records this and throw <code>OnControllerColliderHit</code> event.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyControllerHitReport</span> <span class=o>:</span> <span class=k>public</span> <span class=n>PxUserControllerHitReport</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=n>onShapeHit</span><span class=p>(</span><span class=k>const</span> <span class=n>PxControllerShapeHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onControllerHit</span><span class=p>(</span><span class=k>const</span> <span class=n>PxControllersHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>void</span> <span class=nf>onObstacleHit</span><span class=p>(</span><span class=k>const</span> <span class=n>PxControllerObstacleHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// don&#39;t need this
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=nf>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=nf>GetResult</span><span class=p>(</span><span class=n>PhysXCCTHitReportList</span><span class=o>&amp;</span> <span class=n>out</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXCCTHitReportList</span> <span class=n>m_HitRecords</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MyControllerHitReport</span><span class=o>::</span><span class=n>onShapeHit</span><span class=p>(</span><span class=k>const</span> <span class=n>PxControllerShapeHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>PhysXCCTHitReport</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>controllerActor</span> <span class=o>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>controller</span><span class=o>-&gt;</span><span class=n>getActor</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=n>PxRigidActor</span><span class=o>*</span> <span class=n>otherActor</span> <span class=o>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>shape</span><span class=o>-&gt;</span><span class=n>getActor</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>result</span><span class=p>.</span><span class=n>Controller</span> <span class=o>=</span> <span class=n>controllerActor</span> <span class=o>==</span> <span class=nb>NULL</span><span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=p>(</span><span class=n>ActorWrapper</span><span class=o>*</span><span class=p>)</span><span class=n>controllerActor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>result</span><span class=p>.</span><span class=n>Other</span> <span class=o>=</span> <span class=n>otherActor</span> <span class=o>==</span> <span class=nb>NULL</span><span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=p>(</span><span class=n>ActorWrapper</span><span class=o>*</span><span class=p>)</span><span class=n>otherActor</span><span class=o>-&gt;</span><span class=n>userData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>result</span><span class=p>.</span><span class=n>HitNormal</span> <span class=o>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>worldNormal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>result</span><span class=p>.</span><span class=n>HitPosition</span> <span class=o>=</span> <span class=n>physx</span><span class=o>::</span><span class=n>toVec3</span><span class=p>(</span><span class=n>hit</span><span class=p>.</span><span class=n>worldPos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>result</span><span class=p>.</span><span class=n>Dir</span> <span class=o>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>dir</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>result</span><span class=p>.</span><span class=n>Distance</span> <span class=o>=</span> <span class=n>hit</span><span class=p>.</span><span class=n>length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>m_HitRecords</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MyControllerHitReport</span><span class=o>::</span><span class=n>onControllerHit</span><span class=p>(</span><span class=k>const</span> <span class=n>PxControllersHit</span><span class=o>&amp;</span> <span class=n>hit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//similiar to onShapeHit
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//other functions
</span></span></span></code></pre></div><ol start=2><li>When creating CharacterController, create a object of above class and assign to <code>PxCapsuleControllerDesc.reportCallback</code></li></ol><h2 id=behaviour-callback>Behaviour Callback<a hidden class=anchor aria-hidden=true href=#behaviour-callback>#</a></h2><p>This is called after CCT hit different objects to define three different behaviours:</p><table><thead><tr><th>flag</th><th>meaning</th></tr></thead><tbody><tr><td><code>eCCT_CAN_RIDE_ON_OBJECT</code></td><td>Travel horizontally with the object it is standing on.</td></tr><tr><td><code>eCCT_SLIDE</code></td><td>Slide when standing on the object. It can be used to make CCT fall off a platform&rsquo;s edge if you think it&rsquo;s not enough to climb on it.</td></tr><tr><td><code>eCCT_USER_DEFINED_RIDE</code></td><td>Disable all built-in logic</td></tr></tbody></table><p>Here is how to add a behaviour callback.</p><ol><li>Inherit class PxControllerBehaviorCallback and overide its &ldquo;getBehaviorFlags&rdquo;. Notice there are 3 different functions with same name, used for against shapes, CCTs and internal obstacles. Return above flag.</li><li>When creating CharacterController, create a object of above class and assign to <code>PxCapsuleControllerDesc.behaviorCallback</code>.</li></ol><h2 id=cct-vs-rigidbody>CCT vs Rigidbody<a hidden class=anchor aria-hidden=true href=#cct-vs-rigidbody>#</a></h2><p>As for CCT pushes Rigidbody, it&rsquo;s difficult to control by applying force at contact points. You should use <code>onShapeHit</code> just mentioned.</p><p>As for Rigidbody pushes CCT, as mentioned above, when a CCT is not moving, hitcallback won&rsquo;t even called. There is no official way to solve this, see <a href=#golden-tips>next section</a>.</p><h2 id=cct-vs-cct>CCT vs CCT<a hidden class=anchor aria-hidden=true href=#cct-vs-cct>#</a></h2><ol><li><p>Inherit class <code>PxControllerFilterCallback</code> and override its &ldquo;<code>filter(const PxController& a, const PxController& b)</code>&rdquo; to determin if two CCTs can interact.</p></li><li><p>If you simply want two CCTs just overlap each other, return <code>false</code>. Return <code>true</code> means they will collide-and-slide. You can add custom logic using their shapes&rsquo; <code>PxFilterData</code>.</p></li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ControllerFilterCallback</span> <span class=o>:</span> <span class=n>PxControllerFilterCallback</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>virtual</span> <span class=kt>bool</span> <span class=n>filter</span><span class=p>(</span><span class=k>const</span> <span class=n>PxController</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>PxController</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PxShape</span><span class=o>*</span> <span class=n>shapeA</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>a</span><span class=p>.</span><span class=n>getActor</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getShapes</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shapeA</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>					
</span></span><span class=line><span class=cl>		<span class=n>PxShape</span><span class=o>*</span> <span class=n>shapeB</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>b</span><span class=p>.</span><span class=n>getActor</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getShapes</span><span class=p>(</span><span class=o>&amp;</span><span class=n>shapeB</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>					
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>physx</span><span class=o>::</span><span class=n>PxFilterData</span> <span class=n>filterData0</span> <span class=o>=</span> <span class=n>shapeA</span><span class=o>-&gt;</span><span class=n>getQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=k>const</span> <span class=n>physx</span><span class=o>::</span><span class=n>PxFilterData</span> <span class=n>filterData1</span> <span class=o>=</span> <span class=n>shapeB</span><span class=o>-&gt;</span><span class=n>getQueryFilterData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>((</span><span class=mi>0</span> <span class=o>==</span> <span class=p>(</span><span class=n>filterData0</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData1</span><span class=p>.</span><span class=n>word1</span><span class=p>))</span> <span class=o>||</span> <span class=p>(</span><span class=mi>0</span> <span class=o>==</span> <span class=p>(</span><span class=n>filterData1</span><span class=p>.</span><span class=n>word0</span> <span class=o>&amp;</span> <span class=n>filterData0</span><span class=p>.</span><span class=n>word1</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>		<span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ol start=3><li>In each CCT.Move, create a object of above class and pass as filter.</li></ol><h1 id=golden-tips>Golden Tips<a hidden class=anchor aria-hidden=true href=#golden-tips>#</a></h1><ul><li><p>CCT&rsquo;s <code>slopeLimit</code> must be <code>[0, 1]</code> (<code>[0, 90]</code> in degree). Otherwise PhysX crashes.</p></li><li><p>CCT&rsquo;s <code>stepOffset</code> must be <code>[0, height]</code>. Otherwise PhysX crashes.</p></li><li><p>CCT&rsquo;s <code>height</code> must be positive number <code>(0, )</code>. Otherwise Physx crashes.</p></li><li><p>CCT&rsquo;s <code>skinWidth</code> must be positive number <code>(0, radius)</code>. Otherwise Physx crashes.</p></li><li><p>Unity does not draw <code>skinWidth</code> in scene view, but it exists as part of volumn.</p></li><li><p>Unity locks upvector to <code>(0,1,0)</code> so you can&rsquo;t rotate controller.</p></li><li><p>Unity&rsquo;s <code>IsGrounded</code> is NOT reliable at all. It&rsquo;s just implemented as <code>collisionFlags & eCOLLISION_DOWN::eCOLLISION_DOWN</code>, but very often when running uphill, the flag is <code>eCOLLISION_SIDES</code> so you get wrong result that <code>IsGrounded == false</code>. You should use <code>capsule raycast</code> or anything else to implement your own Ground-Detection algorithm.
<img loading=lazy src=/using_physx_cct/Unity_IsGround.png alt></p></li><li><p>When CCT is not moving, it loses the ability to collide with non-dynamic physical objects. That is, it will penetrate into a kinematic moving platform. <strong>There is NO official way to solve it</strong> since it&rsquo;s as designed by PhysX. To solve this, add a minor movement every frame on your CCT, e.g., <code>0.001 * Forward * deltaTime</code>. <a href=https://forum.unity.com/threads/proper-collision-detection-with-charactercontroller.292598/>See more discussion</a>.</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://pps43.github.io/tags/game-dev/>Game Dev</a></li><li><a href=https://pps43.github.io/tags/physx/>PhysX</a></li></ul><nav class=paginav><a class=prev href=https://pps43.github.io/posts/notes_on_physics_based_cct/><span class=title>Â« Prev</span><br><span>å¸¦ç‰©ç†äº¤äº’çš„CharacterControllerè®¾è®¡ä¸å®ç°</span></a>
<a class=next href=https://pps43.github.io/posts/using_physx_rigidbody/><span class=title>Next Â»</span><br><span>PhysXç‰©ç†å¼•æ“ï¼ˆ3ï¼‰Rigidbody Dynamics</span></a></nav></footer></article></main><footer class=footer><span>Â© 2016-2023 By æ³¢æ³¢æ²™.</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>